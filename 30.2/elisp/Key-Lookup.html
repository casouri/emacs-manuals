<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.2.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Key Lookup (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Key Lookup (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Key Lookup (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Keymaps.html" rel="up" title="Keymaps">
<link href="Functions-for-Key-Lookup.html" rel="next" title="Functions for Key Lookup">
<link href="Controlling-Active-Maps.html" rel="prev" title="Controlling Active Maps">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Key-Lookup">
<div class="nav-panel">
<p>
Next: <a href="Functions-for-Key-Lookup.html" accesskey="n" rel="next">Functions for Key Lookup</a>, Previous: <a href="Controlling-Active-Maps.html" accesskey="p" rel="prev">Controlling the Active Keymaps</a>, Up: <a href="Keymaps.html" accesskey="u" rel="up">Keymaps</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Key-Lookup-1"><span>23.10 Key Lookup<a class="copiable-link" href="#Key-Lookup-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-key-lookup"></a>
<a class="index-entry-id" id="index-keymap-entry"></a>

<p><em class="dfn">Key lookup</em> is the process of finding the binding of a key
sequence from a given keymap.  The execution or use of the binding is
not part of key lookup.
</p>
<p>Key lookup uses just the event type of each event in the key sequence;
the rest of the event is ignored.  In fact, a key sequence used for key
lookup may designate a mouse event with just its types (a symbol)
instead of the entire event (a list).  See <a class="xref" href="Input-Events.html">Input Events</a>.  Such
a key sequence is insufficient for <code class="code">command-execute</code> to run,
but it is sufficient for looking up or rebinding a key.
</p>
<p>When the key sequence consists of multiple events, key lookup
processes the events sequentially: the binding of the first event is
found, and must be a keymap; then the second event&rsquo;s binding is found in
that keymap, and so on until all the events in the key sequence are used
up.  (The binding thus found for the last event may or may not be a
keymap.)  Thus, the process of key lookup is defined in terms of a
simpler process for looking up a single event in a keymap.  How that is
done depends on the type of object associated with the event in that
keymap.
</p>
<p>Let&rsquo;s use the term <em class="dfn">keymap entry</em> to describe the value found by
looking up an event type in a keymap.  (This doesn&rsquo;t include the item
string and other extra elements in a keymap element for a menu item, because
<code class="code">keymap-lookup</code> and other key lookup functions don&rsquo;t include them in
the returned value.)  While any Lisp object may be stored in a keymap
as a keymap entry, not all make sense for key lookup.  Here is a table
of the meaningful types of keymap entries:
</p>
<dl class="table">
<dt><a id="index-nil-in-keymap"></a><span><code class="code">nil</code><a class="copiable-link" href="#index-nil-in-keymap"> &para;</a></span></dt>
<dd><p><code class="code">nil</code> means that the events used so far in the lookup form an
undefined key.  When a keymap fails to mention an event type at all, and
has no default binding, that is equivalent to a binding of <code class="code">nil</code>
for that event type.
</p>
</dd>
<dt><a id="index-command-in-keymap"></a><span><var class="var">command</var><a class="copiable-link" href="#index-command-in-keymap"> &para;</a></span></dt>
<dd><p>The events used so far in the lookup form a complete key,
and <var class="var">command</var> is its binding.  See <a class="xref" href="What-Is-a-Function.html">What Is a Function?</a>.
</p>
</dd>
<dt><a id="index-string-in-keymap"></a><span><var class="var">array</var><a class="copiable-link" href="#index-string-in-keymap"> &para;</a></span></dt>
<dd><p>The array (either a string or a vector) is a keyboard macro.  The events
used so far in the lookup form a complete key, and the array is its
binding.  See <a class="ref" href="Keyboard-Macros.html">Keyboard Macros</a>, for more information.
</p>
</dd>
<dt><a id="index-keymap-in-keymap"></a><span><var class="var">keymap</var><a class="copiable-link" href="#index-keymap-in-keymap"> &para;</a></span></dt>
<dd><p>The events used so far in the lookup form a prefix key.  The next
event of the key sequence is looked up in <var class="var">keymap</var>.
</p>
</dd>
<dt><a id="index-list-in-keymap"></a><span><var class="var">list</var><a class="copiable-link" href="#index-list-in-keymap"> &para;</a></span></dt>
<dd><p>The meaning of a list depends on what it contains:
</p>
<ul class="itemize mark-bullet">
<li>If the <small class="sc">CAR</small> of <var class="var">list</var> is the symbol <code class="code">keymap</code>, then the list
is a keymap, and is treated as a keymap (see above).

</li><li><a class="index-entry-id" id="index-lambda-in-keymap"></a>
If the <small class="sc">CAR</small> of <var class="var">list</var> is <code class="code">lambda</code>, then the list is a
lambda expression.  This is presumed to be a function, and is treated
as such (see above).  In order to execute properly as a key binding,
this function must be a command&mdash;it must have an <code class="code">interactive</code>
specification.  See <a class="xref" href="Defining-Commands.html">Defining Commands</a>.
</li></ul>

</dd>
<dt><a id="index-symbol-in-keymap"></a><span><var class="var">symbol</var><a class="copiable-link" href="#index-symbol-in-keymap"> &para;</a></span></dt>
<dd><p>The function definition of <var class="var">symbol</var> is used in place of
<var class="var">symbol</var>.  If that too is a symbol, then this process is repeated,
any number of times.  Ultimately this should lead to an object that is
a keymap, a command, or a keyboard macro.
</p>
<p>Note that keymaps and keyboard macros (strings and vectors) are not
valid functions, so a symbol with a keymap, string, or vector as its
function definition is invalid as a function.  It is, however, valid as
a key binding.  If the definition is a keyboard macro, then the symbol
is also valid as an argument to <code class="code">command-execute</code>
(see <a class="pxref" href="Interactive-Call.html">Interactive Call</a>).
</p>
<a class="index-entry-id" id="index-undefined-in-keymap"></a>
<p>The symbol <code class="code">undefined</code> is worth special mention: it means to treat
the key as undefined.  Strictly speaking, the key is defined, and its
binding is the command <code class="code">undefined</code>; but that command does the same
thing that is done automatically for an undefined key: it rings the bell
(by calling <code class="code">ding</code>) but does not signal an error.
</p>
<a class="index-entry-id" id="index-preventing-prefix-key"></a>
<p><code class="code">undefined</code> is used in local keymaps to override a global key
binding and make the key undefined locally.  A local binding of
<code class="code">nil</code> would fail to do this because it would not override the
global binding.
</p>
</dd>
<dt><var class="var">anything else</var></dt>
<dd><p>If any other type of object is found, the events used so far in the
lookup form a complete key, and the object is its binding, but the
binding is not executable as a command.
</p></dd>
</dl>

<p>In short, a keymap entry may be a keymap, a command, a keyboard
macro, a symbol that leads to one of them, or <code class="code">nil</code>.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Functions-for-Key-Lookup.html">Functions for Key Lookup</a>, Previous: <a href="Controlling-Active-Maps.html">Controlling the Active Keymaps</a>, Up: <a href="Keymaps.html">Keymaps</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
