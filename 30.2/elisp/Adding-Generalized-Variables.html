<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.2.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Adding Generalized Variables (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Adding Generalized Variables (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Adding Generalized Variables (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Generalized-Variables.html" rel="up" title="Generalized Variables">
<link href="Setting-Generalized-Variables.html" rel="prev" title="Setting Generalized Variables">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Adding-Generalized-Variables">
<div class="nav-panel">
<p>
Previous: <a href="Setting-Generalized-Variables.html" accesskey="p" rel="prev">The <code class="code">setf</code> Macro</a>, Up: <a href="Generalized-Variables.html" accesskey="u" rel="up">Generalized Variables</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Defining-new-setf-forms"><span>12.17.2 Defining new <code class="code">setf</code> forms<a class="copiable-link" href="#Defining-new-setf-forms"> &para;</a></span></h4>

<p>This section describes how to define new forms that <code class="code">setf</code> can
operate on.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-gv_002ddefine_002dsimple_002dsetter"><span class="category-def">Macro: </span><span><strong class="def-name">gv-define-simple-setter</strong> <var class="def-var-arguments">name setter &amp;optional fix-return</var><a class="copiable-link" href="#index-gv_002ddefine_002dsimple_002dsetter"> &para;</a></span></dt>
<dd><p>This macro enables you to easily define <code class="code">setf</code> methods for simple
cases.  <var class="var">name</var> is the name of a function, macro, or special form.
You can use this macro whenever <var class="var">name</var> has a directly
corresponding <var class="var">setter</var> function that updates it, e.g.,
<code class="code">(gv-define-simple-setter car setcar)</code>.
</p>
<p>This macro translates a call of the form
</p>
<div class="example">
<pre class="example-preformatted">(setf (<var class="var">name</var> <var class="var">args</var>...) <var class="var">value</var>)
</pre></div>

<p>into
</p><div class="example">
<pre class="example-preformatted">(<var class="var">setter</var> <var class="var">args</var>... <var class="var">value</var>)
</pre></div>

<p>Such a <code class="code">setf</code> call is documented to return <var class="var">value</var>.  This is
no problem with, e.g., <code class="code">car</code> and <code class="code">setcar</code>, because
<code class="code">setcar</code> returns the value that it set.  If your <var class="var">setter</var>
function does not return <var class="var">value</var>, use a non-<code class="code">nil</code> value for
the <var class="var">fix-return</var> argument of <code class="code">gv-define-simple-setter</code>.  This
expands into something equivalent to
</p><div class="example">
<pre class="example-preformatted">(let ((temp <var class="var">value</var>))
  (<var class="var">setter</var> <var class="var">args</var>... temp)
  temp)
</pre></div>
<p>so ensuring that it returns the correct result.
</p></dd></dl>


<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-gv_002ddefine_002dsetter"><span class="category-def">Macro: </span><span><strong class="def-name">gv-define-setter</strong> <var class="def-var-arguments">name arglist &amp;rest body</var><a class="copiable-link" href="#index-gv_002ddefine_002dsetter"> &para;</a></span></dt>
<dd><p>This macro allows for more complex <code class="code">setf</code> expansions than the
previous form.  You may need to use this form, for example, if there
is no simple setter function to call, or if there is one but it
requires different arguments to the place form.
</p>
<p>This macro expands the form
<code class="code">(setf (<var class="var">name</var> <var class="var">args</var>&hellip;) <var class="var">value</var>)</code> by
first binding the <code class="code">setf</code> argument forms
<code class="code">(<var class="var">value</var> <var class="var">args</var>&hellip;)</code> according to <var class="var">arglist</var>,
and then executing <var class="var">body</var>.  <var class="var">body</var> should return a Lisp
form that does the assignment, and finally returns the value that was
set.  An example of using this macro is:
</p>
<div class="example">
<pre class="example-preformatted">(gv-define-setter caar (val x) `(setcar (car ,x) ,val))
</pre></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-gv_002ddefine_002dexpander"><span class="category-def">Macro: </span><span><strong class="def-name">gv-define-expander</strong> <var class="def-var-arguments">name handler</var><a class="copiable-link" href="#index-gv_002ddefine_002dexpander"> &para;</a></span></dt>
<dd><p>For more control over the expansion, the <code class="code">gv-define-expander</code>
macro can be used.  For instance, a settable <code class="code">substring</code> could be
implemented this way:
</p>
<div class="example">
<pre class="example-preformatted">(gv-define-expander substring
  (lambda (do place from &amp;optional to)
    (gv-letplace (getter setter) place
      (macroexp-let2* (from to)
        (funcall do `(substring ,getter ,from ,to)
                 (lambda (v)
                   (macroexp-let2* (v)
                     `(progn
                        ,(funcall setter `(cl--set-substring
                                           ,getter ,from ,to ,v))
                        ,v))))))))
</pre></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-gv_002dletplace"><span class="category-def">Macro: </span><span><strong class="def-name">gv-letplace</strong> <var class="def-var-arguments">(getter setter) place &amp;rest body</var><a class="copiable-link" href="#index-gv_002dletplace"> &para;</a></span></dt>
<dd><p>The macro <code class="code">gv-letplace</code> can be useful in defining macros that
perform similarly to <code class="code">setf</code>; for example, the <code class="code">incf</code> macro
of Common Lisp could be implemented this way:
</p>
<div class="example">
<pre class="example-preformatted">(defmacro incf (place &amp;optional n)
  (gv-letplace (getter setter) place
    (macroexp-let2* ((v (or n 1)))
      (funcall setter `(+ ,v ,getter)))))
</pre></div>

<p><var class="var">getter</var> will be bound to a copyable expression that returns the
value of <var class="var">place</var>.  <var class="var">setter</var> will be bound to a function that
takes an expression <var class="var">v</var> and returns a new expression that sets
<var class="var">place</var> to <var class="var">v</var>.  <var class="var">body</var> should return a Emacs Lisp
expression manipulating <var class="var">place</var> via <var class="var">getter</var> and <var class="var">setter</var>.
</p></dd></dl>

<p>Consult the source file <samp class="file">gv.el</samp> for more details.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-make_002dobsolete_002dgeneralized_002dvariable"><span class="category-def">Function: </span><span><strong class="def-name">make-obsolete-generalized-variable</strong> <var class="def-var-arguments">obsolete-name current-name when</var><a class="copiable-link" href="#index-make_002dobsolete_002dgeneralized_002dvariable"> &para;</a></span></dt>
<dd><p>This function makes the byte compiler warn that the generalized
variable <var class="var">obsolete-name</var> is obsolete.  If <var class="var">current-name</var> is a
symbol, then the warning message says to use <var class="var">current-name</var>
instead of <var class="var">obsolete-name</var>.  If <var class="var">current-name</var> is a string,
this is the message.  <var class="var">when</var> should be a string indicating when
the variable was first made obsolete (usually a version number
string).
</p></dd></dl>

<a class="index-entry-id" id="index-CL-note_002d_002d_002dno-setf-functions"></a>
<blockquote class="quotation">
<p><b class="b">Common Lisp note:</b> Common Lisp defines another way to specify the
<code class="code">setf</code> behavior of a function, namely <code class="code">setf</code> functions,
whose names are lists <code class="code">(setf <var class="var">name</var>)</code> rather than symbols.
For example, <code class="code">(defun (setf foo) &hellip;)</code> defines the function
that is used when <code class="code">setf</code> is applied to <code class="code">foo</code>.  Emacs does
not support this.  It is a compile-time error to use <code class="code">setf</code> on a
form that has not already had an appropriate expansion defined.  In
Common Lisp, this is not an error since the function <code class="code">(setf
<var class="var">func</var>)</code> might be defined later.
</p></blockquote>

</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Setting-Generalized-Variables.html">The <code class="code">setf</code> Macro</a>, Up: <a href="Generalized-Variables.html">Generalized Variables</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
