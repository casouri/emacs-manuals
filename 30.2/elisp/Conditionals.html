<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.2.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Conditionals (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Conditionals (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Conditionals (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Control-Structures.html" rel="up" title="Control Structures">
<link href="Combining-Conditions.html" rel="next" title="Combining Conditions">
<link href="Sequencing.html" rel="prev" title="Sequencing">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Conditionals">
<div class="nav-panel">
<p>
Next: <a href="Combining-Conditions.html" accesskey="n" rel="next">Constructs for Combining Conditions</a>, Previous: <a href="Sequencing.html" accesskey="p" rel="prev">Sequencing</a>, Up: <a href="Control-Structures.html" accesskey="u" rel="up">Control Structures</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Conditionals-1"><span>11.2 Conditionals<a class="copiable-link" href="#Conditionals-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-conditional-evaluation"></a>
<a class="index-entry-id" id="index-forms_002c-conditional"></a>

<p>Conditional control structures choose among alternatives.  Emacs Lisp
has five conditional forms: <code class="code">if</code>, which is much the same as in
other languages; <code class="code">when</code> and <code class="code">unless</code>, which are variants of
<code class="code">if</code>; <code class="code">cond</code>, which is a generalized case statement;
and <code class="code">pcase</code>, which is a generalization of <code class="code">cond</code>
(see <a class="pxref" href="Pattern_002dMatching-Conditional.html">Pattern-Matching Conditional</a>).
</p>
<dl class="first-deffn first-defspec-alias-first-deffn">
<dt class="deffn defspec-alias-deffn" id="index-if"><span class="category-def">Special Form: </span><span><strong class="def-name">if</strong> <var class="def-var-arguments">condition then-form else-forms&hellip;</var><a class="copiable-link" href="#index-if"> &para;</a></span></dt>
<dd><p><code class="code">if</code> chooses between the <var class="var">then-form</var> and the <var class="var">else-forms</var>
based on the value of <var class="var">condition</var>.  If the evaluated <var class="var">condition</var> is
non-<code class="code">nil</code>, <var class="var">then-form</var> is evaluated and the result returned.
Otherwise, the <var class="var">else-forms</var> are evaluated in textual order, and the
value of the last one is returned.  (The <var class="var">else</var> part of <code class="code">if</code> is
an example of an implicit <code class="code">progn</code>.  See <a class="xref" href="Sequencing.html">Sequencing</a>.)
</p>
<p>If <var class="var">condition</var> has the value <code class="code">nil</code>, and no <var class="var">else-forms</var> are
given, <code class="code">if</code> returns <code class="code">nil</code>.
</p>
<p><code class="code">if</code> is a special form because the branch that is not selected is
never evaluated&mdash;it is ignored.  Thus, in this example,
<code class="code">true</code> is not printed because <code class="code">print</code> is never called:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(if nil
    (print 'true)
  'very-false)
&rArr; very-false
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-when"><span class="category-def">Macro: </span><span><strong class="def-name">when</strong> <var class="def-var-arguments">condition then-forms&hellip;</var><a class="copiable-link" href="#index-when"> &para;</a></span></dt>
<dd><p>This is a variant of <code class="code">if</code> where there are no <var class="var">else-forms</var>,
and possibly several <var class="var">then-forms</var>.  In particular,
</p>
<div class="example">
<pre class="example-preformatted">(when <var class="var">condition</var> <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>)
</pre></div>

<p>is entirely equivalent to
</p>
<div class="example">
<pre class="example-preformatted">(if <var class="var">condition</var> (progn <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>) nil)
</pre></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-unless"><span class="category-def">Macro: </span><span><strong class="def-name">unless</strong> <var class="def-var-arguments">condition forms&hellip;</var><a class="copiable-link" href="#index-unless"> &para;</a></span></dt>
<dd><p>This is a variant of <code class="code">if</code> where there is no <var class="var">then-form</var>:
</p>
<div class="example">
<pre class="example-preformatted">(unless <var class="var">condition</var> <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>)
</pre></div>

<p>is entirely equivalent to
</p>
<div class="example">
<pre class="example-preformatted">(if <var class="var">condition</var> nil
   <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>)
</pre></div>
</dd></dl>

<dl class="first-deffn first-defspec-alias-first-deffn">
<dt class="deffn defspec-alias-deffn" id="index-cond"><span class="category-def">Special Form: </span><span><strong class="def-name">cond</strong> <var class="def-var-arguments">clause&hellip;</var><a class="copiable-link" href="#index-cond"> &para;</a></span></dt>
<dd><p><code class="code">cond</code> chooses among an arbitrary number of alternatives.  Each
<var class="var">clause</var> in the <code class="code">cond</code> must be a list.  The <small class="sc">CAR</small> of this
list is the <var class="var">condition</var>; the remaining elements, if any, the
<var class="var">body-forms</var>.  Thus, a clause looks like this:
</p>
<div class="example">
<pre class="example-preformatted">(<var class="var">condition</var> <var class="var">body-forms</var>...)
</pre></div>

<p><code class="code">cond</code> tries the clauses in textual order, by evaluating the
<var class="var">condition</var> of each clause.  If the value of <var class="var">condition</var> is
non-<code class="code">nil</code>, the clause succeeds; then <code class="code">cond</code> evaluates its
<var class="var">body-forms</var>, and returns the value of the last of <var class="var">body-forms</var>.
Any remaining clauses are ignored.
</p>
<p>If the value of <var class="var">condition</var> is <code class="code">nil</code>, the clause fails, so
the <code class="code">cond</code> moves on to the following clause, trying its <var class="var">condition</var>.
</p>
<p>A clause may also look like this:
</p>
<div class="example">
<pre class="example-preformatted">(<var class="var">condition</var>)
</pre></div>

<p>Then, if <var class="var">condition</var> is non-<code class="code">nil</code> when tested, the <code class="code">cond</code>
form returns the value of <var class="var">condition</var>.
</p>
<p>If every <var class="var">condition</var> evaluates to <code class="code">nil</code>, so that every clause
fails, <code class="code">cond</code> returns <code class="code">nil</code>.
</p>
<p>The following example has four clauses, which test for the cases where
the value of <code class="code">x</code> is a number, string, buffer and symbol,
respectively:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(cond ((numberp x) x)
      ((stringp x) x)
      ((bufferp x)
       (setq temporary-hack x) ; <span class="r">multiple body-forms</span>
       (buffer-name x))        ; <span class="r">in one clause</span>
      ((symbolp x) (symbol-value x)))
</pre></div></div>

<p>Often we want to execute the last clause whenever none of the previous
clauses was successful.  To do this, we use <code class="code">t</code> as the
<var class="var">condition</var> of the last clause, like this: <code class="code">(t
<var class="var">body-forms</var>)</code>.  The form <code class="code">t</code> evaluates to <code class="code">t</code>, which is
never <code class="code">nil</code>, so this clause never fails, provided the <code class="code">cond</code>
gets to it at all.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq a 5)
(cond ((eq a 'hack) 'foo)
      (t &quot;default&quot;))
&rArr; &quot;default&quot;
</pre></div></div>

<p>This <code class="code">cond</code> expression returns <code class="code">foo</code> if the value of <code class="code">a</code>
is <code class="code">hack</code>, and returns the string <code class="code">&quot;default&quot;</code> otherwise.
</p></dd></dl>

<p>Any conditional construct can be expressed with <code class="code">cond</code> or with
<code class="code">if</code>.  Therefore, the choice between them is a matter of style.
For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(if <var class="var">a</var> <var class="var">b</var> <var class="var">c</var>)
&equiv;
(cond (<var class="var">a</var> <var class="var">b</var>) (t <var class="var">c</var>))
</pre></div></div>

<p>It can be convenient to bind variables in conjunction with using a
conditional.  It&rsquo;s often the case that you compute a value, and then
want to do something with that value if it&rsquo;s non-<code class="code">nil</code>.  The
straightforward way to do that is to just write, for instance:
</p>
<div class="example">
<pre class="example-preformatted">(let ((result1 (do-computation)))
  (when result1
    (let ((result2 (do-more result1)))
      (when result2
        (do-something result2)))))
</pre></div>

<p>Since this is a very common pattern, Emacs provides a number of macros
to make this easier and more readable.  The above can be written the
following way instead:
</p>
<div class="example">
<pre class="example-preformatted">(when-let* ((result1 (do-computation))
            (result2 (do-more result1)))
  (do-something result2))
</pre></div>

<p>There&rsquo;s a number of variations on this theme, and they&rsquo;re briefly
described below.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-if_002dlet_002a"><span class="category-def">Macro: </span><span><strong class="def-name">if-let*</strong> <var class="def-var-arguments">varlist then-form else-forms...</var><a class="copiable-link" href="#index-if_002dlet_002a"> &para;</a></span></dt>
<dd><p>Evaluate each binding in <var class="var">varlist</var>, stopping if a binding value is
<code class="code">nil</code>.  If all are non-<code class="code">nil</code>, return the value of
<var class="var">then-form</var>, otherwise the last form in <var class="var">else-forms</var>.
</p>
<p>Each element of <code class="code">varlist</code> has the form <code class="code">(<var class="var">symbol</var>&nbsp;<var class="var">value-form</var>)</code><!-- /@w -->: <var class="var">value-form</var> is evaluated and <var class="var">symbol</var> is
locally bound to the result.  Bindings are sequential, as in <code class="code">let*</code>
(see <a class="pxref" href="Local-Variables.html">Local Variables</a>).  As a special case, <var class="var">symbol</var> can be
omitted if only the test result of <var class="var">value-form</var> is of interest:
<var class="var">value-form</var> is evaluated and checked for <code class="code">nil</code>, but its value
is not bound.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-when_002dlet_002a"><span class="category-def">Macro: </span><span><strong class="def-name">when-let*</strong> <var class="def-var-arguments">varlist then-forms...</var><a class="copiable-link" href="#index-when_002dlet_002a"> &para;</a></span></dt>
<dd><p>Evaluate each binding in <var class="var">varlist</var>, stopping if a binding value is
<code class="code">nil</code>.  If all are non-<code class="code">nil</code>, return the value of the last
form in <var class="var">then-forms</var>.
</p>
<p><var class="var">varlist</var> has the same form as in <code class="code">if-let*</code>: Each element of
<code class="code">varlist</code> has the form <code class="code">(<var class="var">symbol</var>&nbsp;<var class="var">value-form</var>)</code><!-- /@w -->,
in which <var class="var">value-form</var> is evaluated and <var class="var">symbol</var> is locally bound
to the result.  Bindings are sequential, as in <code class="code">let*</code> (see <a class="pxref" href="Local-Variables.html">Local Variables</a>).  As a special case, <var class="var">symbol</var> can be omitted if only the
test result of <var class="var">value-form</var> is of interest: <var class="var">value-form</var> is
evaluated and checked for <code class="code">nil</code>, but its value is not bound.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-and_002dlet_002a"><span class="category-def">Macro: </span><span><strong class="def-name">and-let*</strong> <var class="def-var-arguments">varlist then-forms...</var><a class="copiable-link" href="#index-and_002dlet_002a"> &para;</a></span></dt>
<dd><p>Evaluate each binding in <var class="var">varlist</var>, stopping if a binding value is
<code class="code">nil</code>.  If all are non-<code class="code">nil</code>, return the value of the last
form in <var class="var">then-forms</var>, or, if there are no <var class="var">then-forms</var>, return
the value of the last binding.
</p>
<p><var class="var">varlist</var> has the same form as in <code class="code">if-let*</code>: Each element of
<code class="code">varlist</code> has the form <code class="code">(<var class="var">symbol</var>&nbsp;<var class="var">value-form</var>)</code><!-- /@w -->,
in which <var class="var">value-form</var> is evaluated and <var class="var">symbol</var> is locally bound
to the result.  Bindings are sequential, as in <code class="code">let*</code> (see <a class="pxref" href="Local-Variables.html">Local Variables</a>).  As a special case, <var class="var">symbol</var> can be omitted if only the
test result of <var class="var">value-form</var> is of interest: <var class="var">value-form</var> is
evaluated and checked for <code class="code">nil</code>, but its value is not bound.
</p></dd></dl>

<p>Some Lisp programmers follow the convention that <code class="code">and</code> and
<code class="code">and-let*</code> are for forms evaluated for return value, and
<code class="code">when</code> and <code class="code">when-let*</code> are for forms evaluated for side-effect
with returned values ignored.
</p>
<p>A similar macro exists to run a loop until one binding evaluates to
<code class="code">nil</code>:
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-while_002dlet"><span class="category-def">Macro: </span><span><strong class="def-name">while-let</strong> <var class="def-var-arguments">spec then-forms...</var><a class="copiable-link" href="#index-while_002dlet"> &para;</a></span></dt>
<dd><p>Evaluate each binding in <var class="var">spec</var> in turn, stopping if a binding value
is <code class="code">nil</code>.  If all are non-<code class="code">nil</code>, execute <var class="var">then-forms</var>,
then repeat the loop.  Note that when the loop is repeated, the
<var class="var">value-forms</var> in <var class="var">spec</var> are re-evaluated and the bindings are
established anew.
</p>
<p><var class="var">varlist</var> has the same form as in <code class="code">if-let*</code>: Each element of
<code class="code">varlist</code> has the form <code class="code">(<var class="var">symbol</var>&nbsp;<var class="var">value-form</var>)</code><!-- /@w -->,
in which <var class="var">value-form</var> is evaluated and <var class="var">symbol</var> is locally bound
to the result.  Bindings are sequential, as in <code class="code">let*</code> (see <a class="pxref" href="Local-Variables.html">Local Variables</a>).  As a special case, <var class="var">symbol</var> can be omitted if only the
test result of <var class="var">value-form</var> is of interest: <var class="var">value-form</var> is
evaluated and checked for <code class="code">nil</code>, but its value is not bound.
</p>
<p>The return value of <code class="code">while-let</code> is always <code class="code">nil</code>.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Combining-Conditions.html">Constructs for Combining Conditions</a>, Previous: <a href="Sequencing.html">Sequencing</a>, Up: <a href="Control-Structures.html">Control Structures</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
