<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.2.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Handling Errors (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Handling Errors (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Handling Errors (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Errors.html" rel="up" title="Errors">
<link href="Error-Symbols.html" rel="next" title="Error Symbols">
<link href="Processing-of-Errors.html" rel="prev" title="Processing of Errors">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsubsection-level-extent" id="Handling-Errors">
<div class="nav-panel">
<p>
Next: <a href="Error-Symbols.html" accesskey="n" rel="next">Error Symbols and Condition Names</a>, Previous: <a href="Processing-of-Errors.html" accesskey="p" rel="prev">How Emacs Processes Errors</a>, Up: <a href="Errors.html" accesskey="u" rel="up">Errors</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsubsection" id="Writing-Code-to-Handle-Errors"><span>11.7.3.3 Writing Code to Handle Errors<a class="copiable-link" href="#Writing-Code-to-Handle-Errors"> &para;</a></span></h4>
<a class="index-entry-id" id="index-error-handler"></a>
<a class="index-entry-id" id="index-handling-errors"></a>
<a class="index-entry-id" id="index-handle-Lisp-errors"></a>
<a class="index-entry-id" id="index-forms-for-handling-errors"></a>

<p>The usual effect of signaling an error is to terminate the command
that is running and return immediately to the Emacs editor command loop.
You can arrange to trap errors occurring in a part of your program by
establishing an error handler, with the special form
<code class="code">condition-case</code>.  A simple example looks like this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(condition-case nil
    (delete-file filename)
  (error nil))
</pre></div></div>

<p>This deletes the file named <var class="var">filename</var>, catching any error and
returning <code class="code">nil</code> if an error occurs.  (You can use the macro
<code class="code">ignore-errors</code> for a simple case like this; see below.)
</p>
<p>The <code class="code">condition-case</code> construct is often used to trap errors that
are predictable, such as failure to open a file in a call to
<code class="code">insert-file-contents</code>.  It is also used to trap errors that are
totally unpredictable, such as when the program evaluates an expression
read from the user.
</p>
<p>The second argument of <code class="code">condition-case</code> is called the
<em class="dfn">protected form</em>.  (In the example above, the protected form is a
call to <code class="code">delete-file</code>.)  The error handlers go into effect when
this form begins execution and are deactivated when this form returns.
They remain in effect for all the intervening time.  In particular, they
are in effect during the execution of functions called by this form, in
their subroutines, and so on.  This is a good thing, since, strictly
speaking, errors can be signaled only by Lisp primitives (including
<code class="code">signal</code> and <code class="code">error</code>) called by the protected form, not by the
protected form itself.
</p>
<p>The arguments after the protected form are handlers.  Each handler
lists one or more <em class="dfn">condition names</em> (which are symbols) to specify
which errors it will handle.  The error symbol specified when an error
is signaled also defines a list of condition names.  A handler applies
to an error if they have any condition names in common.  In the example
above, there is one handler, and it specifies one condition name,
<code class="code">error</code>, which covers all errors.
</p>
<p>The search for an applicable handler checks all the established handlers
starting with the most recently established one.  Thus, if two nested
<code class="code">condition-case</code> forms offer to handle the same error, the inner of
the two gets to handle it.
</p>
<p>If an error is handled by some <code class="code">condition-case</code> form, this
ordinarily prevents the debugger from being run, even if
<code class="code">debug-on-error</code> says this error should invoke the debugger.
</p>
<p>If you want to be able to debug errors that are caught by a
<code class="code">condition-case</code>, set the variable <code class="code">debug-on-signal</code> to a
non-<code class="code">nil</code> value.  You can also specify that a particular handler
should let the debugger run first, by writing <code class="code">debug</code> among the
conditions, like this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(condition-case nil
    (delete-file filename)
  ((debug error) nil))
</pre></div></div>

<p>The effect of <code class="code">debug</code> here is only to prevent
<code class="code">condition-case</code> from suppressing the call to the debugger.  Any
given error will invoke the debugger only if <code class="code">debug-on-error</code> and
the other usual filtering mechanisms say it should.  See <a class="xref" href="Error-Debugging.html">Entering the Debugger on an Error</a>.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-condition_002dcase_002dunless_002ddebug"><span class="category-def">Macro: </span><span><strong class="def-name">condition-case-unless-debug</strong> <var class="def-var-arguments">var protected-form handlers&hellip;</var><a class="copiable-link" href="#index-condition_002dcase_002dunless_002ddebug"> &para;</a></span></dt>
<dd><p>The macro <code class="code">condition-case-unless-debug</code> provides another way to
handle debugging of such forms.  It behaves exactly like
<code class="code">condition-case</code>, unless the variable <code class="code">debug-on-error</code> is
non-<code class="code">nil</code>, in which case it does not handle any errors at all.
</p></dd></dl>

<p>Once Emacs decides that a certain handler handles the error, it
returns control to that handler.  To do so, Emacs unbinds all variable
bindings made by binding constructs that are being exited, and
executes the cleanups of all <code class="code">unwind-protect</code> forms that are
being exited.  Once control arrives at the handler, the body of the
handler executes normally.
</p>
<p>After execution of the handler body, execution returns from the
<code class="code">condition-case</code> form.  Because the protected form is exited
completely before execution of the handler, the handler cannot resume
execution at the point of the error, nor can it examine variable
bindings that were made within the protected form.  All it can do is
clean up and proceed.
</p>
<p>Error signaling and handling have some resemblance to <code class="code">throw</code> and
<code class="code">catch</code> (see <a class="pxref" href="Catch-and-Throw.html">Explicit Nonlocal Exits: <code class="code">catch</code> and <code class="code">throw</code></a>), but they are entirely separate
facilities.  An error cannot be caught by a <code class="code">catch</code>, and a
<code class="code">throw</code> cannot be handled by an error handler (though using
<code class="code">throw</code> when there is no suitable <code class="code">catch</code> signals an error
that can be handled).
</p>
<dl class="first-deffn first-defspec-alias-first-deffn">
<dt class="deffn defspec-alias-deffn" id="index-condition_002dcase"><span class="category-def">Special Form: </span><span><strong class="def-name">condition-case</strong> <var class="def-var-arguments">var protected-form handlers&hellip;</var><a class="copiable-link" href="#index-condition_002dcase"> &para;</a></span></dt>
<dd><p>This special form establishes the error handlers <var class="var">handlers</var> around
the execution of <var class="var">protected-form</var>.  If <var class="var">protected-form</var> executes
without error, the value it returns becomes the value of the
<code class="code">condition-case</code> form (in the absence of a success handler; see below).
In this case, the <code class="code">condition-case</code> has
no effect.  The <code class="code">condition-case</code> form makes a difference when an
error occurs during <var class="var">protected-form</var>.
</p>
<p>Each of the <var class="var">handlers</var> is a list of the form <code class="code">(<var class="var">conditions</var>
<var class="var">body</var>&hellip;)</code>.  Here <var class="var">conditions</var> is an error condition name
to be handled, or a list of condition names (which can include <code class="code">debug</code>
to allow the debugger to run before the handler).  A condition name of
<code class="code">t</code> matches any condition.  <var class="var">body</var> is one or more Lisp
expressions to be executed when this handler handles an error.  Here
are examples of handlers:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(error nil)

(arith-error (message &quot;Division by zero&quot;))

((arith-error file-error)
 (message
  &quot;Either division by zero or failure to open a file&quot;))
</pre></div></div>

<p>Each error that occurs has an <em class="dfn">error symbol</em> that describes what
kind of error it is, and which describes also a list of condition names
(see <a class="pxref" href="Error-Symbols.html">Error Symbols and Condition Names</a>).  Emacs
searches all the active <code class="code">condition-case</code> forms for a handler that
specifies one or more of these condition names; the innermost matching
<code class="code">condition-case</code> handles the error.  Within this
<code class="code">condition-case</code>, the first applicable handler handles the error.
</p>
<p>After executing the body of the handler, the <code class="code">condition-case</code>
returns normally, using the value of the last form in the handler body
as the overall value.
</p>
<a class="index-entry-id" id="index-error-description"></a>
<p>The argument <var class="var">var</var> is a variable.  <code class="code">condition-case</code> does not
bind this variable when executing the <var class="var">protected-form</var>, only when it
handles an error.  At that time, it binds <var class="var">var</var> locally to an
<em class="dfn">error description</em>, which is a list giving the particulars of the
error.  The error description has the form <code class="code">(<var class="var">error-symbol</var>
. <var class="var">data</var>)</code>.  The handler can refer to this list to decide what to
do.  For example, if the error is for failure opening a file, the file
name is the second element of <var class="var">data</var>&mdash;the third element of the
error description.
</p>
<p>If <var class="var">var</var> is <code class="code">nil</code>, that means no variable is bound.  Then the
error symbol and associated data are not available to the handler.
</p>
<a class="index-entry-id" id="index-success-handler"></a>
<p>As a special case, one of the <var class="var">handlers</var> can be a list of the
form <code class="code">(:success <var class="var">body</var>&hellip;)</code>, where <var class="var">body</var> is executed
with <var class="var">var</var> (if non-<code class="code">nil</code>) bound to the return value of
<var class="var">protected-form</var> when that expression terminates without error.
</p>
<a class="index-entry-id" id="index-rethrow-a-signal"></a>
<p>Sometimes it is necessary to re-throw a signal caught by
<code class="code">condition-case</code>, for some outer-level handler to catch.  Here&rsquo;s
how to do that:
</p>
<div class="example">
<pre class="example-preformatted">  (signal (car err) (cdr err))
</pre></div>

<p>where <code class="code">err</code> is the error description variable, the first argument
to <code class="code">condition-case</code> whose error condition you want to re-throw.
See <a class="xref" href="Signaling-Errors.html#Definition-of-signal">Definition of signal</a>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-error_002dmessage_002dstring"><span class="category-def">Function: </span><span><strong class="def-name">error-message-string</strong> <var class="def-var-arguments">error-descriptor</var><a class="copiable-link" href="#index-error_002dmessage_002dstring"> &para;</a></span></dt>
<dd><p>This function returns the error message string for a given error
descriptor.  It is useful if you want to handle an error by printing the
usual error message for that error.  See <a class="xref" href="Signaling-Errors.html#Definition-of-signal">Definition of signal</a>.
</p></dd></dl>

<a class="index-entry-id" id="index-arith_002derror-example"></a>
<p>Here is an example of using <code class="code">condition-case</code> to handle the error
that results from dividing by zero.  The handler displays the error
message (but without a beep), then returns a very large number.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(defun safe-divide (dividend divisor)
  (condition-case err
      ;; <span class="r">Protected form.</span>
      (/ dividend divisor)
</pre></div><div class="group"><pre class="example-preformatted">    ;; <span class="r">The handler.</span>
    (arith-error                        ; <span class="r">Condition.</span>
     ;; <span class="r">Display the usual message for this error.</span>
     (message &quot;%s&quot; (error-message-string err))
     1000000)))
&rArr; safe-divide
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(safe-divide 5 0)
     -| Arithmetic error: (arith-error)
&rArr; 1000000
</pre></div></div>

<p>The handler specifies condition name <code class="code">arith-error</code> so that it
will handle only division-by-zero errors.  Other kinds of errors will
not be handled (by this <code class="code">condition-case</code>).  Thus:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(safe-divide nil 3)
     error&rarr; Wrong type argument: number-or-marker-p, nil
</pre></div></div>

<p>Here is a <code class="code">condition-case</code> that catches all kinds of errors,
including those from <code class="code">error</code>:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq baz 34)
     &rArr; 34
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(condition-case err
    (if (eq baz 35)
        t
      ;; <span class="r">This is a call to the function <code class="code">error</code>.</span>
      (error &quot;Rats!  The variable %s was %s, not 35&quot; 'baz baz))
  ;; <span class="r">This is the handler; it is not a form.</span>
  (error (princ (format &quot;The error was: %s&quot; err))
         2))
-| The error was: (error &quot;Rats!  The variable baz was 34, not 35&quot;)
&rArr; 2
</pre></div></div>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-ignore_002derrors"><span class="category-def">Macro: </span><span><strong class="def-name">ignore-errors</strong> <var class="def-var-arguments">body&hellip;</var><a class="copiable-link" href="#index-ignore_002derrors"> &para;</a></span></dt>
<dd><p>This construct executes <var class="var">body</var>, ignoring any errors that occur
during its execution.  If the execution is without error,
<code class="code">ignore-errors</code> returns the value of the last form in <var class="var">body</var>;
otherwise, it returns <code class="code">nil</code>.
</p>
<p>Here&rsquo;s the example at the beginning of this subsection rewritten using
<code class="code">ignore-errors</code>:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">  (ignore-errors
   (delete-file filename))
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-ignore_002derror"><span class="category-def">Macro: </span><span><strong class="def-name">ignore-error</strong> <var class="def-var-arguments">condition body&hellip;</var><a class="copiable-link" href="#index-ignore_002derror"> &para;</a></span></dt>
<dd><p>This macro is like <code class="code">ignore-errors</code>, but will only ignore the
specific error condition specified.
</p>
<div class="example">
<pre class="example-preformatted">  (ignore-error end-of-file
    (read &quot;&quot;))
</pre></div>

<p><var class="var">condition</var> can also be a list of error conditions.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-with_002ddemoted_002derrors"><span class="category-def">Macro: </span><span><strong class="def-name">with-demoted-errors</strong> <var class="def-var-arguments">format body&hellip;</var><a class="copiable-link" href="#index-with_002ddemoted_002derrors"> &para;</a></span></dt>
<dd><p>This macro is like a milder version of <code class="code">ignore-errors</code>.  Rather
than suppressing errors altogether, it converts them into messages.
It uses the string <var class="var">format</var> to format the message.
<var class="var">format</var> should contain a single &lsquo;<samp class="samp">%</samp>&rsquo;-sequence; e.g.,
<code class="code">&quot;Error: %S&quot;</code>.  Use <code class="code">with-demoted-errors</code> around code
that is not expected to signal errors, but
should be robust if one does occur.  Note that this macro uses
<code class="code">condition-case-unless-debug</code> rather than <code class="code">condition-case</code>.
</p></dd></dl>

<p>Occasionally, we want to catch some errors and record some information
about the conditions in which they occurred, such as the full
backtrace, or the current buffer.  This kinds of information is sadly
not available in the handlers of a <code class="code">condition-case</code> because the
stack is unwound before running that handler, so the handler is run in
the dynamic context of the <code class="code">condition-case</code> rather than that of
the place where the error was signaled.  For those circumstances, you
can use the following form:
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-handler_002dbind"><span class="category-def">Macro: </span><span><strong class="def-name">handler-bind</strong> <var class="def-var-arguments">handlers body&hellip;</var><a class="copiable-link" href="#index-handler_002dbind"> &para;</a></span></dt>
<dd><p>This special form runs <var class="var">body</var> and if it executes without error,
the value it returns becomes the value of the <code class="code">handler-bind</code>
form.  In this case, the <code class="code">handler-bind</code> has no effect.
</p>
<p><var class="var">handlers</var> should be a list of elements of the form
<code class="code">(<var class="var">conditions</var> <var class="var">handler</var>)</code> where <var class="var">conditions</var> is an
error condition name to be handled, or a list of condition names, and
<var class="var">handler</var> should be a form whose evaluation should return a function.
As with <code class="code">condition-case</code>, condition names are symbols.
</p>
<p>Before running <var class="var">body</var>, <code class="code">handler-bind</code> evaluates all the
<var class="var">handler</var> forms and installs those handlers to be active during
the evaluation of <var class="var">body</var>.  When an error is signaled,
Emacs searches all the active <code class="code">condition-case</code> and
<code class="code">handler-bind</code> forms for a handler that
specifies one or more of these condition names.  When the innermost
matching handler is one installed by <code class="code">handler-bind</code>, the
<var class="var">handler</var> function is called with a single argument holding the
error description.
</p>
<p>Contrary to what happens with <code class="code">condition-case</code>, <var class="var">handler</var> is
called in the dynamic context where the error happened.  This means it
is executed without unbinding any variable bindings or running any
cleanups of <code class="code">unwind-protect</code>, so that all those dynamic bindings
are still in effect.  There is one exception: while running the
<var class="var">handler</var> function, all the error handlers between the code that
signaled the error and the <code class="code">handler-bind</code> are temporarily
suspended, meaning that when an error is signaled, Emacs will only
search the active <code class="code">condition-case</code> and <code class="code">handler-bind</code> forms
that are inside the <var class="var">handler</var> function or outside of the current
<code class="code">handler-bind</code>.  Note also that lexically-bound variables
(see <a class="pxref" href="Lexical-Binding.html">Lexical Binding</a>) are not affected, since they do not have
dynamic extent.
</p>
<p>Like any normal function, <var class="var">handler</var> can exit non-locally,
typically via <code class="code">throw</code>, or it can return normally.
If <var class="var">handler</var> returns normally, it means the handler
<em class="emph">declined</em> to handle the error and the search for an error
handler is continued where it left off.
</p>
<p>For example, if we wanted to keep a log of all the errors that occur
during the execution of a particular piece of code together with the
buffer that&rsquo;s current when the error is signaled, but without
otherwise affecting the behavior of that code, we can do it with:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(handler-bind
    ((error
      (lambda (err)
        (push (cons err (current-buffer)) my-log-of-errors))))
  <var class="var">body-forms</var>...)
</pre></div></div>

<p>This will log only those errors that are not caught internally to
<var class="var">body-forms</var>&hellip;, in other words errors that &ldquo;escape&rdquo; from
<var class="var">body-forms</var>&hellip;, and it will not prevent those errors from
being passed on to surrounding <code class="code">condition-case</code> handlers (or
<code class="code">handler-bind</code> handlers for that matter) since the above handler
returns normally.
</p>
<p>We can also use <code class="code">handler-bind</code> to replace an error with another,
as in the code below which turns all errors of type <code class="code">user-error</code>
that occur during the execution of <var class="var">body-forms</var>&hellip; into plain
<code class="code">error</code>:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(handler-bind
    ((user-error
      (lambda (err)
        (signal 'error (cdr err)))))
  <var class="var">body-forms</var>...)
</pre></div></div>

<p>We can get almost the same result with <code class="code">condition-case</code>:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(condition-case err
    (progn <var class="var">body-forms</var>...)
  (user-error (signal 'error (cdr err))))
</pre></div></div>

<p>but with the difference that when we (re)signal the new error in
<code class="code">handler-bind</code>, the dynamic environment from the original error
is still active, which means for example that if we enter the debugger
at this point, it will show us a complete backtrace including the
point where we signaled the original error:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">Debugger entered--Lisp error: (error &quot;Oops&quot;)
  signal(error (&quot;Oops&quot;))
  #f(lambda (err) [t] (signal 'error (cdr err)))((user-error &quot;Oops&quot;))
  user-error(&quot;Oops&quot;)
  ...
  eval((handler-bind ((user-error (lambda (err) ...
</pre></div></div>

</dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Error-Symbols.html">Error Symbols and Condition Names</a>, Previous: <a href="Processing-of-Errors.html">How Emacs Processes Errors</a>, Up: <a href="Errors.html">Errors</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
