<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 26.2.

Copyright Â© 1990-1996, 1998-2019 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Module Functions (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Module Functions (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Module Functions (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Writing-Dynamic-Modules.html" rel="up" title="Writing Dynamic Modules">
<link href="Module-Values.html" rel="next" title="Module Values">
<link href="Module-Initialization.html" rel="prev" title="Module Initialization">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Module-Functions">
<div class="nav-panel">
<p>
Next: <a href="Module-Values.html" accesskey="n" rel="next">Conversion Between Lisp and Module Values</a>, Previous: <a href="Module-Initialization.html" accesskey="p" rel="prev">Module Initialization Code</a>, Up: <a href="Writing-Dynamic-Modules.html" accesskey="u" rel="up">Writing Dynamically-Loaded Modules</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Writing-Module-Functions"><span>E.8.2 Writing Module Functions<a class="copiable-link" href="#Writing-Module-Functions"> &para;</a></span></h4>
<a class="index-entry-id" id="index-writing-module-functions"></a>
<a class="index-entry-id" id="index-module-functions"></a>

<p>The main reason for writing an Emacs module is to make additional
functions available to Lisp programs that load the module.  This
subsection describes how to write such <em class="dfn">module functions</em>.
</p>
<p>A module function has the following general form and signature:
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-module_005ffunc"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">module_func</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, ptrdiff_t <var class="var">nargs</var>, emacs_value *<var class="var">args</var>, void *<var class="var">data</var>)</code><a class="copiable-link" href="#index-module_005ffunc"> &para;</a></span></dt>
<dd><p>The <var class="var">env</var> argument provides a pointer to the <abbr class="acronym">API</abbr>
environment, needed to access Emacs objects and functions.  The
<var class="var">nargs</var> argument is the required number of arguments, which can be
zero (see <code class="code">make_function</code> below for more flexible specification
of the argument number), and <var class="var">args</var> is a pointer to the array of
the function arguments.  The argument <var class="var">data</var> points to additional
data required by the function, which was arranged when
<code class="code">make_function</code> (see below) was called to create an Emacs
function from <code class="code">module_func</code>.
</p>
<p>Module functions use the type <code class="code">emacs_value</code> to communicate Lisp
objects between Emacs and the module (see <a class="pxref" href="Module-Values.html">Conversion Between Lisp and Module Values</a>).  The
<abbr class="acronym">API</abbr>, described below and in the following subsections,
provides facilities for conversion between basic C data types and the
corresponding <code class="code">emacs_value</code> objects.
</p>
<p>A module function always returns a value.  If the function returns
normally, the Lisp code which called it will see the Lisp object
corresponding to the <code class="code">emacs_value</code> value the function returned.
However, if the user typed <kbd class="kbd">C-g</kbd>, or if the module function or its
callees signaled an error or exited nonlocally (see <a class="pxref" href="Module-Nonlocal.html">Nonlocal Exits in Modules</a>), Emacs will ignore the returned value and quit or throw as
it does when Lisp code encounters the same situations.
</p></dd></dl>

<p>After writing your C code for a module function, you should make a
Lisp function object from it using the <code class="code">make_function</code> function,
whose pointer is provided in the environment (recall that the pointer
to the environment is returned by <code class="code">get_environment</code>).  This is
normally done in the module initialization function (see <a class="pxref" href="Module-Initialization.html#module-initialization-function">module initialization function</a>), after verifying the <abbr class="acronym">API</abbr>
compatibility.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005ffunction"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_function</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, ptrdiff_t <var class="var">min_arity</var>, ptrdiff_t <var class="var">max_arity</var>, subr <var class="var">func</var>, const char *<var class="var">docstring</var>, void *<var class="var">data</var>)</code><a class="copiable-link" href="#index-make_005ffunction"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-emacs_005fvariadic_005ffunction"></a>
<p>This returns an Emacs function created from the C function <var class="var">func</var>,
whose signature is as described for <code class="code">module_func</code> above (assumed
here to be <code class="code">typedef</code>&rsquo;ed as <code class="code">subr</code>).  The arguments
<var class="var">min_arity</var> and <var class="var">max_arity</var> specify the minimum and maximum
number of arguments that <var class="var">func</var> can accept.  The <var class="var">max_arity</var>
argument can have the special value <code class="code">emacs_variadic_function</code>,
which makes the function accept an unlimited number of arguments, like
the <code class="code">&amp;rest</code> keyword in Lisp (see <a class="pxref" href="Argument-List.html">Other Features of Argument Lists</a>).
</p>
<p>The argument <var class="var">data</var> is a way to arrange for arbitrary additional
data to be passed to <var class="var">func</var> when it is called.  Whatever pointer
is passed to <code class="code">make_function</code> will be passed unaltered to
<var class="var">func</var>.
</p>
<p>The argument <var class="var">docstring</var> specifies the documentation string for
the function.  It should be either an <abbr class="acronym">ASCII</abbr> string, or a
UTF-8 encoded non-<abbr class="acronym">ASCII</abbr> string, or a <code class="code">NULL</code> pointer; in
the latter case the function will have no documentation.  The
documentation string can end with a line that specifies the advertised
calling convention, see <a class="ref" href="Function-Documentation.html">Documentation Strings of Functions</a>.
</p>
<p>Since every module function must accept the pointer to the environment
as its first argument, the call to <code class="code">make_function</code> could be made
from any module function, but you will normally want to do that from
the module initialization function, so that all the module functions
are known to Emacs once the module is loaded.
</p></dd></dl>

<p>Finally, you should bind the Lisp function to a symbol, so that Lisp
code could call your function by name.  For that, use the module
<abbr class="acronym">API</abbr> function <code class="code">intern</code> (see <a class="pxref" href="Module-Misc.html#intern">intern</a>) whose pointer is
also provided in the environment that module functions can access.
</p>
<p>Combining the above steps, code that arranges for a C function
<code class="code">module_func</code> to be callable as <code class="code">module-func</code> from Lisp will
look like this, as part of the module initialization function:
</p>
<div class="example">
<pre class="example-preformatted"> emacs_env *env = ert-&gt;get_environment (ert);
 emacs_value func = env-&gt;make_function (env, min_arity, max_arity,
                                        module_func, docstring, data);
 emacs_value symbol = env-&gt;intern (env, &quot;module-func&quot;);
 emacs_value args[] = {symbol, func};
 env-&gt;funcall (env, env-&gt;intern (env, &quot;defalias&quot;), 2, args);
</pre></div>

<p>This makes the symbol <code class="code">module-func</code> known to Emacs by calling
<code class="code">env-&gt;intern</code>, then invokes <code class="code">defalias</code> from Emacs to bind
the function to that symbol.  Note that it is possible to use
<code class="code">fset</code> instead of <code class="code">defalias</code>; the differences are described
in <a class="ref" href="Defining-Functions.html">defalias</a>.
</p>
<p>Using the module <abbr class="acronym">API</abbr>, it is possible to define more complex
function and data types: interactive functions, inline functions,
macros, etc.  However, the resulting C code will be cumbersome and
hard to read.  Therefore, we recommend that you limit the module code
which creates functions and data structures to the absolute minimum,
and leave the rest for a Lisp package that will accompany your module,
because doing these additional tasks in Lisp is much easier, and will
produce a much more readable code.  For example, given a module
function <code class="code">module-func</code> defined as above, one way of making an
interactive command <code class="code">module-cmd</code> based on it is with the
following simple Lisp wrapper:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(defun module-cmd (&amp;rest args)
  &quot;Documentation string for the command.&quot;
  (interactive <var class="var">spec</var>)
  (apply 'module-func args))
</pre></div>

<p>The Lisp package which goes with your module could then load the
module using the <code class="code">module-load</code> primitive (see <a class="pxref" href="Dynamic-Modules.html">Emacs Dynamic Modules</a>) when the package is loaded into Emacs.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Module-Values.html">Conversion Between Lisp and Module Values</a>, Previous: <a href="Module-Initialization.html">Module Initialization Code</a>, Up: <a href="Writing-Dynamic-Modules.html">Writing Dynamically-Loaded Modules</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
