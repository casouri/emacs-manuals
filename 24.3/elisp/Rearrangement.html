<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 24.3.

Copyright © 1990-1996, 1998-2013 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Rearrangement (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Rearrangement (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Rearrangement (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Modifying-Lists.html" rel="up" title="Modifying Lists">
<link href="Setcdr.html" rel="prev" title="Setcdr">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="subsection-level-extent" id="Rearrangement">
<div class="nav-panel">
<p>
Previous: <a href="Setcdr.html" accesskey="p" rel="prev">Altering the CDR of a List</a>, Up: <a href="Modifying-Lists.html" accesskey="u" rel="up">Modifying Existing List Structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Functions-that-Rearrange-Lists"><span>5.6.3 Functions that Rearrange Lists<a class="copiable-link" href="#Functions-that-Rearrange-Lists"> &para;</a></span></h4>
<a class="index-entry-id" id="index-rearrangement-of-lists"></a>
<a class="index-entry-id" id="index-modification-of-lists"></a>

<p>Here are some functions that rearrange lists &ldquo;destructively&rdquo; by
modifying the <small class="sc">CDR</small>s of their component cons cells.  We call these
functions &ldquo;destructive&rdquo; because they chew up the original lists passed
to them as arguments, relinking their cons cells to form a new list that
is the returned value.
</p>
<p>See <code class="code">delq</code>, in <a class="ref" href="Sets-And-Lists.html">Using Lists as Sets</a>, for another function
that modifies cons cells.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-nconc"><span class="category-def">Function: </span><span><strong class="def-name">nconc</strong> <var class="def-var-arguments">&amp;rest lists</var><a class="copiable-link" href="#index-nconc"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-concatenating-lists"></a>
<a class="index-entry-id" id="index-joining-lists"></a>
<p>This function returns a list containing all the elements of <var class="var">lists</var>.
Unlike <code class="code">append</code> (see <a class="pxref" href="Building-Lists.html">Building Cons Cells and Lists</a>), the <var class="var">lists</var> are
<em class="emph">not</em> copied.  Instead, the last <small class="sc">CDR</small> of each of the
<var class="var">lists</var> is changed to refer to the following list.  The last of the
<var class="var">lists</var> is not altered.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq x '(1 2 3))
     &rArr; (1 2 3)
</pre></div><div class="group"><pre class="example-preformatted">(nconc x '(4 5))
     &rArr; (1 2 3 4 5)
</pre></div><div class="group"><pre class="example-preformatted">x
     &rArr; (1 2 3 4 5)
</pre></div></div>

<p>Since the last argument of <code class="code">nconc</code> is not itself modified, it is
reasonable to use a constant list, such as <code class="code">'(4 5)</code>, as in the
above example.  For the same reason, the last argument need not be a
list:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq x '(1 2 3))
     &rArr; (1 2 3)
</pre></div><div class="group"><pre class="example-preformatted">(nconc x 'z)
     &rArr; (1 2 3 . z)
</pre></div><div class="group"><pre class="example-preformatted">x
     &rArr; (1 2 3 . z)
</pre></div></div>

<p>However, the other arguments (all but the last) must be lists.
</p>
<p>A common pitfall is to use a quoted constant list as a non-last
argument to <code class="code">nconc</code>.  If you do this, your program will change
each time you run it!  Here is what happens:
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">(defun add-foo (x)            ; <span class="r">We want this function to add</span>
  (nconc '(foo) x))           ;   <span class="r"><code class="code">foo</code> to the front of its arg.</span>
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(symbol-function 'add-foo)
     &rArr; (lambda (x) (nconc (quote (foo)) x))
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(setq xx (add-foo '(1 2)))    ; <span class="r">It seems to work.</span>
     &rArr; (foo 1 2)
</pre></div><div class="group"><pre class="example-preformatted">(setq xy (add-foo '(3 4)))    ; <span class="r">What happened?</span>
     &rArr; (foo 1 2 3 4)
</pre></div><div class="group"><pre class="example-preformatted">(eq xx xy)
     &rArr; t
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(symbol-function 'add-foo)
     &rArr; (lambda (x) (nconc (quote (foo 1 2 3 4) x)))
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-nreverse"><span class="category-def">Function: </span><span><strong class="def-name">nreverse</strong> <var class="def-var-arguments">list</var><a class="copiable-link" href="#index-nreverse"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-reversing-a-list"></a>
<p>This function reverses the order of the elements of <var class="var">list</var>.
Unlike <code class="code">reverse</code>, <code class="code">nreverse</code> alters its argument by reversing
the <small class="sc">CDR</small>s in the cons cells forming the list.  The cons cell that
used to be the last one in <var class="var">list</var> becomes the first cons cell of the
value.
</p>
<p>For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq x '(a b c))
     &rArr; (a b c)
</pre></div><div class="group"><pre class="example-preformatted">x
     &rArr; (a b c)
(nreverse x)
     &rArr; (c b a)
</pre></div><div class="group"><pre class="example-preformatted">;; <span class="r">The cons cell that was first is now last.</span>
x
     &rArr; (a)
</pre></div></div>

<p>To avoid confusion, we usually store the result of <code class="code">nreverse</code>
back in the same variable which held the original list:
</p>
<div class="example">
<pre class="example-preformatted">(setq x (nreverse x))
</pre></div>

<p>Here is the <code class="code">nreverse</code> of our favorite example, <code class="code">(a b c)</code>,
presented graphically:
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted"><span class="r">Original list head:</span>                       <span class="r">Reversed list:</span>
 -------------        -------------        ------------
| car  | cdr  |      | car  | cdr  |      | car | cdr  |
|   a  |  nil |&lt;--   |   b  |   o  |&lt;--   |   c |   o  |
|      |      |   |  |      |   |  |   |  |     |   |  |
 -------------    |   --------- | -    |   -------- | -
                  |             |      |            |
                   -------------        ------------
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-sort"><span class="category-def">Function: </span><span><strong class="def-name">sort</strong> <var class="def-var-arguments">list predicate</var><a class="copiable-link" href="#index-sort"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-stable-sort"></a>
<a class="index-entry-id" id="index-sorting-lists"></a>
<p>This function sorts <var class="var">list</var> stably, though destructively, and
returns the sorted list.  It compares elements using <var class="var">predicate</var>.  A
stable sort is one in which elements with equal sort keys maintain their
relative order before and after the sort.  Stability is important when
successive sorts are used to order elements according to different
criteria.
</p>
<p>The argument <var class="var">predicate</var> must be a function that accepts two
arguments.  It is called with two elements of <var class="var">list</var>.  To get an
increasing order sort, the <var class="var">predicate</var> should return non-<code class="code">nil</code> if the
first element is &ldquo;less than&rdquo; the second, or <code class="code">nil</code> if not.
</p>
<p>The comparison function <var class="var">predicate</var> must give reliable results for
any given pair of arguments, at least within a single call to
<code class="code">sort</code>.  It must be <em class="dfn">antisymmetric</em>; that is, if <var class="var">a</var> is
less than <var class="var">b</var>, <var class="var">b</var> must not be less than <var class="var">a</var>.  It must be
<em class="dfn">transitive</em>&mdash;that is, if <var class="var">a</var> is less than <var class="var">b</var>, and <var class="var">b</var>
is less than <var class="var">c</var>, then <var class="var">a</var> must be less than <var class="var">c</var>.  If you
use a comparison function which does not meet these requirements, the
result of <code class="code">sort</code> is unpredictable.
</p>
<p>The destructive aspect of <code class="code">sort</code> is that it rearranges the cons
cells forming <var class="var">list</var> by changing <small class="sc">CDR</small>s.  A nondestructive sort
function would create new cons cells to store the elements in their
sorted order.  If you wish to make a sorted copy without destroying the
original, copy it first with <code class="code">copy-sequence</code> and then sort.
</p>
<p>Sorting does not change the <small class="sc">CAR</small>s of the cons cells in <var class="var">list</var>;
the cons cell that originally contained the element <code class="code">a</code> in
<var class="var">list</var> still has <code class="code">a</code> in its <small class="sc">CAR</small> after sorting, but it now
appears in a different position in the list due to the change of
<small class="sc">CDR</small>s.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq nums '(1 3 2 6 5 4 0))
     &rArr; (1 3 2 6 5 4 0)
</pre></div><div class="group"><pre class="example-preformatted">(sort nums '&lt;)
     &rArr; (0 1 2 3 4 5 6)
</pre></div><div class="group"><pre class="example-preformatted">nums
     &rArr; (1 2 3 4 5 6)
</pre></div></div>

<p><strong class="strong">Warning</strong>: Note that the list in <code class="code">nums</code> no longer contains
0; this is the same cons cell that it was before, but it is no longer
the first one in the list.  Don&rsquo;t assume a variable that formerly held
the argument now holds the entire sorted list!  Instead, save the result
of <code class="code">sort</code> and use that.  Most often we store the result back into
the variable that held the original list:
</p>
<div class="example">
<pre class="example-preformatted">(setq nums (sort nums '&lt;))
</pre></div>

<p>See <a class="xref" href="Sorting.html">Sorting Text</a>, for more functions that perform sorting.
See <code class="code">documentation</code> in <a class="ref" href="Accessing-Documentation.html">Access to Documentation Strings</a>, for a
useful example of <code class="code">sort</code>.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Setcdr.html">Altering the CDR of a List</a>, Up: <a href="Modifying-Lists.html">Modifying Existing List Structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
