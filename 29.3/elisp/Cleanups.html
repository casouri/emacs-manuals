<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.3.

Copyright Â© 1990-1996, 1998-2024 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Cleanups (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Cleanups (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Cleanups (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Nonlocal-Exits.html" rel="up" title="Nonlocal Exits">
<link href="Errors.html" rel="prev" title="Errors">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Cleanups">
<div class="nav-panel">
<p>
Previous: <a href="Errors.html" accesskey="p" rel="prev">Errors</a>, Up: <a href="Nonlocal-Exits.html" accesskey="u" rel="up">Nonlocal Exits</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Cleaning-Up-from-Nonlocal-Exits"><span>11.7.4 Cleaning Up from Nonlocal Exits<a class="copiable-link" href="#Cleaning-Up-from-Nonlocal-Exits"> &para;</a></span></h4>
<a class="index-entry-id" id="index-nonlocal-exits_002c-cleaning-up"></a>
<a class="index-entry-id" id="index-forms-for-cleanup"></a>

<p>The <code class="code">unwind-protect</code> construct is essential whenever you
temporarily put a data structure in an inconsistent state; it permits
you to make the data consistent again in the event of an error or
throw.  (Another more specific cleanup construct that is used only for
changes in buffer contents is the atomic change group; <a class="ref" href="Atomic-Changes.html">Atomic Change Groups</a>.)
</p>
<dl class="first-deffn first-defspec-alias-first-deffn">
<dt class="deffn defspec-alias-deffn" id="index-unwind_002dprotect"><span class="category-def">Special Form: </span><span><strong class="def-name">unwind-protect</strong> <var class="def-var-arguments">body-form cleanup-forms&hellip;</var><a class="copiable-link" href="#index-unwind_002dprotect"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-cleanup-forms"></a>
<a class="index-entry-id" id="index-protected-forms"></a>
<a class="index-entry-id" id="index-error-cleanup"></a>
<a class="index-entry-id" id="index-unwinding"></a>
<p><code class="code">unwind-protect</code> executes <var class="var">body-form</var> with a guarantee that
the <var class="var">cleanup-forms</var> will be evaluated if control leaves
<var class="var">body-form</var>, no matter how that happens.  <var class="var">body-form</var> may
complete normally, or execute a <code class="code">throw</code> out of the
<code class="code">unwind-protect</code>, or cause an error; in all cases, the
<var class="var">cleanup-forms</var> will be evaluated.
</p>
<p>If <var class="var">body-form</var> finishes normally, <code class="code">unwind-protect</code> returns the
value of <var class="var">body-form</var>, after it evaluates the <var class="var">cleanup-forms</var>.
If <var class="var">body-form</var> does not finish, <code class="code">unwind-protect</code> does not
return any value in the normal sense.
</p>
<p>Only <var class="var">body-form</var> is protected by the <code class="code">unwind-protect</code>.  If any
of the <var class="var">cleanup-forms</var> themselves exits nonlocally (via a
<code class="code">throw</code> or an error), <code class="code">unwind-protect</code> is <em class="emph">not</em>
guaranteed to evaluate the rest of them.  If the failure of one of the
<var class="var">cleanup-forms</var> has the potential to cause trouble, then protect
it with another <code class="code">unwind-protect</code> around that form.
</p></dd></dl>

<p>For example, here we make an invisible buffer for temporary use, and
make sure to kill it before finishing:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(let ((buffer (get-buffer-create &quot; *temp*&quot;)))
  (with-current-buffer buffer
    (unwind-protect
        <var class="var">body-form</var>
      (kill-buffer buffer))))
</pre></div></div>

<p>You might think that we could just as well write <code class="code">(kill-buffer
(current-buffer))</code> and dispense with the variable <code class="code">buffer</code>.
However, the way shown above is safer, if <var class="var">body-form</var> happens to
get an error after switching to a different buffer!  (Alternatively,
you could write a <code class="code">save-current-buffer</code> around <var class="var">body-form</var>,
to ensure that the temporary buffer becomes current again in time to
kill it.)
</p>
<p>Emacs includes a standard macro called <code class="code">with-temp-buffer</code> which
expands into more or less the code shown above (see <a class="pxref" href="Current-Buffer.html#Definition-of-with_002dtemp_002dbuffer">Current Buffer</a>).  Several of the macros defined in
this manual use <code class="code">unwind-protect</code> in this way.
</p>
<a class="index-entry-id" id="index-ftp_002dlogin"></a>
<p>Here is an actual example derived from an FTP package.  It creates a
process (see <a class="pxref" href="Processes.html">Processes</a>) to try to establish a connection to a remote
machine.  As the function <code class="code">ftp-login</code> is highly susceptible to
numerous problems that the writer of the function cannot anticipate, it
is protected with a form that guarantees deletion of the process in the
event of failure.  Otherwise, Emacs might fill up with useless
subprocesses.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(let ((win nil))
  (unwind-protect
      (progn
        (setq process (ftp-setup-buffer host file))
        (if (setq win (ftp-login process host user password))
            (message &quot;Logged in&quot;)
          (error &quot;Ftp login failed&quot;)))
    (or win (and process (delete-process process)))))
</pre></div></div>

<p>This example has a small bug: if the user types <kbd class="kbd">C-g</kbd> to
quit, and the quit happens immediately after the function
<code class="code">ftp-setup-buffer</code> returns but before the variable <code class="code">process</code> is
set, the process will not be killed.  There is no easy way to fix this bug,
but at least it is very unlikely.
</p></div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Errors.html">Errors</a>, Up: <a href="Nonlocal-Exits.html">Nonlocal Exits</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
