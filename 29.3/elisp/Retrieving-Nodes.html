<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.3.

Copyright Â© 1990-1996, 1998-2024 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Retrieving Nodes (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Retrieving Nodes (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Retrieving Nodes (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-Program-Source.html" rel="up" title="Parsing Program Source">
<link href="Accessing-Node-Information.html" rel="next" title="Accessing Node Information">
<link href="Using-Parser.html" rel="prev" title="Using Parser">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Retrieving-Nodes">
<div class="nav-panel">
<p>
Next: <a href="Accessing-Node-Information.html" accesskey="n" rel="next">Accessing Node Information</a>, Previous: <a href="Using-Parser.html" accesskey="p" rel="prev">Using Tree-sitter Parser</a>, Up: <a href="Parsing-Program-Source.html" accesskey="u" rel="up">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Retrieving-Nodes-1"><span>37.3 Retrieving Nodes<a class="copiable-link" href="#Retrieving-Nodes-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-retrieve-node_002c-tree_002dsitter"></a>
<a class="index-entry-id" id="index-tree_002dsitter_002c-find-node"></a>
<a class="index-entry-id" id="index-get-node_002c-tree_002dsitter"></a>

<a class="index-entry-id" id="index-terminology_002c-for-tree_002dsitter-functions"></a>
<p>Here are some terms and conventions we use when documenting
tree-sitter functions.
</p>
<p>A node in a syntax tree spans some portion of the program text in the
buffer.  We say that a node is &ldquo;smaller&rdquo; or &ldquo;larger&rdquo; than another
if it spans, respectively, a smaller or larger portion of buffer text
than the other node.  Since nodes that are deeper (&ldquo;lower&rdquo;) in the
tree are children of the nodes that are &ldquo;higher&rdquo; in the tree, it
follows that a lower node will always be smaller than a node that is
higher in the node hierarchy.  A node that is higher up in the syntax
tree contains one or more smaller nodes as its children, and therefore
spans a larger portion of buffer text.
</p>
<p>When a function cannot find a node, it returns <code class="code">nil</code>.  For
convenience, all functions that take a node as argument and return
a node, also accept the node argument of <code class="code">nil</code> and in that case
just return <code class="code">nil</code>.
</p>
<a class="index-entry-id" id="index-treesit_002dnode_002doutdated"></a>
<p>Nodes are not automatically updated when the associated buffer is
modified, and there is no way to update a node once it is retrieved.
Using an outdated node signals the <code class="code">treesit-node-outdated</code> error.
</p>
<h3 class="heading" id="Retrieving-nodes-from-syntax-tree"><span>Retrieving nodes from syntax tree<a class="copiable-link" href="#Retrieving-nodes-from-syntax-tree"> &para;</a></span></h3>
<a class="index-entry-id" id="index-retrieving-tree_002dsitter-nodes"></a>
<a class="index-entry-id" id="index-syntax-tree_002c-retrieving-nodes"></a>

<a class="index-entry-id" id="index-leaf-node_002c-of-tree_002dsitter-parse-tree"></a>
<a class="index-entry-id" id="index-tree_002dsitter-parse-tree_002c-leaf-node"></a>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dat"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-at</strong> <var class="def-var-arguments">pos &amp;optional parser-or-lang named</var><a class="copiable-link" href="#index-treesit_002dnode_002dat"> &para;</a></span></dt>
<dd><p>This function returns a <em class="dfn">leaf</em> node at buffer position <var class="var">pos</var>.
A leaf node is a node that doesn&rsquo;t have any child nodes.
</p>
<p>This function tries to return a node whose span covers <var class="var">pos</var>: the
node&rsquo;s beginning position is less than or equal to <var class="var">pos</var>, and the
node&rsquo;s end position is greater than or equal to <var class="var">pos</var>.
</p>
<p>If no leaf node&rsquo;s span covers <var class="var">pos</var> (e.g., <var class="var">pos</var> is in the
whitespace between two leaf nodes), this function returns the first
leaf node after <var class="var">pos</var>.
</p>
<p>Finally, if there is no leaf node after <var class="var">pos</var>, return the first
leaf node before <var class="var">pos</var>.
</p>
<p>If <var class="var">parser-or-lang</var> is a parser object, this function uses that
parser; if <var class="var">parser-or-lang</var> is a language, this function uses the
first parser for that language in the current buffer, or creates one
if none exists; if <var class="var">parser-or-lang</var> is <code class="code">nil</code>, this function
tries to guess the language at <var class="var">pos</var> by calling
<code class="code">treesit-language-at</code> (see <a class="pxref" href="Multiple-Languages.html">Parsing Text in Multiple Languages</a>).
</p>
<p>If this function cannot find a suitable node to return, it returns
<code class="code">nil</code>.
</p>
<p>If <var class="var">named</var> is non-<code class="code">nil</code>, this function looks only for named
nodes (see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-named-node">named node</a>).
</p>
<p>Example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">;; Find the node at point in a C parser's syntax tree.
(treesit-node-at (point) 'c)
  &rArr; #&lt;treesit-node (primitive_type) in 23-27&gt;
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002don"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-on</strong> <var class="def-var-arguments">beg end &amp;optional parser-or-lang named</var><a class="copiable-link" href="#index-treesit_002dnode_002don"> &para;</a></span></dt>
<dd><p>This function returns the <em class="emph">smallest</em> node that covers the region
of buffer text between <var class="var">beg</var> and <var class="var">end</var>.  In other words, the
start of the node is before or at <var class="var">beg</var>, and the end of the node
is at or after <var class="var">end</var>.
</p>
<p><em class="emph">Beware:</em> calling this function on an empty line that is not
inside any top-level construct (function definition, etc.) most
probably will give you the root node, because the root node is the
smallest node that covers that empty line.  Most of the time, you want
to use <code class="code">treesit-node-at</code> instead.
</p>
<p>If <var class="var">parser-or-lang</var> is a parser object, this function uses that
parser; if <var class="var">parser-or-lang</var> is a language, this function uses the
first parser for that language in the current buffer, or creates one
if none exists; if <var class="var">parser-or-lang</var> is <code class="code">nil</code>, this function
tries to guess the language at <var class="var">beg</var> by calling
<code class="code">treesit-language-at</code>.
</p>
<p>If <var class="var">named</var> is non-<code class="code">nil</code>, this function looks for a named node
only (see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-named-node">named node</a>).
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002droot_002dnode"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-root-node</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002droot_002dnode"> &para;</a></span></dt>
<dd><p>This function returns the root node of the syntax tree generated by
<var class="var">parser</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dbuffer_002droot_002dnode"><span class="category-def">Function: </span><span><strong class="def-name">treesit-buffer-root-node</strong> <var class="def-var-arguments">&amp;optional language</var><a class="copiable-link" href="#index-treesit_002dbuffer_002droot_002dnode"> &para;</a></span></dt>
<dd><p>This function finds the first parser for <var class="var">language</var> in the current
buffer, or creates one if none exists, and returns the root node
generated by that parser.  If <var class="var">language</var> is omitted, it uses the
first parser in the parser list.  If it cannot find an appropriate
parser, it returns <code class="code">nil</code>.
</p></dd></dl>

<p>Given a node, a Lisp program can retrieve other nodes starting from
it, or query for information about this node.
</p>
<h3 class="heading" id="Retrieving-nodes-from-other-nodes"><span>Retrieving nodes from other nodes<a class="copiable-link" href="#Retrieving-nodes-from-other-nodes"> &para;</a></span></h3>
<a class="index-entry-id" id="index-syntax-tree-nodes_002c-retrieving-from-other-nodes"></a>

<h4 class="subheading" id="By-kinship"><span>By kinship<a class="copiable-link" href="#By-kinship"> &para;</a></span></h4>
<a class="index-entry-id" id="index-kinship_002c-syntax-tree-nodes"></a>
<a class="index-entry-id" id="index-nodes_002c-by-kinship"></a>
<a class="index-entry-id" id="index-syntax-tree-nodes_002c-by-kinship"></a>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dparent"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-parent</strong> <var class="def-var-arguments">node</var><a class="copiable-link" href="#index-treesit_002dnode_002dparent"> &para;</a></span></dt>
<dd><p>This function returns the immediate parent of <var class="var">node</var>.
</p>
<p>If <var class="var">node</var> is more than 1000 levels deep in a parse tree, the
return value is undefined.  Currently it returns <code class="code">nil</code>, but that
could change in the future.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dchild"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-child</strong> <var class="def-var-arguments">node n &amp;optional named</var><a class="copiable-link" href="#index-treesit_002dnode_002dchild"> &para;</a></span></dt>
<dd><p>This function returns the <var class="var">n</var>&rsquo;th child of <var class="var">node</var>.  If
<var class="var">named</var> is non-<code class="code">nil</code>, it counts only named nodes
(see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-named-node">named node</a>).
</p>
<p>For example, in a node that represents a string <code class="code">&quot;text&quot;</code>, there
are three children nodes: the opening quote <code class="code">&quot;</code>, the string text
<code class="code">text</code>, and the closing quote <code class="code">&quot;</code>.  Among these nodes, the
first child is the opening quote <code class="code">&quot;</code>, and the first named child
is the string text.
</p>
<p>This function returns <code class="code">nil</code> if there is no <var class="var">n</var>&rsquo;th child.
<var class="var">n</var> could be negative, e.g., &minus;1 represents the last child.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dchildren"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-children</strong> <var class="def-var-arguments">node &amp;optional named</var><a class="copiable-link" href="#index-treesit_002dnode_002dchildren"> &para;</a></span></dt>
<dd><p>This function returns all of <var class="var">node</var>&rsquo;s children as a list.  If
<var class="var">named</var> is non-<code class="code">nil</code>, it retrieves only named nodes.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dnext_002dsibling"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-next-sibling</strong> <var class="def-var-arguments">node &amp;optional named</var><a class="copiable-link" href="#index-treesit_002dnode_002dnext_002dsibling"> &para;</a></span></dt>
<dd><p>This function finds the next sibling of <var class="var">node</var>.  If <var class="var">named</var> is
non-<code class="code">nil</code>, it finds the next named sibling.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dprev_002dsibling"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-prev-sibling</strong> <var class="def-var-arguments">node &amp;optional named</var><a class="copiable-link" href="#index-treesit_002dnode_002dprev_002dsibling"> &para;</a></span></dt>
<dd><p>This function finds the previous sibling of <var class="var">node</var>.  If
<var class="var">named</var> is non-<code class="code">nil</code>, it finds the previous named sibling.
</p></dd></dl>

<h4 class="subheading" id="By-field-name"><span>By field name<a class="copiable-link" href="#By-field-name"> &para;</a></span></h4>
<a class="index-entry-id" id="index-nodes_002c-by-field-name"></a>
<a class="index-entry-id" id="index-syntax-tree-nodes_002c-by-field-name"></a>

<p>To make the syntax tree easier to analyze, many language grammars
assign <em class="dfn">field names</em> to child nodes (see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-node-field-name">field name</a>).  For example, a <code class="code">function_definition</code> node
could have a <code class="code">declarator</code> node and a <code class="code">body</code> node.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dchild_002dby_002dfield_002dname"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-child-by-field-name</strong> <var class="def-var-arguments">node field-name</var><a class="copiable-link" href="#index-treesit_002dnode_002dchild_002dby_002dfield_002dname"> &para;</a></span></dt>
<dd><p>This function finds the child of <var class="var">node</var> whose field name is
<var class="var">field-name</var>, a string.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">;; Get the child that has &quot;body&quot; as its field name.
(treesit-node-child-by-field-name node &quot;body&quot;)
  &rArr; #&lt;treesit-node (compound_statement) in 45-89&gt;
</pre></div></div>
</dd></dl>

<h4 class="subheading" id="By-position"><span>By position<a class="copiable-link" href="#By-position"> &para;</a></span></h4>
<a class="index-entry-id" id="index-nodes_002c-by-position"></a>
<a class="index-entry-id" id="index-syntax-tree-nodes_002c-by-position"></a>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dfirst_002dchild_002dfor_002dpos"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-first-child-for-pos</strong> <var class="def-var-arguments">node pos &amp;optional named</var><a class="copiable-link" href="#index-treesit_002dnode_002dfirst_002dchild_002dfor_002dpos"> &para;</a></span></dt>
<dd><p>This function finds the first child of <var class="var">node</var> that extends beyond
buffer position <var class="var">pos</var>.  &ldquo;Extends beyond&rdquo; means the end of the
child node is greater or equal to <var class="var">pos</var>.  This function only looks
for immediate children of <var class="var">node</var>, and doesn&rsquo;t look in its
grandchildren.  If <var class="var">named</var> is non-<code class="code">nil</code>, it looks for the
first named child (see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-named-node">named node</a>).
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002ddescendant_002dfor_002drange"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-descendant-for-range</strong> <var class="def-var-arguments">node beg end &amp;optional named</var><a class="copiable-link" href="#index-treesit_002dnode_002ddescendant_002dfor_002drange"> &para;</a></span></dt>
<dd><p>This function finds the <em class="emph">smallest</em> descendant node of <var class="var">node</var>
that spans the region of text between positions <var class="var">beg</var> and
<var class="var">end</var>.  It is similar to <code class="code">treesit-node-at</code>.  If <var class="var">named</var>
is non-<code class="code">nil</code>, it looks for the smallest named child.
</p></dd></dl>

<h3 class="heading" id="Searching-for-node"><span>Searching for node<a class="copiable-link" href="#Searching-for-node"> &para;</a></span></h3>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dsearch_002dsubtree"><span class="category-def">Function: </span><span><strong class="def-name">treesit-search-subtree</strong> <var class="def-var-arguments">node predicate &amp;optional backward all depth</var><a class="copiable-link" href="#index-treesit_002dsearch_002dsubtree"> &para;</a></span></dt>
<dd><p>This function traverses the subtree of <var class="var">node</var> (including
<var class="var">node</var> itself), looking for a node for which <var class="var">predicate</var>
returns non-<code class="code">nil</code>.  <var class="var">predicate</var> is a regexp that is matched
against each node&rsquo;s type, or a predicate function that takes a node
and returns non-<code class="code">nil</code> if the node matches.  The function returns
the first node that matches, or <code class="code">nil</code> if none does.
</p>
<p>By default, this function only traverses named nodes, but if <var class="var">all</var>
is non-<code class="code">nil</code>, it traverses all the nodes.  If <var class="var">backward</var> is
non-<code class="code">nil</code>, it traverses backwards (i.e., it visits the last child
first when traversing down the tree).  If <var class="var">depth</var> is
non-<code class="code">nil</code>, it must be a number that limits the tree traversal to
that many levels down the tree.  If <var class="var">depth</var> is <code class="code">nil</code>, it
defaults to 1000.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dsearch_002dforward"><span class="category-def">Function: </span><span><strong class="def-name">treesit-search-forward</strong> <var class="def-var-arguments">start predicate &amp;optional backward all</var><a class="copiable-link" href="#index-treesit_002dsearch_002dforward"> &para;</a></span></dt>
<dd><p>Like <code class="code">treesit-search-subtree</code>, this function also traverses the
parse tree and matches each node with <var class="var">predicate</var> (except for
<var class="var">start</var>), where <var class="var">predicate</var> can be a regexp or a function.
For a tree like the one below where <var class="var">start</var> is marked &lsquo;<samp class="samp">S</samp>&rsquo;,
this function traverses as numbered from 1 to 12:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">              12
              |
     S--------3----------11
     |        |          |
o--o-+--o  1--+--2    6--+-----10
|  |                  |        |
o  o                +-+-+   +--+--+
                    |   |   |  |  |
                    4   5   7  8  9
</pre></div></div>

<p>Note that this function doesn&rsquo;t traverse the subtree of <var class="var">start</var>,
and it always traverses leaf nodes first, before moving upwards.
</p>
<p>Like <code class="code">treesit-search-subtree</code>, this function only searches for
named nodes by default, but if <var class="var">all</var> is non-<code class="code">nil</code>, it
searches for all nodes.  If <var class="var">backward</var> is non-<code class="code">nil</code>, it
searches backwards.
</p>
<p>While <code class="code">treesit-search-subtree</code> traverses the subtree of a node,
this function starts with node <var class="var">start</var> and traverses every node
that comes after it in the buffer position order, i.e., nodes with
start positions greater than the end position of <var class="var">start</var>.
</p>
<p>In the tree shown above, <code class="code">treesit-search-subtree</code> traverses node
&lsquo;<samp class="samp">S</samp>&rsquo; (<var class="var">start</var>) and nodes marked with <code class="code">o</code>, whereas this
function traverses the nodes marked with numbers.  This function is
useful for answering questions like &ldquo;what is the first node after
<var class="var">start</var> in the buffer that satisfies some condition?&rdquo;
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dsearch_002dforward_002dgoto"><span class="category-def">Function: </span><span><strong class="def-name">treesit-search-forward-goto</strong> <var class="def-var-arguments">node predicate &amp;optional start backward all</var><a class="copiable-link" href="#index-treesit_002dsearch_002dforward_002dgoto"> &para;</a></span></dt>
<dd><p>This function moves point to the start or end of the next node after
<var class="var">node</var> in the buffer that matches <var class="var">predicate</var>.  If <var class="var">start</var>
is non-<code class="code">nil</code>, stop at the beginning rather than the end of a node.
</p>
<p>This function guarantees that the matched node it returns makes
progress in terms of buffer position: the start/end position of the
returned node is always greater than that of <var class="var">node</var>.
</p>
<p>Arguments <var class="var">predicate</var>, <var class="var">backward</var>, and <var class="var">all</var> are the same
as in <code class="code">treesit-search-forward</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dinduce_002dsparse_002dtree"><span class="category-def">Function: </span><span><strong class="def-name">treesit-induce-sparse-tree</strong> <var class="def-var-arguments">root predicate &amp;optional process-fn depth</var><a class="copiable-link" href="#index-treesit_002dinduce_002dsparse_002dtree"> &para;</a></span></dt>
<dd><p>This function creates a sparse tree from <var class="var">root</var>&rsquo;s subtree.
</p>
<p>It takes the subtree under <var class="var">root</var>, and combs it so only the nodes
that match <var class="var">predicate</var> are left.  Like previous functions, the
<var class="var">predicate</var> can be a regexp string that matches against each
node&rsquo;s type, or a function that takes a node and returns
non-<code class="code">nil</code> if it matches.
</p>
<p>For example, given the subtree on the left that consists of both
numbers and letters, if <var class="var">predicate</var> is &ldquo;letter only&rdquo;, the
returned tree is the one on the right.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">    a                 a              a
    |                 |              |
+---+---+         +---+---+      +---+---+
|   |   |         |   |   |      |   |   |
b   1   2         b   |   |      b   c   d
    |   |     =&gt;      |   |  =&gt;      |
    c   +--+          c   +          e
    |   |  |          |   |
 +--+   d  4       +--+   d
 |  |              |
 e  5              e
</pre></div></div>

<p>If <var class="var">process-fn</var> is non-<code class="code">nil</code>, instead of returning the
matched nodes, this function passes each node to <var class="var">process-fn</var> and
uses the returned value instead.  If non-<code class="code">nil</code>, <var class="var">depth</var>
limits the number of levels to go down from <var class="var">root</var>.  If
<var class="var">depth</var> is <code class="code">nil</code>, it defaults to 1000.
</p>
<p>Each node in the returned tree looks like
<code class="code">(<var class="var">tree-sitter-node</var>&nbsp;.&nbsp;(<var class="var">child</var>&nbsp;&hellip;))</code><!-- /@w -->.  The
<var class="var">tree-sitter-node</var> of the root of this tree will be <code class="code">nil</code> if
<var class="var">root</var> doesn&rsquo;t match <var class="var">predicate</var>.  If no node matches
<var class="var">predicate</var>, the function returns <code class="code">nil</code>.
</p></dd></dl>

<h3 class="heading" id="More-convenience-functions"><span>More convenience functions<a class="copiable-link" href="#More-convenience-functions"> &para;</a></span></h3>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dfilter_002dchild"><span class="category-def">Function: </span><span><strong class="def-name">treesit-filter-child</strong> <var class="def-var-arguments">node predicate &amp;optional named</var><a class="copiable-link" href="#index-treesit_002dfilter_002dchild"> &para;</a></span></dt>
<dd><p>This function finds immediate children of <var class="var">node</var> that satisfy
<var class="var">predicate</var>.
</p>
<p>The <var class="var">predicate</var> function takes a node as argument and should
return non-<code class="code">nil</code> to indicate that the node should be kept.  If
<var class="var">named</var> is non-<code class="code">nil</code>, this function only examines named
nodes.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparent_002duntil"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parent-until</strong> <var class="def-var-arguments">node predicate &amp;optional include-node</var><a class="copiable-link" href="#index-treesit_002dparent_002duntil"> &para;</a></span></dt>
<dd><p>This function repeatedly finds the parents of <var class="var">node</var>, and returns
the parent that satisfies <var class="var">predicate</var>, a function that takes a node as
argument and returns a boolean that indicates a match.  If no parent
satisfies <var class="var">predicate</var>, this function returns <code class="code">nil</code>.
</p>
<p>Normally this function only looks at the parents of <var class="var">node</var> but not
<var class="var">node</var> itself.  But if <var class="var">include-node</var> is non-<code class="code">nil</code>, this
function returns <var class="var">node</var> if <var class="var">node</var> satisfies <var class="var">predicate</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparent_002dwhile"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parent-while</strong> <var class="def-var-arguments">node predicate</var><a class="copiable-link" href="#index-treesit_002dparent_002dwhile"> &para;</a></span></dt>
<dd><p>This function goes up the tree starting from <var class="var">node</var>, and keeps
doing so as long as the nodes satisfy <var class="var">predicate</var>, a function that
takes a node as argument.  That is, this function returns the highest
parent of <var class="var">node</var> that still satisfies <var class="var">predicate</var>.  Note that if
<var class="var">node</var> satisfies <var class="var">predicate</var> but its immediate parent doesn&rsquo;t,
<var class="var">node</var> itself is returned.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dtop_002dlevel"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-top-level</strong> <var class="def-var-arguments">node &amp;optional predicate include-node</var><a class="copiable-link" href="#index-treesit_002dnode_002dtop_002dlevel"> &para;</a></span></dt>
<dd><p>This function returns the highest parent of <var class="var">node</var> that has the
same type as <var class="var">node</var>.  If no such parent exists, it returns
<code class="code">nil</code>.  Therefore this function is also useful for testing
whether <var class="var">node</var> is top-level.
</p>
<p>If <var class="var">predicate</var> is <code class="code">nil</code>, this function uses <var class="var">node</var>&rsquo;s type
to find the parent.  If <var class="var">predicate</var> is non-<code class="code">nil</code>, this
function searches the parent that satisfies <var class="var">predicate</var>.  If
<var class="var">include-node</var> is non-<code class="code">nil</code>, this function returns <var class="var">node</var>
if <var class="var">node</var> satisfies <var class="var">predicate</var>.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Accessing-Node-Information.html">Accessing Node Information</a>, Previous: <a href="Using-Parser.html">Using Tree-sitter Parser</a>, Up: <a href="Parsing-Program-Source.html">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
