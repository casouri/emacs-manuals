<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.3.

Copyright © 1990-1996, 1998-2024 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Regexp Special (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Regexp Special (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Regexp Special (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Syntax-of-Regexps.html" rel="up" title="Syntax of Regexps">
<link href="Char-Classes.html" rel="next" title="Char Classes">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsubsection-level-extent" id="Regexp-Special">
<div class="nav-panel">
<p>
Next: <a href="Char-Classes.html" accesskey="n" rel="next">Character Classes</a>, Up: <a href="Syntax-of-Regexps.html" accesskey="u" rel="up">Syntax of Regular Expressions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsubsection" id="Special-Characters-in-Regular-Expressions"><span>35.3.1.1 Special Characters in Regular Expressions<a class="copiable-link" href="#Special-Characters-in-Regular-Expressions"> &para;</a></span></h4>
<a class="index-entry-id" id="index-regexp_002c-special-characters-in"></a>

<p>Here is a list of the characters that are special in a regular
expression.
</p>
<dl class="table">
<dt><a id="index-_002e-in-regexp"></a><span>&lsquo;<samp class="samp">.</samp>&rsquo; <span class="r">(Period)</span><a class="copiable-link" href="#index-_002e-in-regexp"> &para;</a></span></dt>
<dd><p>is a special character that matches any single character except a newline.
Using concatenation, we can make regular expressions like &lsquo;<samp class="samp">a.b</samp>&rsquo;, which
matches any three-character string that begins with &lsquo;<samp class="samp">a</samp>&rsquo; and ends with
&lsquo;<samp class="samp">b</samp>&rsquo;.
</p>
</dd>
<dt><a id="index-_002a-in-regexp"></a><span>&lsquo;<samp class="samp">*</samp>&rsquo;<a class="copiable-link" href="#index-_002a-in-regexp"> &para;</a></span></dt>
<dd><p>is not a construct by itself; it is a postfix operator that means to
match the preceding regular expression repetitively as many times as
possible.  Thus, &lsquo;<samp class="samp">o*</samp>&rsquo; matches any number of &lsquo;<samp class="samp">o</samp>&rsquo;s (including no
&lsquo;<samp class="samp">o</samp>&rsquo;s).
</p>
<p>&lsquo;<samp class="samp">*</samp>&rsquo; always applies to the <em class="emph">smallest</em> possible preceding
expression.  Thus, &lsquo;<samp class="samp">fo*</samp>&rsquo; has a repeating &lsquo;<samp class="samp">o</samp>&rsquo;, not a repeating
&lsquo;<samp class="samp">fo</samp>&rsquo;.  It matches &lsquo;<samp class="samp">f</samp>&rsquo;, &lsquo;<samp class="samp">fo</samp>&rsquo;, &lsquo;<samp class="samp">foo</samp>&rsquo;, and so on.
</p>
<a class="index-entry-id" id="index-backtracking-and-regular-expressions"></a>
<p>The matcher processes a &lsquo;<samp class="samp">*</samp>&rsquo; construct by matching, immediately, as
many repetitions as can be found.  Then it continues with the rest of
the pattern.  If that fails, backtracking occurs, discarding some of the
matches of the &lsquo;<samp class="samp">*</samp>&rsquo;-modified construct in the hope that this will
make it possible to match the rest of the pattern.  For example, in
matching &lsquo;<samp class="samp">ca*ar</samp>&rsquo; against the string &lsquo;<samp class="samp">caaar</samp>&rsquo;, the &lsquo;<samp class="samp">a*</samp>&rsquo;
first tries to match all three &lsquo;<samp class="samp">a</samp>&rsquo;s; but the rest of the pattern is
&lsquo;<samp class="samp">ar</samp>&rsquo; and there is only &lsquo;<samp class="samp">r</samp>&rsquo; left to match, so this try fails.
The next alternative is for &lsquo;<samp class="samp">a*</samp>&rsquo; to match only two &lsquo;<samp class="samp">a</samp>&rsquo;s.  With
this choice, the rest of the regexp matches successfully.
</p>
</dd>
<dt><a id="index-_002b-in-regexp"></a><span>&lsquo;<samp class="samp">+</samp>&rsquo;<a class="copiable-link" href="#index-_002b-in-regexp"> &para;</a></span></dt>
<dd><p>is a postfix operator, similar to &lsquo;<samp class="samp">*</samp>&rsquo; except that it must match
the preceding expression at least once.  So, for example, &lsquo;<samp class="samp">ca+r</samp>&rsquo;
matches the strings &lsquo;<samp class="samp">car</samp>&rsquo; and &lsquo;<samp class="samp">caaaar</samp>&rsquo; but not the string
&lsquo;<samp class="samp">cr</samp>&rsquo;, whereas &lsquo;<samp class="samp">ca*r</samp>&rsquo; matches all three strings.
</p>
</dd>
<dt><a id="index-_003f-in-regexp"></a><span>&lsquo;<samp class="samp">?</samp>&rsquo;<a class="copiable-link" href="#index-_003f-in-regexp"> &para;</a></span></dt>
<dd><p>is a postfix operator, similar to &lsquo;<samp class="samp">*</samp>&rsquo; except that it must match the
preceding expression either once or not at all.  For example,
&lsquo;<samp class="samp">ca?r</samp>&rsquo; matches &lsquo;<samp class="samp">car</samp>&rsquo; or &lsquo;<samp class="samp">cr</samp>&rsquo;; nothing else.
</p>
<a class="anchor" id="Non_002dgreedy-repetition"></a></dd>
<dt><a id="index-non_002dgreedy-repetition-characters-in-regexp"></a><span>&lsquo;<samp class="samp">*?</samp>&rsquo;, &lsquo;<samp class="samp">+?</samp>&rsquo;, &lsquo;<samp class="samp">??</samp>&rsquo;<a class="copiable-link" href="#index-non_002dgreedy-repetition-characters-in-regexp"> &para;</a></span></dt>
<dd><p>are <em class="dfn">non-greedy</em> variants of the operators &lsquo;<samp class="samp">*</samp>&rsquo;, &lsquo;<samp class="samp">+</samp>&rsquo;
and &lsquo;<samp class="samp">?</samp>&rsquo;.  Where those operators match the largest possible
substring (consistent with matching the entire containing expression),
the non-greedy variants match the smallest possible substring
(consistent with matching the entire containing expression).
</p>
<p>For example, the regular expression &lsquo;<samp class="samp">c[ad]*a</samp>&rsquo; when applied to the
string &lsquo;<samp class="samp">cdaaada</samp>&rsquo; matches the whole string; but the regular
expression &lsquo;<samp class="samp">c[ad]*?a</samp>&rsquo;, applied to that same string, matches just
&lsquo;<samp class="samp">cda</samp>&rsquo;.  (The smallest possible match here for &lsquo;<samp class="samp">[ad]*?</samp>&rsquo; that
permits the whole expression to match is &lsquo;<samp class="samp">d</samp>&rsquo;.)
</p>
</dd>
<dt><a class="index-entry-id" id="index-_005b-in-regexp"></a>
<a class="index-entry-id" id="index-_005d-in-regexp"></a>
<a id="index-character-alternative-_0028in-regexp_0029"></a><span>&lsquo;<samp class="samp">[ &hellip; ]</samp>&rsquo;<a class="copiable-link" href="#index-character-alternative-_0028in-regexp_0029"> &para;</a></span></dt>
<dd><p>is a <em class="dfn">character alternative</em>, which begins with &lsquo;<samp class="samp">[</samp>&rsquo; and is
terminated by &lsquo;<samp class="samp">]</samp>&rsquo;.  In the simplest case, the characters between
the two brackets are what this character alternative can match.
</p>
<p>Thus, &lsquo;<samp class="samp">[ad]</samp>&rsquo; matches either one &lsquo;<samp class="samp">a</samp>&rsquo; or one &lsquo;<samp class="samp">d</samp>&rsquo;, and
&lsquo;<samp class="samp">[ad]*</samp>&rsquo; matches any string composed of just &lsquo;<samp class="samp">a</samp>&rsquo;s and &lsquo;<samp class="samp">d</samp>&rsquo;s
(including the empty string).  It follows that &lsquo;<samp class="samp">c[ad]*r</samp>&rsquo;
matches &lsquo;<samp class="samp">cr</samp>&rsquo;, &lsquo;<samp class="samp">car</samp>&rsquo;, &lsquo;<samp class="samp">cdr</samp>&rsquo;, &lsquo;<samp class="samp">caddaar</samp>&rsquo;, etc.
</p>
<p>You can also include character ranges in a character alternative, by
writing the starting and ending characters with a &lsquo;<samp class="samp">-</samp>&rsquo; between them.
Thus, &lsquo;<samp class="samp">[a-z]</samp>&rsquo; matches any lower-case <abbr class="acronym">ASCII</abbr> letter.
Ranges may be intermixed freely with individual characters, as in
&lsquo;<samp class="samp">[a-z$%.]</samp>&rsquo;, which matches any lower case <abbr class="acronym">ASCII</abbr> letter
or &lsquo;<samp class="samp">$</samp>&rsquo;, &lsquo;<samp class="samp">%</samp>&rsquo; or period.  However, the ending character of one
range should not be the starting point of another one; for example,
&lsquo;<samp class="samp">[a-m-z]</samp>&rsquo; should be avoided.
</p>
<p>A character alternative can also specify named character classes
(see <a class="pxref" href="Char-Classes.html">Character Classes</a>).  For example, &lsquo;<samp class="samp">[[:ascii:]]</samp>&rsquo; matches any
<abbr class="acronym">ASCII</abbr> character.  Using a character class is equivalent to
mentioning each of the characters in that class; but the latter is not
feasible in practice, since some classes include thousands of
different characters.  A character class should not appear as the
lower or upper bound of a range.
</p>
<p>The usual regexp special characters are not special inside a
character alternative.  A completely different set of characters is
special: &lsquo;<samp class="samp">]</samp>&rsquo;, &lsquo;<samp class="samp">-</samp>&rsquo; and &lsquo;<samp class="samp">^</samp>&rsquo;.
To include &lsquo;<samp class="samp">]</samp>&rsquo; in a character alternative, put it at the
beginning.  To include &lsquo;<samp class="samp">^</samp>&rsquo;, put it anywhere but at the beginning.
To include &lsquo;<samp class="samp">-</samp>&rsquo;, put it at the end.  Thus, &lsquo;<samp class="samp">[]^-]</samp>&rsquo; matches
all three of these special characters.  You cannot use &lsquo;<samp class="samp">\</samp>&rsquo; to
escape these three characters, since &lsquo;<samp class="samp">\</samp>&rsquo; is not special here.
</p>
<p>The following aspects of ranges are specific to Emacs, in that POSIX
allows but does not require this behavior and programs other than
Emacs may behave differently:
</p>
<ol class="enumerate">
<li> If <code class="code">case-fold-search</code> is non-<code class="code">nil</code>, &lsquo;<samp class="samp">[a-z]</samp>&rsquo; also
matches upper-case letters.

</li><li> A range is not affected by the locale&rsquo;s collation sequence: it always
represents the set of characters with codepoints ranging between those
of its bounds, so that &lsquo;<samp class="samp">[a-z]</samp>&rsquo; matches only ASCII letters, even
outside the C or POSIX locale.

</li><li> If the lower bound of a range is greater than its upper bound, the
range is empty and represents no characters.  Thus, &lsquo;<samp class="samp">[z-a]</samp>&rsquo;
always fails to match, and &lsquo;<samp class="samp">[^z-a]</samp>&rsquo; matches any character,
including newline.  However, a reversed range should always be from
the letter &lsquo;<samp class="samp">z</samp>&rsquo; to the letter &lsquo;<samp class="samp">a</samp>&rsquo; to make it clear that it is
not a typo; for example, &lsquo;<samp class="samp">[+-*/]</samp>&rsquo; should be avoided, because it
matches only &lsquo;<samp class="samp">/</samp>&rsquo; rather than the likely-intended four characters.

</li><li> If the end points of a range are raw 8-bit bytes (see <a class="pxref" href="Text-Representations.html">Text Representations</a>), or if the range start is ASCII and the end is a raw
byte (as in &lsquo;<samp class="samp">[a-\377]</samp>&rsquo;), the range will match only ASCII
characters and raw 8-bit bytes, but not non-ASCII characters.  This
feature is intended for searching text in unibyte buffers and strings.
</li></ol>

<p>Some kinds of character alternatives are not the best style even
though they have a well-defined meaning in Emacs.  They include:
</p>
<ol class="enumerate">
<li> Although a range&rsquo;s bound can be almost any character, it is better
style to stay within natural sequences of ASCII letters and digits
because most people have not memorized character code tables.
For example, &lsquo;<samp class="samp">[.-9]</samp>&rsquo; is less clear than &lsquo;<samp class="samp">[./0-9]</samp>&rsquo;,
and &lsquo;<samp class="samp">[`-~]</samp>&rsquo; is less clear than &lsquo;<samp class="samp">[`a-z{|}~]</samp>&rsquo;.
Unicode character escapes can help here; for example, for most programmers
&lsquo;<samp class="samp">[ก-ฺ฿-๛]</samp>&rsquo; is less clear than &lsquo;<samp class="samp">[\u0E01-\u0E3A\u0E3F-\u0E5B]</samp>&rsquo;.

</li><li> Although a character alternative can include duplicates, it is better
style to avoid them.  For example, &lsquo;<samp class="samp">[XYa-yYb-zX]</samp>&rsquo; is less clear
than &lsquo;<samp class="samp">[XYa-z]</samp>&rsquo;.

</li><li> Although a range can denote just one, two, or three characters, it
is simpler to list the characters.  For example,
&lsquo;<samp class="samp">[a-a0]</samp>&rsquo; is less clear than &lsquo;<samp class="samp">[a0]</samp>&rsquo;, &lsquo;<samp class="samp">[i-j]</samp>&rsquo; is less clear
than &lsquo;<samp class="samp">[ij]</samp>&rsquo;, and &lsquo;<samp class="samp">[i-k]</samp>&rsquo; is less clear than &lsquo;<samp class="samp">[ijk]</samp>&rsquo;.

</li><li> Although a &lsquo;<samp class="samp">-</samp>&rsquo; can appear at the beginning of a character
alternative or as the upper bound of a range, it is better style to
put &lsquo;<samp class="samp">-</samp>&rsquo; by itself at the end of a character alternative.  For
example, although &lsquo;<samp class="samp">[-a-z]</samp>&rsquo; is valid, &lsquo;<samp class="samp">[a-z-]</samp>&rsquo; is better
style; and although &lsquo;<samp class="samp">[*--]</samp>&rsquo; is valid, &lsquo;<samp class="samp">[*+,-]</samp>&rsquo; is clearer.
</li></ol>

</dd>
<dt><a id="index-_005e-in-regexp"></a><span>&lsquo;<samp class="samp">[^ &hellip; ]</samp>&rsquo;<a class="copiable-link" href="#index-_005e-in-regexp"> &para;</a></span></dt>
<dd><p>&lsquo;<samp class="samp">[^</samp>&rsquo; begins a <em class="dfn">complemented character alternative</em>.  This
matches any character except the ones specified.  Thus,
&lsquo;<samp class="samp">[^a-z0-9A-Z]</samp>&rsquo; matches all characters <em class="emph">except</em> ASCII letters and
digits.
</p>
<p>&lsquo;<samp class="samp">^</samp>&rsquo; is not special in a character alternative unless it is the first
character.  The character following the &lsquo;<samp class="samp">^</samp>&rsquo; is treated as if it
were first (in other words, &lsquo;<samp class="samp">-</samp>&rsquo; and &lsquo;<samp class="samp">]</samp>&rsquo; are not special there).
</p>
<p>A complemented character alternative can match a newline, unless newline is
mentioned as one of the characters not to match.  This is in contrast to
the handling of regexps in programs such as <code class="code">grep</code>.
</p>
<p>You can specify named character classes, just like in character
alternatives.  For instance, &lsquo;<samp class="samp">[^[:ascii:]]</samp>&rsquo; matches any
non-<abbr class="acronym">ASCII</abbr> character.  See <a class="xref" href="Char-Classes.html">Character Classes</a>.
</p>
</dd>
<dt><a id="index-beginning-of-line-in-regexp"></a><span>&lsquo;<samp class="samp">^</samp>&rsquo;<a class="copiable-link" href="#index-beginning-of-line-in-regexp"> &para;</a></span></dt>
<dd><p>When matching a buffer, &lsquo;<samp class="samp">^</samp>&rsquo; matches the empty string, but only at the
beginning of a line in the text being matched (or the beginning of the
accessible portion of the buffer).  Otherwise it fails to match
anything.  Thus, &lsquo;<samp class="samp">^foo</samp>&rsquo; matches a &lsquo;<samp class="samp">foo</samp>&rsquo; that occurs at the
beginning of a line.
</p>
<p>When matching a string instead of a buffer, &lsquo;<samp class="samp">^</samp>&rsquo; matches at the
beginning of the string or after a newline character.
</p>
<p>For historical compatibility reasons, &lsquo;<samp class="samp">^</samp>&rsquo; can be used only at the
beginning of the regular expression, or after &lsquo;<samp class="samp">\(</samp>&rsquo;, &lsquo;<samp class="samp">\(?:</samp>&rsquo;
or &lsquo;<samp class="samp">\|</samp>&rsquo;.
</p>
</dd>
<dt><a class="index-entry-id" id="index-end-of-line-in-regexp"></a>
<a id="index-_0024-in-regexp"></a><span>&lsquo;<samp class="samp">$</samp>&rsquo;<a class="copiable-link" href="#index-_0024-in-regexp"> &para;</a></span></dt>
<dd><p>is similar to &lsquo;<samp class="samp">^</samp>&rsquo; but matches only at the end of a line (or the
end of the accessible portion of the buffer).  Thus, &lsquo;<samp class="samp">x+$</samp>&rsquo;
matches a string of one &lsquo;<samp class="samp">x</samp>&rsquo; or more at the end of a line.
</p>
<p>When matching a string instead of a buffer, &lsquo;<samp class="samp">$</samp>&rsquo; matches at the end
of the string or before a newline character.
</p>
<p>For historical compatibility reasons, &lsquo;<samp class="samp">$</samp>&rsquo; can be used only at the
end of the regular expression, or before &lsquo;<samp class="samp">\)</samp>&rsquo; or &lsquo;<samp class="samp">\|</samp>&rsquo;.
</p>
</dd>
<dt><a id="index-_005c-in-regexp"></a><span>&lsquo;<samp class="samp">\</samp>&rsquo;<a class="copiable-link" href="#index-_005c-in-regexp"> &para;</a></span></dt>
<dd><p>has two functions: it quotes the special characters (including
&lsquo;<samp class="samp">\</samp>&rsquo;), and it introduces additional special constructs.
</p>
<p>Because &lsquo;<samp class="samp">\</samp>&rsquo; quotes special characters, &lsquo;<samp class="samp">\$</samp>&rsquo; is a regular
expression that matches only &lsquo;<samp class="samp">$</samp>&rsquo;, and &lsquo;<samp class="samp">\[</samp>&rsquo; is a regular
expression that matches only &lsquo;<samp class="samp">[</samp>&rsquo;, and so on.
</p>
<p>Note that &lsquo;<samp class="samp">\</samp>&rsquo; also has special meaning in the read syntax of Lisp
strings (see <a class="pxref" href="String-Type.html">String Type</a>), and must be quoted with &lsquo;<samp class="samp">\</samp>&rsquo;.  For
example, the regular expression that matches the &lsquo;<samp class="samp">\</samp>&rsquo; character is
&lsquo;<samp class="samp">\\</samp>&rsquo;.  To write a Lisp string that contains the characters
&lsquo;<samp class="samp">\\</samp>&rsquo;, Lisp syntax requires you to quote each &lsquo;<samp class="samp">\</samp>&rsquo; with another
&lsquo;<samp class="samp">\</samp>&rsquo;.  Therefore, the read syntax for a regular expression matching
&lsquo;<samp class="samp">\</samp>&rsquo; is <code class="code">&quot;\\\\&quot;</code>.
</p></dd>
</dl>

<p><strong class="strong">Please note:</strong> For historical compatibility, special characters
are treated as ordinary ones if they are in contexts where their special
meanings make no sense.  For example, &lsquo;<samp class="samp">*foo</samp>&rsquo; treats &lsquo;<samp class="samp">*</samp>&rsquo; as
ordinary since there is no preceding expression on which the &lsquo;<samp class="samp">*</samp>&rsquo;
can act.  It is poor practice to depend on this behavior; quote the
special character anyway, regardless of where it appears.
</p>
<p>As a &lsquo;<samp class="samp">\</samp>&rsquo; is not special inside a character alternative, it can
never remove the special meaning of &lsquo;<samp class="samp">-</samp>&rsquo;, &lsquo;<samp class="samp">^</samp>&rsquo; or &lsquo;<samp class="samp">]</samp>&rsquo;.
You should not quote these characters when they have no special
meaning.  This would not clarify anything, since backslashes
can legitimately precede these characters where they <em class="emph">have</em>
special meaning, as in &lsquo;<samp class="samp">[^\]</samp>&rsquo; (<code class="code">&quot;[^\\]&quot;</code> for Lisp string
syntax), which matches any single character except a backslash.
</p>
<p>In practice, most &lsquo;<samp class="samp">]</samp>&rsquo; that occur in regular expressions close a
character alternative and hence are special.  However, occasionally a
regular expression may try to match a complex pattern of literal
&lsquo;<samp class="samp">[</samp>&rsquo; and &lsquo;<samp class="samp">]</samp>&rsquo;.  In such situations, it sometimes may be
necessary to carefully parse the regexp from the start to determine
which square brackets enclose a character alternative.  For example,
&lsquo;<samp class="samp">[^][]]</samp>&rsquo; consists of the complemented character alternative
&lsquo;<samp class="samp">[^][]</samp>&rsquo; (which matches any single character that is not a square
bracket), followed by a literal &lsquo;<samp class="samp">]</samp>&rsquo;.
</p>
<p>The exact rules are that at the beginning of a regexp, &lsquo;<samp class="samp">[</samp>&rsquo; is
special and &lsquo;<samp class="samp">]</samp>&rsquo; not.  This lasts until the first unquoted
&lsquo;<samp class="samp">[</samp>&rsquo;, after which we are in a character alternative; &lsquo;<samp class="samp">[</samp>&rsquo; is
no longer special (except when it starts a character class) but &lsquo;<samp class="samp">]</samp>&rsquo;
is special, unless it immediately follows the special &lsquo;<samp class="samp">[</samp>&rsquo; or that
&lsquo;<samp class="samp">[</samp>&rsquo; followed by a &lsquo;<samp class="samp">^</samp>&rsquo;.  This lasts until the next special
&lsquo;<samp class="samp">]</samp>&rsquo; that does not end a character class.  This ends the character
alternative and restores the ordinary syntax of regular expressions;
an unquoted &lsquo;<samp class="samp">[</samp>&rsquo; is special again and a &lsquo;<samp class="samp">]</samp>&rsquo; not.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Char-Classes.html">Character Classes</a>, Up: <a href="Syntax-of-Regexps.html">Syntax of Regular Expressions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
