<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.3.

Copyright Â© 1990-1996, 1998-2024 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Language Grammar (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Language Grammar (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Language Grammar (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-Program-Source.html" rel="up" title="Parsing Program Source">
<link href="Using-Parser.html" rel="next" title="Using Parser">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Language-Grammar">
<div class="nav-panel">
<p>
Next: <a href="Using-Parser.html" accesskey="n" rel="next">Using Tree-sitter Parser</a>, Up: <a href="Parsing-Program-Source.html" accesskey="u" rel="up">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Tree_002dsitter-Language-Grammar"><span>37.1 Tree-sitter Language Grammar<a class="copiable-link" href="#Tree_002dsitter-Language-Grammar"> &para;</a></span></h3>
<a class="index-entry-id" id="index-language-grammar_002c-for-tree_002dsitter"></a>

<h3 class="heading" id="Loading-a-language-grammar"><span>Loading a language grammar<a class="copiable-link" href="#Loading-a-language-grammar"> &para;</a></span></h3>
<a class="index-entry-id" id="index-loading-language-grammar-for-tree_002dsitter"></a>

<a class="index-entry-id" id="index-language-argument_002c-for-tree_002dsitter"></a>
<p>Tree-sitter relies on language grammar to parse text in that
language.  In Emacs, a language grammar is represented by a symbol.
For example, the C language grammar is represented as the symbol
<code class="code">c</code>, and <code class="code">c</code> can be passed to tree-sitter functions as the
<var class="var">language</var> argument.
</p>
<a class="index-entry-id" id="index-treesit_002dextra_002dload_002dpath"></a>
<a class="index-entry-id" id="index-treesit_002dload_002dlanguage_002derror"></a>
<p>Tree-sitter language grammars are distributed as dynamic libraries.
In order to use a language grammar in Emacs, you need to make sure
that the dynamic library is installed on the system.  Emacs looks for
language grammars in several places, in the following order:
</p>
<ul class="itemize mark-bullet">
<li>first, in the list of directories specified by the variable
<code class="code">treesit-extra-load-path</code>;
</li><li>then, in the <samp class="file">tree-sitter</samp> subdirectory of the directory
specified by <code class="code">user-emacs-directory</code> (see <a class="pxref" href="Init-File.html">The Init File</a>);
</li><li>and finally, in the system&rsquo;s default locations for dynamic libraries.
</li></ul>

<p>In each of these directories, Emacs looks for a file with file-name
extensions specified by the variable <code class="code">dynamic-library-suffixes</code>.
</p>
<p>If Emacs cannot find the library or has problems loading it, Emacs
signals the <code class="code">treesit-load-language-error</code> error.  The data of
that signal could be one of the following:
</p>
<dl class="table">
<dt><code class="code">(not-found <var class="var">error-msg</var> &hellip;)</code></dt>
<dd><p>This means that Emacs could not find the language grammar library.
</p></dd>
<dt><code class="code">(symbol-error <var class="var">error-msg</var>)</code></dt>
<dd><p>This means that Emacs could not find in the library the expected function
that every language grammar library should export.
</p></dd>
<dt><code class="code">(version-mismatch <var class="var">error-msg</var>)</code></dt>
<dd><p>This means that the version of the language grammar library is
incompatible with that of the tree-sitter library.
</p></dd>
</dl>

<p>In all of these cases, <var class="var">error-msg</var> might provide additional
details about the failure.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dlanguage_002davailable_002dp"><span class="category-def">Function: </span><span><strong class="def-name">treesit-language-available-p</strong> <var class="def-var-arguments">language &amp;optional detail</var><a class="copiable-link" href="#index-treesit_002dlanguage_002davailable_002dp"> &para;</a></span></dt>
<dd><p>This function returns non-<code class="code">nil</code> if the language grammar for
<var class="var">language</var> exists and can be loaded.
</p>
<p>If <var class="var">detail</var> is non-<code class="code">nil</code>, return <code class="code">(t . nil)</code> when
<var class="var">language</var> is available, and <code class="code">(nil . <var class="var">data</var>)</code> when it&rsquo;s
unavailable.  <var class="var">data</var> is the signal data of
<code class="code">treesit-load-language-error</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-treesit_002dload_002dname_002doverride_002dlist"></a>
<p>By convention, the file name of the dynamic library for <var class="var">language</var> is
<samp class="file">libtree-sitter-<var class="var">language</var>.<var class="var">ext</var></samp>, where <var class="var">ext</var> is the
system-specific extension for dynamic libraries.  Also by convention,
the function provided by that library is named
<code class="code">tree_sitter_<var class="var">language</var></code>.  If a language grammar library
doesn&rsquo;t follow this convention, you should add an entry
</p>
<div class="example">
<pre class="example-preformatted">(<var class="var">language</var> <var class="var">library-base-name</var> <var class="var">function-name</var>)
</pre></div>

<p>to the list in the variable <code class="code">treesit-load-name-override-list</code>, where
<var class="var">library-base-name</var> is the basename of the dynamic library&rsquo;s file name
(usually, <samp class="file">libtree-sitter-<var class="var">language</var></samp>), and
<var class="var">function-name</var> is the function provided by the library
(usually, <code class="code">tree_sitter_<var class="var">language</var></code>).  For example,
</p>
<div class="example">
<pre class="example-preformatted">(cool-lang &quot;libtree-sitter-coool&quot; &quot;tree_sitter_cooool&quot;)
</pre></div>

<p>for a language that considers itself too &ldquo;cool&rdquo; to abide by
conventions.
</p>
<a class="index-entry-id" id="index-language-grammar-version_002c-compatibility"></a>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dlibrary_002dabi_002dversion"><span class="category-def">Function: </span><span><strong class="def-name">treesit-library-abi-version</strong> <var class="def-var-arguments">&amp;optional min-compatible</var><a class="copiable-link" href="#index-treesit_002dlibrary_002dabi_002dversion"> &para;</a></span></dt>
<dd><p>This function returns the version of the language grammar
Application Binary Interface (<abbr class="acronym">ABI</abbr>) supported by the
tree-sitter library.  By default, it returns the latest ABI version
supported by the library, but if <var class="var">min-compatible</var> is
non-<code class="code">nil</code>, it returns the oldest ABI version which the library
still can support.  Language grammar libraries must be built for
ABI versions between the oldest and the latest versions supported by
the tree-sitter library, otherwise the library will be unable to load
them.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dlanguage_002dabi_002dversion"><span class="category-def">Function: </span><span><strong class="def-name">treesit-language-abi-version</strong> <var class="def-var-arguments">language</var><a class="copiable-link" href="#index-treesit_002dlanguage_002dabi_002dversion"> &para;</a></span></dt>
<dd><p>This function returns the <abbr class="acronym">ABI</abbr> version of the language
grammar library loaded by Emacs for <var class="var">language</var>.  If <var class="var">language</var>
is unavailable, this function returns <code class="code">nil</code>.
</p></dd></dl>

<h3 class="heading" id="Concrete-syntax-tree"><span>Concrete syntax tree<a class="copiable-link" href="#Concrete-syntax-tree"> &para;</a></span></h3>
<a class="index-entry-id" id="index-syntax-tree_002c-concrete"></a>

<p>A syntax tree is what a parser generates.  In a syntax tree, each node
represents a piece of text, and is connected to each other by a
parent-child relationship.  For example, if the source text is
</p>
<div class="example">
<pre class="example-preformatted">1 + 2
</pre></div>

<p>its syntax tree could be
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">                  +--------------+
                  | root &quot;1 + 2&quot; |
                  +--------------+
                         |
        +--------------------------------+
        |       expression &quot;1 + 2&quot;       |
        +--------------------------------+
           |             |            |
+------------+   +--------------+   +------------+
| number &quot;1&quot; |   | operator &quot;+&quot; |   | number &quot;2&quot; |
+------------+   +--------------+   +------------+
</pre></div></div>

<p>We can also represent it as an s-expression:
</p>
<div class="example">
<pre class="example-preformatted">(root (expression (number) (operator) (number)))
</pre></div>

<h4 class="subheading" id="Node-types"><span>Node types<a class="copiable-link" href="#Node-types"> &para;</a></span></h4>
<a class="index-entry-id" id="index-node-types_002c-in-a-syntax-tree"></a>

<a class="index-entry-id" id="index-type-of-node_002c-tree_002dsitter"></a>
<a class="anchor" id="tree_002dsitter-node-type"></a><a class="index-entry-id" id="index-named-node_002c-tree_002dsitter"></a>
<a class="anchor" id="tree_002dsitter-named-node"></a><a class="index-entry-id" id="index-anonymous-node_002c-tree_002dsitter"></a>
<p>Names like <code class="code">root</code>, <code class="code">expression</code>, <code class="code">number</code>, and
<code class="code">operator</code> specify the <em class="dfn">type</em> of the nodes.  However, not all
nodes in a syntax tree have a type.  Nodes that don&rsquo;t have a type are
known as <em class="dfn">anonymous nodes</em>, and nodes with a type are <em class="dfn">named
nodes</em>.  Anonymous nodes are tokens with fixed spellings, including
punctuation characters like bracket &lsquo;<samp class="samp">]</samp>&rsquo;, and keywords like
<code class="code">return</code>.
</p>
<h4 class="subheading" id="Field-names"><span>Field names<a class="copiable-link" href="#Field-names"> &para;</a></span></h4>

<a class="index-entry-id" id="index-field-name_002c-tree_002dsitter"></a>
<a class="index-entry-id" id="index-tree_002dsitter-node-field-name"></a>
<a class="anchor" id="tree_002dsitter-node-field-name"></a><p>To make the syntax tree easier to analyze, many language grammar
assign <em class="dfn">field names</em> to child nodes.  For example, a
<code class="code">function_definition</code> node could have a <code class="code">declarator</code> and a
<code class="code">body</code>:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(function_definition
 declarator: (declaration)
 body: (compound_statement))
</pre></div></div>

<h3 class="heading" id="Exploring-the-syntax-tree"><span>Exploring the syntax tree<a class="copiable-link" href="#Exploring-the-syntax-tree"> &para;</a></span></h3>
<a class="index-entry-id" id="index-explore-tree_002dsitter-syntax-tree"></a>
<a class="index-entry-id" id="index-inspection-of-tree_002dsitter-parse-tree-nodes"></a>

<p>To aid in understanding the syntax of a language and in debugging Lisp
programs that use the syntax tree, Emacs provides an &ldquo;explore&rdquo; mode,
which displays the syntax tree of the source in the current buffer in
real time.  Emacs also comes with an &ldquo;inspect mode&rdquo;, which displays
information of the nodes at point in the mode-line.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-treesit_002dexplore_002dmode"><span class="category-def">Command: </span><span><strong class="def-name">treesit-explore-mode</strong><a class="copiable-link" href="#index-treesit_002dexplore_002dmode"> &para;</a></span></dt>
<dd><p>This mode pops up a window displaying the syntax tree of the source in
the current buffer.  Selecting text in the source buffer highlights
the corresponding nodes in the syntax tree display.  Clicking
on nodes in the syntax tree highlights the corresponding text in the
source buffer.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-treesit_002dinspect_002dmode"><span class="category-def">Command: </span><span><strong class="def-name">treesit-inspect-mode</strong><a class="copiable-link" href="#index-treesit_002dinspect_002dmode"> &para;</a></span></dt>
<dd><p>This minor mode displays on the mode-line the node that <em class="emph">starts</em>
at point.  For example, the mode-line can display
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">parent</var> <var class="var">field</var>: (<var class="var">node</var> (<var class="var">child</var> (...)))
</pre></div>

<p>where <var class="var">node</var>, <var class="var">child</var>, etc., are nodes which begin at point.
<var class="var">parent</var> is the parent of <var class="var">node</var>.  <var class="var">node</var> is displayed in
a bold typeface.  <var class="var">field-name</var>s are field names of <var class="var">node</var> and
of <var class="var">child</var>, etc.
</p>
<p>If no node starts at point, i.e., point is in the middle of a node,
then the mode line displays the earliest node that spans point, and
its immediate parent.
</p>
<p>This minor mode doesn&rsquo;t create parsers on its own.  It uses the first
parser in <code class="code">(treesit-parser-list)</code> (see <a class="pxref" href="Using-Parser.html">Using Tree-sitter Parser</a>).
</p></dd></dl>

<h3 class="heading" id="Reading-the-grammar-definition"><span>Reading the grammar definition<a class="copiable-link" href="#Reading-the-grammar-definition"> &para;</a></span></h3>
<a class="index-entry-id" id="index-reading-grammar-definition_002c-tree_002dsitter"></a>

<p>Authors of language grammars define the <em class="dfn">grammar</em> of a
programming language, which determines how a parser constructs a
concrete syntax tree out of the program text.  In order to use the
syntax tree effectively, you need to consult the <em class="dfn">grammar file</em>.
</p>
<p>The grammar file is usually <samp class="file">grammar.js</samp> in a language
grammar&rsquo;s project repository.  The link to a language grammar&rsquo;s
home page can be found on
<a class="uref" href="https://tree-sitter.github.io/tree-sitter">tree-sitter&rsquo;s
homepage</a>.
</p>
<p>The grammar definition is written in JavaScript.  For example, the
rule matching a <code class="code">function_definition</code> node may look like
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">function_definition: $ =&gt; seq(
  $.declaration_specifiers,
  field('declarator', $.declaration),
  field('body', $.compound_statement)
)
</pre></div></div>

<p>The rules are represented by functions that take a single argument
<var class="var">$</var>, representing the whole grammar.  The function itself is
constructed by other functions: the <code class="code">seq</code> function puts together
a sequence of children; the <code class="code">field</code> function annotates a child
with a field name.  If we write the above definition in the so-called
<em class="dfn">Backus-Naur Form</em> (<abbr class="acronym">BNF</abbr>) syntax, it would look like
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">function_definition :=
  &lt;declaration_specifiers&gt; &lt;declaration&gt; &lt;compound_statement&gt;
</pre></div></div>

<p>and the node returned by the parser would look like
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(function_definition
  (declaration_specifier)
  declarator: (declaration)
  body: (compound_statement))
</pre></div></div>

<p>Below is a list of functions that one can see in a grammar definition.
Each function takes other rules as arguments and returns a new rule.
</p>
<dl class="table">
<dt><code class="code">seq(<var class="var">rule1</var>, <var class="var">rule2</var>, &hellip;)</code></dt>
<dd><p>matches each rule one after another.
</p></dd>
<dt><code class="code">choice(<var class="var">rule1</var>, <var class="var">rule2</var>, &hellip;)</code></dt>
<dd><p>matches one of the rules in its arguments.
</p></dd>
<dt><code class="code">repeat(<var class="var">rule</var>)</code></dt>
<dd><p>matches <var class="var">rule</var> <em class="emph">zero or more</em> times.
This is like the &lsquo;<samp class="samp">*</samp>&rsquo; operator in regular expressions.
</p></dd>
<dt><code class="code">repeat1(<var class="var">rule</var>)</code></dt>
<dd><p>matches <var class="var">rule</var> <em class="emph">one or more</em> times.
This is like the &lsquo;<samp class="samp">+</samp>&rsquo; operator in regular expressions.
</p></dd>
<dt><code class="code">optional(<var class="var">rule</var>)</code></dt>
<dd><p>matches <var class="var">rule</var> <em class="emph">zero or one</em> times.
This is like the &lsquo;<samp class="samp">?</samp>&rsquo; operator in regular expressions.
</p></dd>
<dt><code class="code">field(<var class="var">name</var>, <var class="var">rule</var>)</code></dt>
<dd><p>assigns field name <var class="var">name</var> to the child node matched by <var class="var">rule</var>.
</p></dd>
<dt><code class="code">alias(<var class="var">rule</var>, <var class="var">alias</var>)</code></dt>
<dd><p>makes nodes matched by <var class="var">rule</var> appear as <var class="var">alias</var> in the syntax
tree generated by the parser.  For example,
</p>
<div class="example">
<pre class="example-preformatted">alias(preprocessor_call_exp, call_expression)
</pre></div>

<p>makes any node matched by <code class="code">preprocessor_call_exp</code> appear as
<code class="code">call_expression</code>.
</p></dd>
</dl>

<p>Below are grammar functions of lesser importance for reading a
language grammar.
</p>
<dl class="table">
<dt><code class="code">token(<var class="var">rule</var>)</code></dt>
<dd><p>marks <var class="var">rule</var> to produce a single leaf node.  That is, instead of
generating a parent node with individual child nodes under it,
everything is combined into a single leaf node.  See <a class="xref" href="Retrieving-Nodes.html">Retrieving Nodes</a>.
</p></dd>
<dt><code class="code">token.immediate(<var class="var">rule</var>)</code></dt>
<dd><p>Normally, grammar rules ignore preceding whitespace; this
changes <var class="var">rule</var> to match only when there is no preceding
whitespace.
</p></dd>
<dt><code class="code">prec(<var class="var">n</var>, <var class="var">rule</var>)</code></dt>
<dd><p>gives <var class="var">rule</var> the level-<var class="var">n</var> precedence.
</p></dd>
<dt><code class="code">prec.left([<var class="var">n</var>,] <var class="var">rule</var>)</code></dt>
<dd><p>marks <var class="var">rule</var> as left-associative, optionally with level <var class="var">n</var>.
</p></dd>
<dt><code class="code">prec.right([<var class="var">n</var>,] <var class="var">rule</var>)</code></dt>
<dd><p>marks <var class="var">rule</var> as right-associative, optionally with level <var class="var">n</var>.
</p></dd>
<dt><code class="code">prec.dynamic(<var class="var">n</var>, <var class="var">rule</var>)</code></dt>
<dd><p>this is like <code class="code">prec</code>, but the precedence is applied at runtime
instead.
</p></dd>
</dl>

<p>The documentation of the tree-sitter project has
<a class="uref" href="https://tree-sitter.github.io/tree-sitter/creating-parsers">more
about writing a grammar</a>.  Read especially &ldquo;The Grammar DSL&rdquo;
section.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Using-Parser.html">Using Tree-sitter Parser</a>, Up: <a href="Parsing-Program-Source.html">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
