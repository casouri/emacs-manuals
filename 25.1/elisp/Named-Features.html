<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 25.1.

Copyright Â© 1990-1996, 1998-2016 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Named Features (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Named Features (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Named Features (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Loading.html" rel="up" title="Loading">
<link href="Where-Defined.html" rel="next" title="Where Defined">
<link href="Repeated-Loading.html" rel="prev" title="Repeated Loading">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Named-Features">
<div class="nav-panel">
<p>
Next: <a href="Where-Defined.html" accesskey="n" rel="next">Which File Defined a Certain Symbol</a>, Previous: <a href="Repeated-Loading.html" accesskey="p" rel="prev">Repeated Loading</a>, Up: <a href="Loading.html" accesskey="u" rel="up">Loading</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Features"><span>15.7 Features<a class="copiable-link" href="#Features"> &para;</a></span></h3>
<a class="index-entry-id" id="index-features"></a>
<a class="index-entry-id" id="index-requiring-features"></a>
<a class="index-entry-id" id="index-providing-features"></a>

<p><code class="code">provide</code> and <code class="code">require</code> are an alternative to
<code class="code">autoload</code> for loading files automatically.  They work in terms of
named <em class="dfn">features</em>.  Autoloading is triggered by calling a specific
function, but a feature is loaded the first time another program asks
for it by name.
</p>
<p>A feature name is a symbol that stands for a collection of functions,
variables, etc.  The file that defines them should <em class="dfn">provide</em> the
feature.  Another program that uses them may ensure they are defined by
<em class="dfn">requiring</em> the feature.  This loads the file of definitions if it
hasn&rsquo;t been loaded already.
</p>
<a class="index-entry-id" id="index-load-error-with-require"></a>
<p>To require the presence of a feature, call <code class="code">require</code> with the
feature name as argument.  <code class="code">require</code> looks in the global variable
<code class="code">features</code> to see whether the desired feature has been provided
already.  If not, it loads the feature from the appropriate file.  This
file should call <code class="code">provide</code> at the top level to add the feature to
<code class="code">features</code>; if it fails to do so, <code class="code">require</code> signals an error.
</p>
<p>For example, in <samp class="file">idlwave.el</samp>, the definition for
<code class="code">idlwave-complete-filename</code> includes the following code:
</p>
<div class="example">
<pre class="example-preformatted">(defun idlwave-complete-filename ()
  &quot;Use the comint stuff to complete a file name.&quot;
   (require 'comint)
   (let* ((comint-file-name-chars &quot;~/A-Za-z0-9+@:_.$#%={}\\-&quot;)
          (comint-completion-addsuffix nil)
          ...)
       (comint-dynamic-complete-filename)))
</pre></div>

<p>The expression <code class="code">(require 'comint)</code> loads the file <samp class="file">comint.el</samp>
if it has not yet been loaded, ensuring that
<code class="code">comint-dynamic-complete-filename</code> is defined.  Features are
normally named after the files that provide them, so that
<code class="code">require</code> need not be given the file name.  (Note that it is
important that the <code class="code">require</code> statement be outside the body of the
<code class="code">let</code>.  Loading a library while its variables are let-bound can
have unintended consequences, namely the variables becoming unbound
after the let exits.)
</p>
<p>The <samp class="file">comint.el</samp> file contains the following top-level expression:
</p>
<div class="example">
<pre class="example-preformatted">(provide 'comint)
</pre></div>

<p>This adds <code class="code">comint</code> to the global <code class="code">features</code> list, so that
<code class="code">(require 'comint)</code> will henceforth know that nothing needs to be
done.
</p>
<a class="index-entry-id" id="index-byte_002dcompiling-require"></a>
<p>When <code class="code">require</code> is used at top level in a file, it takes effect
when you byte-compile that file (see <a class="pxref" href="Byte-Compilation.html">Byte Compilation</a>) as well as
when you load it.  This is in case the required package contains macros
that the byte compiler must know about.  It also avoids byte compiler
warnings for functions and variables defined in the file loaded with
<code class="code">require</code>.
</p>
<p>Although top-level calls to <code class="code">require</code> are evaluated during
byte compilation, <code class="code">provide</code> calls are not.  Therefore, you can
ensure that a file of definitions is loaded before it is byte-compiled
by including a <code class="code">provide</code> followed by a <code class="code">require</code> for the same
feature, as in the following example.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(provide 'my-feature)  ; <span class="r">Ignored by byte compiler,</span>
                       ;   <span class="r">evaluated by <code class="code">load</code>.</span>
(require 'my-feature)  ; <span class="r">Evaluated by byte compiler.</span>
</pre></div></div>

<p>The compiler ignores the <code class="code">provide</code>, then processes the
<code class="code">require</code> by loading the file in question.  Loading the file does
execute the <code class="code">provide</code> call, so the subsequent <code class="code">require</code> call
does nothing when the file is loaded.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-provide"><span class="category-def">Function: </span><span><strong class="def-name">provide</strong> <var class="def-var-arguments">feature &amp;optional subfeatures</var><a class="copiable-link" href="#index-provide"> &para;</a></span></dt>
<dd><p>This function announces that <var class="var">feature</var> is now loaded, or being
loaded, into the current Emacs session.  This means that the facilities
associated with <var class="var">feature</var> are or will be available for other Lisp
programs.
</p>
<p>The direct effect of calling <code class="code">provide</code> is to add <var class="var">feature</var> to
the front of <code class="code">features</code> if it is not already in that list and
call any <code class="code">eval-after-load</code> code waiting for it (see <a class="pxref" href="Hooks-for-Loading.html">Hooks for Loading</a>).  The argument <var class="var">feature</var> must be a symbol.
<code class="code">provide</code> returns <var class="var">feature</var>.
</p>
<p>If provided, <var class="var">subfeatures</var> should be a list of symbols indicating
a set of specific subfeatures provided by this version of
<var class="var">feature</var>.  You can test the presence of a subfeature using
<code class="code">featurep</code>.  The idea of subfeatures is that you use them when a
package (which is one <var class="var">feature</var>) is complex enough to make it
useful to give names to various parts or functionalities of the
package, which might or might not be loaded, or might or might not be
present in a given version.  See <a class="xref" href="Network-Feature-Testing.html">Testing Availability of Network Features</a>, for
an example.
</p>
<div class="example">
<pre class="example-preformatted">features
     &rArr; (bar bish)

(provide 'foo)
     &rArr; foo
features
     &rArr; (foo bar bish)
</pre></div>

<p>When a file is loaded to satisfy an autoload, and it stops due to an
error in the evaluation of its contents, any function definitions or
<code class="code">provide</code> calls that occurred during the load are undone.
See <a class="xref" href="Autoload.html">Autoload</a>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-require"><span class="category-def">Function: </span><span><strong class="def-name">require</strong> <var class="def-var-arguments">feature &amp;optional filename noerror</var><a class="copiable-link" href="#index-require"> &para;</a></span></dt>
<dd><p>This function checks whether <var class="var">feature</var> is present in the current
Emacs session (using <code class="code">(featurep <var class="var">feature</var>)</code>; see below).  The
argument <var class="var">feature</var> must be a symbol.
</p>
<p>If the feature is not present, then <code class="code">require</code> loads <var class="var">filename</var>
with <code class="code">load</code>.  If <var class="var">filename</var> is not supplied, then the name of
the symbol <var class="var">feature</var> is used as the base file name to load.
However, in this case, <code class="code">require</code> insists on finding <var class="var">feature</var>
with an added &lsquo;<samp class="samp">.el</samp>&rsquo; or &lsquo;<samp class="samp">.elc</samp>&rsquo; suffix (possibly extended with
a compression suffix); a file whose name is just <var class="var">feature</var> won&rsquo;t
be used.  (The variable <code class="code">load-suffixes</code> specifies the exact
required Lisp suffixes.)
</p>
<p>If <var class="var">noerror</var> is non-<code class="code">nil</code>, that suppresses errors from actual
loading of the file.  In that case, <code class="code">require</code> returns <code class="code">nil</code>
if loading the file fails.  Normally, <code class="code">require</code> returns
<var class="var">feature</var>.
</p>
<p>If loading the file succeeds but does not provide <var class="var">feature</var>,
<code class="code">require</code> signals an error, &lsquo;<samp class="samp">Required feature <var class="var">feature</var>
was not provided</samp>&rsquo;.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-featurep"><span class="category-def">Function: </span><span><strong class="def-name">featurep</strong> <var class="def-var-arguments">feature &amp;optional subfeature</var><a class="copiable-link" href="#index-featurep"> &para;</a></span></dt>
<dd><p>This function returns <code class="code">t</code> if <var class="var">feature</var> has been provided in
the current Emacs session (i.e., if <var class="var">feature</var> is a member of
<code class="code">features</code>.)  If <var class="var">subfeature</var> is non-<code class="code">nil</code>, then the
function returns <code class="code">t</code> only if that subfeature is provided as well
(i.e., if <var class="var">subfeature</var> is a member of the <code class="code">subfeature</code>
property of the <var class="var">feature</var> symbol.)
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-features-1"><span class="category-def">Variable: </span><span><strong class="def-name">features</strong><a class="copiable-link" href="#index-features-1"> &para;</a></span></dt>
<dd><p>The value of this variable is a list of symbols that are the features
loaded in the current Emacs session.  Each symbol was put in this list
with a call to <code class="code">provide</code>.  The order of the elements in the
<code class="code">features</code> list is not significant.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Where-Defined.html">Which File Defined a Certain Symbol</a>, Previous: <a href="Repeated-Loading.html">Repeated Loading</a>, Up: <a href="Loading.html">Loading</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
