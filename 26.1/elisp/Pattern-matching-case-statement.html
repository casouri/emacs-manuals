<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 26.1.

Copyright Â© 1990-1996, 1998-2018 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Pattern matching case statement (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Pattern matching case statement (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Pattern matching case statement (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Conditionals.html" rel="up" title="Conditionals">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Pattern-matching-case-statement">
<div class="nav-panel">
<p>
Up: <a href="Conditionals.html" accesskey="u" rel="up">Conditionals</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Pattern-matching-case-statement-1"><span>11.2.1 Pattern matching case statement<a class="copiable-link" href="#Pattern-matching-case-statement-1"> &para;</a></span></h4>
<a class="index-entry-id" id="index-pcase"></a>
<a class="index-entry-id" id="index-pattern-matching"></a>

<p>The <code class="code">cond</code> form lets you choose between alternatives using
predicate conditions that compare values of expressions against
specific values known and written in advance.  However, sometimes it
is useful to select alternatives based on more general conditions that
distinguish between broad classes of values.  The <code class="code">pcase</code> macro
allows you to choose between alternatives based on matching the value
of an expression against a series of patterns.  A pattern can be a
literal value (for comparisons to literal values you&rsquo;d use
<code class="code">cond</code>), or it can be a more general description of the expected
structure of the expression&rsquo;s value.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-pcase-1"><span class="category-def">Macro: </span><span><strong class="def-name">pcase</strong> <var class="def-var-arguments">expression &amp;rest clauses</var><a class="copiable-link" href="#index-pcase-1"> &para;</a></span></dt>
<dd><p>Evaluate <var class="var">expression</var> and choose among an arbitrary number of
alternatives based on the value of <var class="var">expression</var>.  The possible
alternatives are specified by <var class="var">clauses</var>, each of which must be a
list of the form <code class="code">(<var class="var">pattern</var> <var class="var">body-forms</var>&hellip;)</code>.
<code class="code">pcase</code> tries to match the value of <var class="var">expression</var> to the
<var class="var">pattern</var> of each clause, in textual order.  If the value matches,
the clause succeeds; <code class="code">pcase</code> then evaluates its <var class="var">body-forms</var>,
and returns the value of the last of <var class="var">body-forms</var>.  Any remaining
<var class="var">clauses</var> are ignored.  If no clauses match, then the <code class="code">pcase</code>
form evaluates to <code class="code">nil</code>.
</p>
<p>The <var class="var">pattern</var> part of a clause can be of one of two types:
<em class="dfn">QPattern</em>, a pattern quoted with a backquote; or a
<em class="dfn">UPattern</em>, which is not quoted.  UPatterns are simpler, so we
describe them first.
</p>
<p>Note: In the description of the patterns below, we use &ldquo;the value
being matched&rdquo; to refer to the value of the <var class="var">expression</var> that is
the first argument of <code class="code">pcase</code>.
</p>
<p>A UPattern can have the following forms:
</p>
<dl class="table">
<dt><code class="code">'<var class="var">val</var></code></dt>
<dd><p>Matches if the value being matched is <code class="code">equal</code> to <var class="var">val</var>.
</p></dd>
<dt><code class="code"><var class="var">atom</var></code></dt>
<dd><p>Matches any <var class="var">atom</var>, which can be a keyword, a number, or a string.
(These are self-quoting, so this kind of UPattern is actually a
shorthand for <code class="code">'<var class="var">atom</var></code>.)  Note that a string or a float
matches any string or float with the same contents/value.
</p></dd>
<dt><code class="code">_</code></dt>
<dd><p>Matches any value.  This is known as <em class="dfn">don&rsquo;t care</em> or <em class="dfn">wildcard</em>.
</p></dd>
<dt><code class="code"><var class="var">symbol</var></code></dt>
<dd><p>Matches any value, and additionally let-binds <var class="var">symbol</var> to the
value it matched, so that you can later refer to it, either in the
<var class="var">body-forms</var> or also later in the pattern.
</p></dd>
<dt><code class="code">(pred <var class="var">predfun</var>)</code></dt>
<dd><p>Matches if the predicate function <var class="var">predfun</var> returns non-<code class="code">nil</code>
when called with the value being matched as its argument.
<var class="var">predfun</var> can be one of the possible forms described below.
</p></dd>
<dt><code class="code">(guard <var class="var">boolean-expression</var>)</code></dt>
<dd><p>Matches if <var class="var">boolean-expression</var> evaluates to non-<code class="code">nil</code>.  This
allows you to include in a UPattern boolean conditions that refer to
symbols bound to values (including the value being matched) by
previous UPatterns.  Typically used inside an <code class="code">and</code> UPattern, see
below.  For example, <code class="code">(and&nbsp;x&nbsp;(guard&nbsp;(&lt;&nbsp;x&nbsp;10)))</code><!-- /@w --> is a pattern
which matches any number smaller than 10 and let-binds the variable
<code class="code">x</code> to that number.
</p></dd>
<dt><code class="code">(let <var class="var">upattern</var> <var class="var">expression</var>)</code></dt>
<dd><p>Matches if the specified <var class="var">expression</var> matches the specified
<var class="var">upattern</var>.  This allows matching a pattern against the value of
an <em class="emph">arbitrary</em> expression, not just the expression that is the
first argument to <code class="code">pcase</code>.  (It is called <code class="code">let</code> because
<var class="var">upattern</var> can bind symbols to values using the <var class="var">symbol</var>
UPattern.  For example:
<code class="code">((or&nbsp;`(key&nbsp;.&nbsp;,val)&nbsp;(let&nbsp;val&nbsp;5))&nbsp;val)</code><!-- /@w -->.)
</p></dd>
<dt><code class="code">(app <var class="var">function</var> <var class="var">upattern</var>)</code></dt>
<dd><p>Matches if <var class="var">function</var> applied to the value being matched returns a
value that matches <var class="var">upattern</var>.  This is like the <code class="code">pred</code>
UPattern, except that it tests the result against <var class="var">upattern</var>,
rather than against a boolean truth value.  The <var class="var">function</var> call can
use one of the forms described below.
</p></dd>
<dt><code class="code">(or <var class="var">upattern1</var> <var class="var">upattern2</var>&hellip;)</code></dt>
<dd><p>Matches if one the argument UPatterns matches.  As soon as the first
matching UPattern is found, the rest are not tested.  For this reason,
if any of the UPatterns let-bind symbols to the matched value, they
should all bind the same symbols.
</p></dd>
<dt><code class="code">(and <var class="var">upattern1</var> <var class="var">upattern2</var>&hellip;)</code></dt>
<dd><p>Matches if all the argument UPatterns match.
</p></dd>
</dl>

<p>The function calls used in the <code class="code">pred</code> and <code class="code">app</code> UPatterns
can have one of the following forms:
</p>
<dl class="table">
<dt>function symbol, like <code class="code">integerp</code></dt>
<dd><p>In this case, the named function is applied to the value being
matched.
</p></dd>
<dt>lambda-function <code class="code">(lambda (<var class="var">arg</var>) <var class="var">body</var>)</code></dt>
<dd><p>In this case, the lambda-function is called with one argument, the
value being matched.
</p></dd>
<dt><code class="code">(<var class="var">func</var> <var class="var">args</var>&hellip;)</code></dt>
<dd><p>This is a function call with <var class="var">n</var> specified arguments; the function
is called with these <var class="var">n</var> arguments and an additional <var class="var">n</var>+1-th
argument that is the value being matched.
</p></dd>
</dl>

<p>Here&rsquo;s an illustrative example of using UPatterns:
</p>
<div class="example">
<pre class="example-preformatted">(pcase (get-return-code x)
  ('success       (message &quot;Done!&quot;))
  ('would-block   (message &quot;Sorry, can't do it now&quot;))
  ('read-only     (message &quot;The shmliblick is read-only&quot;))
  ('access-denied (message &quot;You do not have the needed rights&quot;))
  (code           (message &quot;Unknown return code %S&quot; code)))
</pre></div>

<p>In addition, you can use backquoted patterns that are more powerful.
They allow matching the value of the <var class="var">expression</var> that is the
first argument of <code class="code">pcase</code> against specifications of its
<em class="emph">structure</em>.  For example, you can specify that the value must be
a list of 2 elements whose first element is a specific string and the
second element is any value with a backquoted pattern like
<code class="code">`(&quot;first&quot; ,second-elem)</code>.
</p>
<p>Backquoted patterns have the form <code class="code">`<var class="var">qpattern</var></code> where
<var class="var">qpattern</var> can have the following forms:
</p>
<dl class="table">
<dt><code class="code">(<var class="var">qpattern1</var> . <var class="var">qpattern2</var>)</code></dt>
<dd><p>Matches if the value being matched is a cons cell whose <code class="code">car</code>
matches <var class="var">qpattern1</var> and whose <code class="code">cdr</code> matches <var class="var">qpattern2</var>.
This readily generalizes to backquoted lists as in
<code class="code">(<var class="var">qpattern1</var>&nbsp;<var class="var">qpattern2</var>&nbsp;&hellip;)</code><!-- /@w -->.
</p></dd>
<dt><code class="code">[<var class="var">qpattern1</var> <var class="var">qpattern2</var> &hellip; <var class="var">qpatternm</var>]</code></dt>
<dd><p>Matches if the value being matched is a vector of length <var class="var">m</var> whose
<code class="code">0</code>..<code class="code">(<var class="var">m</var>-1)</code>th elements match <var class="var">qpattern1</var>,
<var class="var">qpattern2</var> &hellip; <var class="var">qpatternm</var>, respectively.
</p></dd>
<dt><code class="code"><var class="var">atom</var></code></dt>
<dd><p>Matches if corresponding element of the value being matched is
<code class="code">equal</code> to the specified <var class="var">atom</var>.
</p></dd>
<dt><code class="code">,<var class="var">upattern</var></code></dt>
<dd><p>Matches if the corresponding element of the value being matched
matches the specified <var class="var">upattern</var>.
</p></dd>
</dl>

<p>Note that uses of QPatterns can be expressed using only UPatterns, as
QPatterns are implemented on top of UPatterns using
<code class="code">pcase-defmacro</code>, described below.  However, using QPatterns will
in many cases lead to a more readable code.
</p>
</dd></dl>

<p>Here is an example of using <code class="code">pcase</code> to implement a simple
interpreter for a little expression language (note that this example
requires lexical binding, see <a class="pxref" href="Lexical-Binding.html">Lexical Binding</a>):
</p>
<div class="example">
<pre class="example-preformatted">(defun evaluate (exp env)
  (pcase exp
    (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))
    (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))
    (`(fn ,arg ,body)   (lambda (val)
                          (evaluate body (cons (cons arg val) env))))
    ((pred numberp)     exp)
    ((pred symbolp)     (cdr (assq exp env)))
    (_                  (error &quot;Unknown expression %S&quot; exp))))
</pre></div>

<p>Here <code class="code">`(add ,x ,y)</code> is a pattern that checks that <code class="code">exp</code> is a
three-element list starting with the literal symbol <code class="code">add</code>, then
extracts the second and third elements and binds them to the variables
<code class="code">x</code> and <code class="code">y</code>.  Then it evaluates <code class="code">x</code> and <code class="code">y</code> and
adds the results.  The <code class="code">call</code> and <code class="code">fn</code> patterns similarly
implement two flavors of function calls.  <code class="code">(pred numberp)</code> is a
pattern that simply checks that <code class="code">exp</code> is a number and if so,
evaluates it.  <code class="code">(pred symbolp)</code> matches symbols, and returns
their association.  Finally, <code class="code">_</code> is the catch-all pattern that
matches anything, so it&rsquo;s suitable for reporting syntax errors.
</p>
<p>Here are some sample programs in this small language, including their
evaluation results:
</p>
<div class="example">
<pre class="example-preformatted">(evaluate '(add 1 2) nil)                 ;=&gt; 3
(evaluate '(add x y) '((x . 1) (y . 2)))  ;=&gt; 3
(evaluate '(call (fn x (add 1 x)) 2) nil) ;=&gt; 3
(evaluate '(sub 1 2) nil)                 ;=&gt; error
</pre></div>

<p>Additional UPatterns can be defined using the <code class="code">pcase-defmacro</code>
macro.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-pcase_002ddefmacro"><span class="category-def">Macro: </span><span><strong class="def-name">pcase-defmacro</strong> <var class="def-var-arguments">name args &amp;rest body</var><a class="copiable-link" href="#index-pcase_002ddefmacro"> &para;</a></span></dt>
<dd><p>Define a new kind of UPattern for <code class="code">pcase</code>.  The new UPattern will
be invoked as <code class="code">(<var class="var">name</var> <var class="var">actual-args</var>)</code>.  The <var class="var">body</var>
should describe how to rewrite the UPattern <var class="var">name</var> into some other
UPattern.  The rewriting will be the result of evaluating <var class="var">body</var>
in an environment where <var class="var">args</var> are bound to <var class="var">actual-args</var>.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Up: <a href="Conditionals.html">Conditionals</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
