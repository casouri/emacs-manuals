<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 26.1.

Copyright Â© 1990-1996, 1998-2018 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Current Buffer (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Current Buffer (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Current Buffer (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Buffers.html" rel="up" title="Buffers">
<link href="Buffer-Names.html" rel="next" title="Buffer Names">
<link href="Buffer-Basics.html" rel="prev" title="Buffer Basics">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Current-Buffer">
<div class="nav-panel">
<p>
Next: <a href="Buffer-Names.html" accesskey="n" rel="next">Buffer Names</a>, Previous: <a href="Buffer-Basics.html" accesskey="p" rel="prev">Buffer Basics</a>, Up: <a href="Buffers.html" accesskey="u" rel="up">Buffers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="The-Current-Buffer"><span>27.2 The Current Buffer<a class="copiable-link" href="#The-Current-Buffer"> &para;</a></span></h3>
<a class="index-entry-id" id="index-selecting-a-buffer"></a>
<a class="index-entry-id" id="index-changing-to-another-buffer"></a>
<a class="index-entry-id" id="index-current-buffer"></a>

<p>There are, in general, many buffers in an Emacs session.  At any
time, one of them is designated the <em class="dfn">current buffer</em>&mdash;the buffer
in which most editing takes place.  Most of the primitives for
examining or changing text operate implicitly on the current buffer
(see <a class="pxref" href="Text.html">Text</a>).
</p>
<p>Normally, the buffer displayed in the selected window is the current
buffer, but this is not always so: a Lisp program can temporarily
designate any buffer as current in order to operate on its contents,
without changing what is displayed on the screen.  The most basic
function for designating a current buffer is <code class="code">set-buffer</code>.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-current_002dbuffer"><span class="category-def">Function: </span><span><strong class="def-name">current-buffer</strong><a class="copiable-link" href="#index-current_002dbuffer"> &para;</a></span></dt>
<dd><p>This function returns the current buffer.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(current-buffer)
     &rArr; #&lt;buffer buffers.texi&gt;
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-set_002dbuffer"><span class="category-def">Function: </span><span><strong class="def-name">set-buffer</strong> <var class="def-var-arguments">buffer-or-name</var><a class="copiable-link" href="#index-set_002dbuffer"> &para;</a></span></dt>
<dd><p>This function makes <var class="var">buffer-or-name</var> the current buffer.
<var class="var">buffer-or-name</var> must be an existing buffer or the name of an
existing buffer.  The return value is the buffer made current.
</p>
<p>This function does not display the buffer in any window, so the user
cannot necessarily see the buffer.  But Lisp programs will now operate
on it.
</p></dd></dl>

<p>When an editing command returns to the editor command loop, Emacs
automatically calls <code class="code">set-buffer</code> on the buffer shown in the
selected window.  This is to prevent confusion: it ensures that the
buffer that the cursor is in, when Emacs reads a command, is the
buffer to which that command applies (see <a class="pxref" href="Command-Loop.html">Command Loop</a>).  Thus,
you should not use <code class="code">set-buffer</code> to switch visibly to a different
buffer; for that, use the functions described in <a class="ref" href="Switching-Buffers.html">Switching to a Buffer in a Window</a>.
</p>
<p>When writing a Lisp function, do <em class="emph">not</em> rely on this behavior of
the command loop to restore the current buffer after an operation.
Editing commands can also be called as Lisp functions by other
programs, not just from the command loop; it is convenient for the
caller if the subroutine does not change which buffer is current
(unless, of course, that is the subroutine&rsquo;s purpose).
</p>
<p>To operate temporarily on another buffer, put the <code class="code">set-buffer</code>
within a <code class="code">save-current-buffer</code> form.  Here, as an example, is a
simplified version of the command <code class="code">append-to-buffer</code>:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(defun append-to-buffer (buffer start end)
  &quot;Append the text of the region to BUFFER.&quot;
  (interactive &quot;BAppend to buffer: \nr&quot;)
  (let ((oldbuf (current-buffer)))
    (save-current-buffer
      (set-buffer (get-buffer-create buffer))
      (insert-buffer-substring oldbuf start end))))
</pre></div></div>

<p>Here, we bind a local variable to record the current buffer, and then
<code class="code">save-current-buffer</code> arranges to make it current again later.
Next, <code class="code">set-buffer</code> makes the specified buffer current, and
<code class="code">insert-buffer-substring</code> copies the string from the original
buffer to the specified (and now current) buffer.
</p>
<p>Alternatively, we can use the <code class="code">with-current-buffer</code> macro:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(defun append-to-buffer (buffer start end)
  &quot;Append the text of the region to BUFFER.&quot;
  (interactive &quot;BAppend to buffer: \nr&quot;)
  (let ((oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (insert-buffer-substring oldbuf start end))))
</pre></div></div>

<p>In either case, if the buffer appended to happens to be displayed in
some window, the next redisplay will show how its text has changed.
If it is not displayed in any window, you will not see the change
immediately on the screen.  The command causes the buffer to become
current temporarily, but does not cause it to be displayed.
</p>
<p>If you make local bindings (with <code class="code">let</code> or function arguments)
for a variable that may also have buffer-local bindings, make sure
that the same buffer is current at the beginning and at the end of the
local binding&rsquo;s scope.  Otherwise you might bind it in one buffer and
unbind it in another!
</p>
<p>Do not rely on using <code class="code">set-buffer</code> to change the current buffer
back, because that won&rsquo;t do the job if a quit happens while the wrong
buffer is current.  For instance, in the previous example, it would
have been wrong to do this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">  (let ((oldbuf (current-buffer)))
    (set-buffer (get-buffer-create buffer))
    (insert-buffer-substring oldbuf start end)
    (set-buffer oldbuf))
</pre></div></div>

<p>Using <code class="code">save-current-buffer</code> or <code class="code">with-current-buffer</code>, as we
did, correctly handles quitting, errors, and <code class="code">throw</code>, as well as
ordinary evaluation.
</p>
<dl class="first-deffn first-defspec-alias-first-deffn">
<dt class="deffn defspec-alias-deffn" id="index-save_002dcurrent_002dbuffer"><span class="category-def">Special Form: </span><span><strong class="def-name">save-current-buffer</strong> <var class="def-var-arguments">body&hellip;</var><a class="copiable-link" href="#index-save_002dcurrent_002dbuffer"> &para;</a></span></dt>
<dd><p>The <code class="code">save-current-buffer</code> special form saves the identity of the
current buffer, evaluates the <var class="var">body</var> forms, and finally restores
that buffer as current.  The return value is the value of the last
form in <var class="var">body</var>.  The current buffer is restored even in case of an
abnormal exit via <code class="code">throw</code> or error (see <a class="pxref" href="Nonlocal-Exits.html">Nonlocal Exits</a>).
</p>
<p>If the buffer that used to be current has been killed by the time of
exit from <code class="code">save-current-buffer</code>, then it is not made current again,
of course.  Instead, whichever buffer was current just before exit
remains current.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-with_002dcurrent_002dbuffer"><span class="category-def">Macro: </span><span><strong class="def-name">with-current-buffer</strong> <var class="def-var-arguments">buffer-or-name body&hellip;</var><a class="copiable-link" href="#index-with_002dcurrent_002dbuffer"> &para;</a></span></dt>
<dd><p>The <code class="code">with-current-buffer</code> macro saves the identity of the current
buffer, makes <var class="var">buffer-or-name</var> current, evaluates the <var class="var">body</var>
forms, and finally restores the current buffer.  <var class="var">buffer-or-name</var>
must specify an existing buffer or the name of an existing buffer.
</p>
<p>The return value is the value of the last form in <var class="var">body</var>.  The
current buffer is restored even in case of an abnormal exit via
<code class="code">throw</code> or error (see <a class="pxref" href="Nonlocal-Exits.html">Nonlocal Exits</a>).
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-with_002dtemp_002dbuffer"><span class="category-def">Macro: </span><span><strong class="def-name">with-temp-buffer</strong> <var class="def-var-arguments">body&hellip;</var><a class="copiable-link" href="#index-with_002dtemp_002dbuffer"> &para;</a></span></dt>
<dd><a class="anchor" id="Definition-of-with_002dtemp_002dbuffer"></a><p>The <code class="code">with-temp-buffer</code> macro evaluates the <var class="var">body</var> forms
with a temporary buffer as the current buffer.  It saves the identity of
the current buffer, creates a temporary buffer and makes it current,
evaluates the <var class="var">body</var> forms, and finally restores the previous
current buffer while killing the temporary buffer.  By default, undo
information (see <a class="pxref" href="Undo.html">Undo</a>) is not recorded in the buffer created by
this macro (but <var class="var">body</var> can enable that, if needed).
</p>
<p>The return value is the value of the last form in <var class="var">body</var>.  You can
return the contents of the temporary buffer by using
<code class="code">(buffer-string)</code> as the last form.
</p>
<p>The current buffer is restored even in case of an abnormal exit via
<code class="code">throw</code> or error (see <a class="pxref" href="Nonlocal-Exits.html">Nonlocal Exits</a>).
</p>
<p>See also <code class="code">with-temp-file</code> in <a class="ref" href="Writing-to-Files.html#Definition-of-with_002dtemp_002dfile">Writing to Files</a>.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Buffer-Names.html">Buffer Names</a>, Previous: <a href="Buffer-Basics.html">Buffer Basics</a>, Up: <a href="Buffers.html">Buffers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
