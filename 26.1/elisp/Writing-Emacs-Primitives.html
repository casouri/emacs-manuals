<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 26.1.

Copyright Â© 1990-1996, 1998-2018 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Writing Emacs Primitives (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Writing Emacs Primitives (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Writing Emacs Primitives (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="GNU-Emacs-Internals.html" rel="up" title="GNU Emacs Internals">
<link href="Object-Internals.html" rel="next" title="Object Internals">
<link href="C-Dialect.html" rel="prev" title="C Dialect">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Writing-Emacs-Primitives">
<div class="nav-panel">
<p>
Next: <a href="Object-Internals.html" accesskey="n" rel="next">Object Internals</a>, Previous: <a href="C-Dialect.html" accesskey="p" rel="prev">C Dialect</a>, Up: <a href="GNU-Emacs-Internals.html" accesskey="u" rel="up">GNU Emacs Internals</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Writing-Emacs-Primitives-1"><span>E.7 Writing Emacs Primitives<a class="copiable-link" href="#Writing-Emacs-Primitives-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-primitive-function-internals"></a>
<a class="index-entry-id" id="index-writing-Emacs-primitives"></a>

<p>Lisp primitives are Lisp functions implemented in C.  The details of
interfacing the C function so that Lisp can call it are handled by a few
C macros.  The only way to really understand how to write new C code is
to read the source, but we can explain some things here.
</p>
<p>An example of a special form is the definition of <code class="code">or</code>, from
<samp class="file">eval.c</samp>.  (An ordinary function would have the same general
appearance.)
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">DEFUN (&quot;or&quot;, For, Sor, 0, UNEVALLED, 0,
  doc: /* Eval args until one of them yields non-nil, then return
that value.
The remaining args are not evalled at all.
If all args return nil, return nil.
</pre></div><div class="group"><pre class="example-preformatted">usage: (or CONDITIONS...)  */)
  (Lisp_Object args)
{
  Lisp_Object val = Qnil;
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">  while (CONSP (args))
    {
      val = eval_sub (XCAR (args));
      if (!NILP (val))
        break;
      args = XCDR (args);
      maybe_quit ();
    }
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">  return val;
}
</pre></div></div>

<a class="index-entry-id" id="index-DEFUN_002c-C-macro-to-define-Lisp-primitives"></a>
<p>Let&rsquo;s start with a precise explanation of the arguments to the
<code class="code">DEFUN</code> macro.  Here is a template for them:
</p>
<div class="example">
<pre class="example-preformatted">DEFUN (<var class="var">lname</var>, <var class="var">fname</var>, <var class="var">sname</var>, <var class="var">min</var>, <var class="var">max</var>, <var class="var">interactive</var>, <var class="var">doc</var>)
</pre></div>

<dl class="table">
<dt><var class="var">lname</var></dt>
<dd><p>This is the name of the Lisp symbol to define as the function name; in
the example above, it is <code class="code">or</code>.
</p>
</dd>
<dt><var class="var">fname</var></dt>
<dd><p>This is the C function name for this function.  This is the name that
is used in C code for calling the function.  The name is, by
convention, &lsquo;<samp class="samp">F</samp>&rsquo; prepended to the Lisp name, with all dashes
(&lsquo;<samp class="samp">-</samp>&rsquo;) in the Lisp name changed to underscores.  Thus, to call
this function from C code, call <code class="code">For</code>.
</p>
</dd>
<dt><var class="var">sname</var></dt>
<dd><p>This is a C variable name to use for a structure that holds the data for
the subr object that represents the function in Lisp.  This structure
conveys the Lisp symbol name to the initialization routine that will
create the symbol and store the subr object as its definition.  By
convention, this name is always <var class="var">fname</var> with &lsquo;<samp class="samp">F</samp>&rsquo; replaced with
&lsquo;<samp class="samp">S</samp>&rsquo;.
</p>
</dd>
<dt><var class="var">min</var></dt>
<dd><p>This is the minimum number of arguments that the function requires.  The
function <code class="code">or</code> allows a minimum of zero arguments.
</p>
</dd>
<dt><var class="var">max</var></dt>
<dd><p>This is the maximum number of arguments that the function accepts, if
there is a fixed maximum.  Alternatively, it can be <code class="code">UNEVALLED</code>,
indicating a special form that receives unevaluated arguments, or
<code class="code">MANY</code>, indicating an unlimited number of evaluated arguments (the
equivalent of <code class="code">&amp;rest</code>).  Both <code class="code">UNEVALLED</code> and <code class="code">MANY</code> are
macros.  If <var class="var">max</var> is a number, it must be more than <var class="var">min</var> but
less than 8.
</p>
</dd>
<dt><a id="index-interactive-specification-in-primitives"></a><span><var class="var">interactive</var><a class="copiable-link" href="#index-interactive-specification-in-primitives"> &para;</a></span></dt>
<dd><p>This is an interactive specification, a string such as might be used
as the argument of <code class="code">interactive</code> in a Lisp function.  In the case
of <code class="code">or</code>, it is 0 (a null pointer), indicating that <code class="code">or</code>
cannot be called interactively.  A value of <code class="code">&quot;&quot;</code> indicates a
function that should receive no arguments when called interactively.
If the value begins with a &lsquo;<samp class="samp">&quot;(</samp>&rsquo;, the string is evaluated as a
Lisp form.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">DEFUN (&quot;foo&quot;, Ffoo, Sfoo, 0, UNEVALLED, 0
       &quot;(list (read-char-by-name \&quot;Insert character: \&quot;)\
              (prefix-numeric-value current-prefix-arg)\
              t))&quot;,
  doc: /* ... */)
</pre></div></div>

</dd>
<dt><var class="var">doc</var></dt>
<dd><p>This is the documentation string.  It uses C comment syntax rather
than C string syntax because comment syntax requires nothing special
to include multiple lines.  The &lsquo;<samp class="samp">doc:</samp>&rsquo; identifies the comment
that follows as the documentation string.  The &lsquo;<samp class="samp">/*</samp>&rsquo; and &lsquo;<samp class="samp">*/</samp>&rsquo;
delimiters that begin and end the comment are not part of the
documentation string.
</p>
<p>If the last line of the documentation string begins with the keyword
&lsquo;<samp class="samp">usage:</samp>&rsquo;, the rest of the line is treated as the argument list
for documentation purposes.  This way, you can use different argument
names in the documentation string from the ones used in the C code.
&lsquo;<samp class="samp">usage:</samp>&rsquo; is required if the function has an unlimited number of
arguments.
</p>
<p>All the usual rules for documentation strings in Lisp code
(see <a class="pxref" href="Documentation-Tips.html">Tips for Documentation Strings</a>) apply to C code documentation strings
too.
</p>
<p>The documentation string can be followed by a list of C function
attributes for the C function that implements the primitive, like
this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">DEFUN (&quot;bar&quot;, Fbar, Sbar, 0, UNEVALLED, 0
  doc: /* ... */
  attributes: <var class="var">attr1</var> <var class="var">attr2</var> ...)
</pre></div></div>

<p>You can specify more than a single attribute, one after the other.
Currently, only the following attributes are recognized:
</p>
<dl class="table">
<dt><code class="code">noreturn</code></dt>
<dd><p>Declares the C function as one that never returns.  This corresponds
to the C11 keyword <code class="code">_Noreturn</code> and to <code class="code">__attribute__&nbsp;((__noreturn__))</code><!-- /@w --> attribute of GCC (see <a data-manual="gcc" href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">Function Attributes</a> in <cite class="cite">Using the GNU Compiler Collection</cite>).
</p>
</dd>
<dt><code class="code">const</code></dt>
<dd><p>Declares that the function does not examine any values except its
arguments, and has no effects except the return value.  This
corresponds to <code class="code">__attribute__&nbsp;((__const__))</code><!-- /@w --> attribute of
GCC.
</p>
</dd>
<dt><code class="code">noinline</code></dt>
<dd><p>This corresponds to <code class="code">__attribute__&nbsp;((__noinline__))</code><!-- /@w -->
attribute of GCC, which prevents the function from being considered
for inlining.  This might be needed, e.g., to countermand effects of
link-time optimizations on stack-based variables.
</p></dd>
</dl>

</dd>
</dl>

<p>After the call to the <code class="code">DEFUN</code> macro, you must write the
argument list for the C function, including the types for the
arguments.  If the primitive accepts a fixed maximum number of Lisp
arguments, there must be one C argument for each Lisp argument, and
each argument must be of type <code class="code">Lisp_Object</code>.  (Various macros and
functions for creating values of type <code class="code">Lisp_Object</code> are declared
in the file <samp class="file">lisp.h</samp>.)  If the primitive has no upper limit on
the number of Lisp arguments, it must have exactly two C arguments:
the first is the number of Lisp arguments, and the second is the
address of a block containing their values.  These have types
<code class="code">int</code> and <code class="code">Lisp_Object&nbsp;*</code><!-- /@w --> respectively.  Since
<code class="code">Lisp_Object</code> can hold any Lisp object of any data type, you
can determine the actual data type only at run time; so if you want
a primitive to accept only a certain type of argument, you must check
the type explicitly using a suitable predicate (see <a class="pxref" href="Type-Predicates.html">Type Predicates</a>).
<a class="index-entry-id" id="index-type-checking-internals"></a>
</p>
<a class="index-entry-id" id="index-garbage-collection-protection"></a>
<a class="index-entry-id" id="index-protect-C-variables-from-garbage-collection"></a>
<p>Within the function <code class="code">For</code> itself, the local variable
<code class="code">args</code> refers to objects controlled by Emacs&rsquo;s stack-marking
garbage collector.  Although the garbage collector does not reclaim
objects reachable from C <code class="code">Lisp_Object</code> stack variables, it may
move non-object components of an object, such as string contents; so
functions that access non-object components must take care to refetch
their addresses after performing Lisp evaluation.  Lisp evaluation can
occur via calls to <code class="code">eval_sub</code> or <code class="code">Feval</code>, either directly or
indirectly.
</p>
<a class="index-entry-id" id="index-maybe_005fquit_002c-use-in-Lisp-primitives"></a>
<p>Note the call to <code class="code">maybe_quit</code> inside the loop: this function
checks whether the user pressed <kbd class="kbd">C-g</kbd>, and if so, aborts the
processing.  You should do that in any loop that can potentially
require a large number of iterations; in this case, the list of
arguments could be very long.  This increases Emacs responsiveness and
improves user experience.
</p>
<p>You must not use C initializers for static or global variables unless
the variables are never written once Emacs is dumped.  These variables
with initializers are allocated in an area of memory that becomes
read-only (on certain operating systems) as a result of dumping Emacs.
See <a class="xref" href="Pure-Storage.html">Pure Storage</a>.
</p>
<a class="index-entry-id" id="index-defsubr_002c-Lisp-symbol-for-a-primitive"></a>
<p>Defining the C function is not enough to make a Lisp primitive
available; you must also create the Lisp symbol for the primitive and
store a suitable subr object in its function cell.  The code looks like
this:
</p>
<div class="example">
<pre class="example-preformatted">defsubr (&amp;<var class="var">sname</var>);
</pre></div>

<p>Here <var class="var">sname</var> is the name you used as the third argument to <code class="code">DEFUN</code>.
</p>
<p>If you add a new primitive to a file that already has Lisp primitives
defined in it, find the function (near the end of the file) named
<code class="code">syms_of_<var class="var">something</var></code>, and add the call to <code class="code">defsubr</code>
there.  If the file doesn&rsquo;t have this function, or if you create a new
file, add to it a <code class="code">syms_of_<var class="var">filename</var></code> (e.g.,
<code class="code">syms_of_myfile</code>).  Then find the spot in <samp class="file">emacs.c</samp> where all
of these functions are called, and add a call to
<code class="code">syms_of_<var class="var">filename</var></code> there.
</p>
<a class="anchor" id="Defining-Lisp-variables-in-C"></a><a class="index-entry-id" id="index-byte_002dboolean_002dvars-1"></a>
<a class="index-entry-id" id="index-defining-Lisp-variables-in-C"></a>
<a class="index-entry-id" id="index-DEFVAR_005fINT_002c-DEFVAR_005fLISP_002c-DEFVAR_005fBOOL"></a>
<p>The function <code class="code">syms_of_<var class="var">filename</var></code> is also the place to define
any C variables that are to be visible as Lisp variables.
<code class="code">DEFVAR_LISP</code> makes a C variable of type <code class="code">Lisp_Object</code> visible
in Lisp.  <code class="code">DEFVAR_INT</code> makes a C variable of type <code class="code">int</code>
visible in Lisp with a value that is always an integer.
<code class="code">DEFVAR_BOOL</code> makes a C variable of type <code class="code">int</code> visible in Lisp
with a value that is either <code class="code">t</code> or <code class="code">nil</code>.  Note that variables
defined with <code class="code">DEFVAR_BOOL</code> are automatically added to the list
<code class="code">byte-boolean-vars</code> used by the byte compiler.
</p>
<a class="index-entry-id" id="index-defining-customization-variables-in-C"></a>
<p>If you want to make a Lisp variable that is defined in C behave
like one declared with <code class="code">defcustom</code>, add an appropriate entry to
<samp class="file">cus-start.el</samp>.
</p>
<a class="index-entry-id" id="index-staticpro_002c-protection-from-GC"></a>
<p>If you define a file-scope C variable of type <code class="code">Lisp_Object</code>,
you must protect it from garbage-collection by calling <code class="code">staticpro</code>
in <code class="code">syms_of_<var class="var">filename</var></code>, like this:
</p>
<div class="example">
<pre class="example-preformatted">staticpro (&amp;<var class="var">variable</var>);
</pre></div>

<p>Here is another example function, with more complicated arguments.
This comes from the code in <samp class="file">window.c</samp>, and it demonstrates the use
of macros and functions to manipulate Lisp objects.
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">DEFUN (&quot;coordinates-in-window-p&quot;, Fcoordinates_in_window_p,
  Scoordinates_in_window_p, 2, 2, 0,
  doc: /* Return non-nil if COORDINATES are in WINDOW.
  ...
</pre></div><div class="group"><pre class="example-preformatted">  or `right-margin' is returned.  */)
  (register Lisp_Object coordinates, Lisp_Object window)
{
  struct window *w;
  struct frame *f;
  int x, y;
  Lisp_Object lx, ly;
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">  CHECK_LIVE_WINDOW (window);
  w = XWINDOW (window);
  f = XFRAME (w-&gt;frame);
  CHECK_CONS (coordinates);
  lx = Fcar (coordinates);
  ly = Fcdr (coordinates);
  CHECK_NUMBER_OR_FLOAT (lx);
  CHECK_NUMBER_OR_FLOAT (ly);
  x = FRAME_PIXEL_X_FROM_CANON_X (f, lx) + FRAME_INTERNAL_BORDER_WIDTH(f);
  y = FRAME_PIXEL_Y_FROM_CANON_Y (f, ly) + FRAME_INTERNAL_BORDER_WIDTH(f);
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">  switch (coordinates_in_window (w, x, y))
    {
    case ON_NOTHING:            /* NOT in window at all.  */
      return Qnil;
</pre></div><pre class="example-preformatted">

    ...

</pre><div class="group"><pre class="example-preformatted">    case ON_MODE_LINE:          /* In mode line of window.  */
      return Qmode_line;
</pre></div><pre class="example-preformatted">

    ...

</pre><div class="group"><pre class="example-preformatted">    case ON_SCROLL_BAR:         /* On scroll-bar of window.  */
      /* Historically we are supposed to return nil in this case.  */
      return Qnil;
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">    default:
      abort ();
    }
}
</pre></div></div>

<p>Note that C code cannot call functions by name unless they are defined
in C.  The way to call a function written in Lisp is to use
<code class="code">Ffuncall</code>, which embodies the Lisp function <code class="code">funcall</code>.  Since
the Lisp function <code class="code">funcall</code> accepts an unlimited number of
arguments, in C it takes two: the number of Lisp-level arguments, and a
one-dimensional array containing their values.  The first Lisp-level
argument is the Lisp function to call, and the rest are the arguments to
pass to it.
</p>
<p>The C functions <code class="code">call0</code>, <code class="code">call1</code>, <code class="code">call2</code>, and so on,
provide handy ways to call a Lisp function conveniently with a fixed
number of arguments.  They work by calling <code class="code">Ffuncall</code>.
</p>
<p><samp class="file">eval.c</samp> is a very good file to look through for examples;
<samp class="file">lisp.h</samp> contains the definitions for some important macros and
functions.
</p>
<p>If you define a function which is side-effect free, update the code
in <samp class="file">byte-opt.el</samp> that binds <code class="code">side-effect-free-fns</code> and
<code class="code">side-effect-and-error-free-fns</code> so that the compiler optimizer
knows about it.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Object-Internals.html">Object Internals</a>, Previous: <a href="C-Dialect.html">C Dialect</a>, Up: <a href="GNU-Emacs-Internals.html">GNU Emacs Internals</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
