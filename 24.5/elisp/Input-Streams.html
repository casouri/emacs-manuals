<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 24.5.

Copyright Â© 1990-1996, 1998-2015 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Input Streams (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Input Streams (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Input Streams (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Read-and-Print.html" rel="up" title="Read and Print">
<link href="Input-Functions.html" rel="next" title="Input Functions">
<link href="Streams-Intro.html" rel="prev" title="Streams Intro">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
kbd.key {font-style: normal}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Input-Streams">
<div class="nav-panel">
<p>
Next: <a href="Input-Functions.html" accesskey="n" rel="next">Input Functions</a>, Previous: <a href="Streams-Intro.html" accesskey="p" rel="prev">Introduction to Reading and Printing</a>, Up: <a href="Read-and-Print.html" accesskey="u" rel="up">Reading and Printing Lisp Objects</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Input-Streams-1"><span>18.2 Input Streams<a class="copiable-link" href="#Input-Streams-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-stream-_0028for-reading_0029"></a>
<a class="index-entry-id" id="index-input-stream"></a>

<p>Most of the Lisp functions for reading text take an <em class="dfn">input stream</em>
as an argument.  The input stream specifies where or how to get the
characters of the text to be read.  Here are the possible types of input
stream:
</p>
<dl class="table">
<dt><a id="index-buffer-input-stream"></a><span><var class="var">buffer</var><a class="copiable-link" href="#index-buffer-input-stream"> &para;</a></span></dt>
<dd><p>The input characters are read from <var class="var">buffer</var>, starting with the
character directly after point.  Point advances as characters are read.
</p>
</dd>
<dt><a id="index-marker-input-stream"></a><span><var class="var">marker</var><a class="copiable-link" href="#index-marker-input-stream"> &para;</a></span></dt>
<dd><p>The input characters are read from the buffer that <var class="var">marker</var> is in,
starting with the character directly after the marker.  The marker
position advances as characters are read.  The value of point in the
buffer has no effect when the stream is a marker.
</p>
</dd>
<dt><a id="index-string-input-stream"></a><span><var class="var">string</var><a class="copiable-link" href="#index-string-input-stream"> &para;</a></span></dt>
<dd><p>The input characters are taken from <var class="var">string</var>, starting at the first
character in the string and using as many characters as required.
</p>
</dd>
<dt><a id="index-function-input-stream"></a><span><var class="var">function</var><a class="copiable-link" href="#index-function-input-stream"> &para;</a></span></dt>
<dd><p>The input characters are generated by <var class="var">function</var>, which must support
two kinds of calls:
</p>
<ul class="itemize mark-bullet">
<li>When it is called with no arguments, it should return the next character.

</li><li>When it is called with one argument (always a character), <var class="var">function</var>
should save the argument and arrange to return it on the next call.
This is called <em class="dfn">unreading</em> the character; it happens when the Lisp
reader reads one character too many and wants to &ldquo;put it back where it
came from&rdquo;.  In this case, it makes no difference what value
<var class="var">function</var> returns.
</li></ul>

</dd>
<dt><a id="index-t-input-stream"></a><span><code class="code">t</code><a class="copiable-link" href="#index-t-input-stream"> &para;</a></span></dt>
<dd><p><code class="code">t</code> used as a stream means that the input is read from the
minibuffer.  In fact, the minibuffer is invoked once and the text
given by the user is made into a string that is then used as the
input stream.  If Emacs is running in batch mode, standard input is used
instead of the minibuffer.  For example,
</p><div class="example">
<pre class="example-preformatted">(message &quot;%s&quot; (read t))
</pre></div>
<p>will read a Lisp expression from standard input and print the result
to standard output.
</p>
</dd>
<dt><a id="index-nil-input-stream"></a><span><code class="code">nil</code><a class="copiable-link" href="#index-nil-input-stream"> &para;</a></span></dt>
<dd><p><code class="code">nil</code> supplied as an input stream means to use the value of
<code class="code">standard-input</code> instead; that value is the <em class="dfn">default input
stream</em>, and must be a non-<code class="code">nil</code> input stream.
</p>
</dd>
<dt><var class="var">symbol</var></dt>
<dd><p>A symbol as input stream is equivalent to the symbol&rsquo;s function
definition (if any).
</p></dd>
</dl>

<p>Here is an example of reading from a stream that is a buffer, showing
where point is located before and after:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">---------- Buffer: foo ----------
This&lowast; is the contents of foo.
---------- Buffer: foo ----------
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(read (get-buffer &quot;foo&quot;))
     &rArr; is
</pre></div><div class="group"><pre class="example-preformatted">(read (get-buffer &quot;foo&quot;))
     &rArr; the
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">---------- Buffer: foo ----------
This is the&lowast; contents of foo.
---------- Buffer: foo ----------
</pre></div></div>

<p>Note that the first read skips a space.  Reading skips any amount of
whitespace preceding the significant text.
</p>
<p>Here is an example of reading from a stream that is a marker,
initially positioned at the beginning of the buffer shown.  The value
read is the symbol <code class="code">This</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">

---------- Buffer: foo ----------
This is the contents of foo.
---------- Buffer: foo ----------
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(setq m (set-marker (make-marker) 1 (get-buffer &quot;foo&quot;)))
     &rArr; #&lt;marker at 1 in foo&gt;
</pre></div><div class="group"><pre class="example-preformatted">(read m)
     &rArr; This
</pre></div><div class="group"><pre class="example-preformatted">m
     &rArr; #&lt;marker at 5 in foo&gt;   ;; <span class="r">Before the first space.</span>
</pre></div></div>

<p>Here we read from the contents of a string:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(read &quot;(When in) the course&quot;)
     &rArr; (When in)
</pre></div></div>

<p>The following example reads from the minibuffer.  The
prompt is: &lsquo;<samp class="samp">Lisp&nbsp;expression:&nbsp;</samp>&rsquo;<!-- /@w -->.  (That is always the prompt
used when you read from the stream <code class="code">t</code>.)  The user&rsquo;s input is shown
following the prompt.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(read t)
     &rArr; 23
---------- Buffer: Minibuffer ----------
Lisp expression: <kbd class="kbd">23 <kbd class="key">RET</kbd></kbd>
---------- Buffer: Minibuffer ----------
</pre></div></div>

<p>Finally, here is an example of a stream that is a function, named
<code class="code">useless-stream</code>.  Before we use the stream, we initialize the
variable <code class="code">useless-list</code> to a list of characters.  Then each call to
the function <code class="code">useless-stream</code> obtains the next character in the list
or unreads a character by adding it to the front of the list.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq useless-list (append &quot;XY()&quot; nil))
     &rArr; (88 89 40 41)
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(defun useless-stream (&amp;optional unread)
  (if unread
      (setq useless-list (cons unread useless-list))
    (prog1 (car useless-list)
           (setq useless-list (cdr useless-list)))))
     &rArr; useless-stream
</pre></div></div>

<p>Now we read using the stream thus constructed:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(read 'useless-stream)
     &rArr; XY
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">useless-list
     &rArr; (40 41)
</pre></div></div>

<p>Note that the open and close parentheses remain in the list.  The Lisp
reader encountered the open parenthesis, decided that it ended the
input, and unread it.  Another attempt to read from the stream at this
point would read &lsquo;<samp class="samp">()</samp>&rsquo; and return <code class="code">nil</code>.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Input-Functions.html">Input Functions</a>, Previous: <a href="Streams-Intro.html">Introduction to Reading and Printing</a>, Up: <a href="Read-and-Print.html">Reading and Printing Lisp Objects</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
