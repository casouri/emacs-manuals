<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 24.5.

Copyright Â© 1990-1996, 1998-2015 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Bitwise Operations (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Bitwise Operations (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Bitwise Operations (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Numbers.html" rel="up" title="Numbers">
<link href="Math-Functions.html" rel="next" title="Math Functions">
<link href="Rounding-Operations.html" rel="prev" title="Rounding Operations">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Bitwise-Operations">
<div class="nav-panel">
<p>
Next: <a href="Math-Functions.html" accesskey="n" rel="next">Standard Mathematical Functions</a>, Previous: <a href="Rounding-Operations.html" accesskey="p" rel="prev">Rounding Operations</a>, Up: <a href="Numbers.html" accesskey="u" rel="up">Numbers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Bitwise-Operations-on-Integers"><span>3.8 Bitwise Operations on Integers<a class="copiable-link" href="#Bitwise-Operations-on-Integers"> &para;</a></span></h3>
<a class="index-entry-id" id="index-bitwise-arithmetic"></a>
<a class="index-entry-id" id="index-logical-arithmetic"></a>

<p>In a computer, an integer is represented as a binary number, a
sequence of <em class="dfn">bits</em> (digits which are either zero or one).  A bitwise
operation acts on the individual bits of such a sequence.  For example,
<em class="dfn">shifting</em> moves the whole sequence left or right one or more places,
reproducing the same pattern &ldquo;moved over&rdquo;.
</p>
<p>The bitwise operations in Emacs Lisp apply only to integers.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-lsh"><span class="category-def">Function: </span><span><strong class="def-name">lsh</strong> <var class="def-var-arguments">integer1 count</var><a class="copiable-link" href="#index-lsh"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-logical-shift"></a>
<p><code class="code">lsh</code>, which is an abbreviation for <em class="dfn">logical shift</em>, shifts the
bits in <var class="var">integer1</var> to the left <var class="var">count</var> places, or to the right
if <var class="var">count</var> is negative, bringing zeros into the vacated bits.  If
<var class="var">count</var> is negative, <code class="code">lsh</code> shifts zeros into the leftmost
(most-significant) bit, producing a positive result even if
<var class="var">integer1</var> is negative.  Contrast this with <code class="code">ash</code>, below.
</p>
<p>Here are two examples of <code class="code">lsh</code>, shifting a pattern of bits one
place to the left.  We show only the low-order eight bits of the binary
pattern; the rest are all zero.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(lsh 5 1)
     &rArr; 10
;; <span class="r">Decimal 5 becomes decimal 10.</span>
00000101 &rArr; 00001010

(lsh 7 1)
     &rArr; 14
;; <span class="r">Decimal 7 becomes decimal 14.</span>
00000111 &rArr; 00001110
</pre></div></div>

<p>As the examples illustrate, shifting the pattern of bits one place to
the left produces a number that is twice the value of the previous
number.
</p>
<p>Shifting a pattern of bits two places to the left produces results
like this (with 8-bit binary numbers):
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(lsh 3 2)
     &rArr; 12
;; <span class="r">Decimal 3 becomes decimal 12.</span>
00000011 &rArr; 00001100
</pre></div></div>

<p>On the other hand, shifting one place to the right looks like this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(lsh 6 -1)
     &rArr; 3
;; <span class="r">Decimal 6 becomes decimal 3.</span>
00000110 &rArr; 00000011
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(lsh 5 -1)
     &rArr; 2
;; <span class="r">Decimal 5 becomes decimal 2.</span>
00000101 &rArr; 00000010
</pre></div></div>

<p>As the example illustrates, shifting one place to the right divides the
value of a positive integer by two, rounding downward.
</p>
<p>The function <code class="code">lsh</code>, like all Emacs Lisp arithmetic functions, does
not check for overflow, so shifting left can discard significant bits
and change the sign of the number.  For example, left shifting
536,870,911 produces &minus;2 in the 30-bit implementation:
</p>
<div class="example">
<pre class="example-preformatted">(lsh 536870911 1)          ; <span class="r">left shift</span>
     &rArr; -2
</pre></div>

<p>In binary, the argument looks like this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">;; <span class="r">Decimal 536,870,911</span>
0111...111111 (30 bits total)
</pre></div></div>

<p>which becomes the following when left shifted:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">;; <span class="r">Decimal &minus;2</span>
1111...111110 (30 bits total)
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-ash"><span class="category-def">Function: </span><span><strong class="def-name">ash</strong> <var class="def-var-arguments">integer1 count</var><a class="copiable-link" href="#index-ash"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-arithmetic-shift"></a>
<p><code class="code">ash</code> (<em class="dfn">arithmetic shift</em>) shifts the bits in <var class="var">integer1</var>
to the left <var class="var">count</var> places, or to the right if <var class="var">count</var>
is negative.
</p>
<p><code class="code">ash</code> gives the same results as <code class="code">lsh</code> except when
<var class="var">integer1</var> and <var class="var">count</var> are both negative.  In that case,
<code class="code">ash</code> puts ones in the empty bit positions on the left, while
<code class="code">lsh</code> puts zeros in those bit positions.
</p>
<p>Thus, with <code class="code">ash</code>, shifting the pattern of bits one place to the right
looks like this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(ash -6 -1) &rArr; -3
;; <span class="r">Decimal &minus;6 becomes decimal &minus;3.</span>
1111...111010 (30 bits total)
     &rArr;
1111...111101 (30 bits total)
</pre></div></div>

<p>In contrast, shifting the pattern of bits one place to the right with
<code class="code">lsh</code> looks like this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(lsh -6 -1) &rArr; 536870909
;; <span class="r">Decimal &minus;6 becomes decimal 536,870,909.</span>
1111...111010 (30 bits total)
     &rArr;
0111...111101 (30 bits total)
</pre></div></div>

<p>Here are other examples:
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">                   ;  <span class="r">       30-bit binary values</span>

(lsh 5 2)          ;   5  =  <span class="r">0000...000101</span>
     &rArr; 20         ;      =  <span class="r">0000...010100</span>
</pre></div><div class="group"><pre class="example-preformatted">(ash 5 2)
     &rArr; 20
(lsh -5 2)         ;  -5  =  <span class="r">1111...111011</span>
     &rArr; -20        ;      =  <span class="r">1111...101100</span>
(ash -5 2)
     &rArr; -20
</pre></div><div class="group"><pre class="example-preformatted">(lsh 5 -2)         ;   5  =  <span class="r">0000...000101</span>
     &rArr; 1          ;      =  <span class="r">0000...000001</span>
</pre></div><div class="group"><pre class="example-preformatted">(ash 5 -2)
     &rArr; 1
</pre></div><div class="group"><pre class="example-preformatted">(lsh -5 -2)        ;  -5  =  <span class="r">1111...111011</span>
     &rArr; 268435454
                   ;      =  <span class="r">0011...111110</span>
</pre></div><div class="group"><pre class="example-preformatted">(ash -5 -2)        ;  -5  =  <span class="r">1111...111011</span>
     &rArr; -2         ;      =  <span class="r">1111...111110</span>
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-logand"><span class="category-def">Function: </span><span><strong class="def-name">logand</strong> <var class="def-var-arguments">&amp;rest ints-or-markers</var><a class="copiable-link" href="#index-logand"> &para;</a></span></dt>
<dd><p>This function returns the &ldquo;logical and&rdquo; of the arguments: the
<var class="var">n</var>th bit is set in the result if, and only if, the <var class="var">n</var>th bit is
set in all the arguments.  (&ldquo;Set&rdquo; means that the value of the bit is 1
rather than 0.)
</p>
<p>For example, using 4-bit binary numbers, the &ldquo;logical and&rdquo; of 13 and
12 is 12: 1101 combined with 1100 produces 1100.
In both the binary numbers, the leftmost two bits are set (i.e., they
are 1&rsquo;s), so the leftmost two bits of the returned value are set.
However, for the rightmost two bits, each is zero in at least one of
the arguments, so the rightmost two bits of the returned value are 0&rsquo;s.
</p>
<p>Therefore,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(logand 13 12)
     &rArr; 12
</pre></div></div>

<p>If <code class="code">logand</code> is not passed any argument, it returns a value of
&minus;1.  This number is an identity element for <code class="code">logand</code>
because its binary representation consists entirely of ones.  If
<code class="code">logand</code> is passed just one argument, it returns that argument.
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">                   ; <span class="r">       30-bit binary values</span>

(logand 14 13)     ; 14  =  <span class="r">0000...001110</span>
                   ; 13  =  <span class="r">0000...001101</span>
     &rArr; 12         ; 12  =  <span class="r">0000...001100</span>
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(logand 14 13 4)   ; 14  =  <span class="r">0000...001110</span>
                   ; 13  =  <span class="r">0000...001101</span>
                   ;  4  =  <span class="r">0000...000100</span>
     &rArr; 4          ;  4  =  <span class="r">0000...000100</span>
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(logand)
     &rArr; -1         ; -1  =  <span class="r">1111...111111</span>
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-logior"><span class="category-def">Function: </span><span><strong class="def-name">logior</strong> <var class="def-var-arguments">&amp;rest ints-or-markers</var><a class="copiable-link" href="#index-logior"> &para;</a></span></dt>
<dd><p>This function returns the &ldquo;inclusive or&rdquo; of its arguments: the <var class="var">n</var>th bit
is set in the result if, and only if, the <var class="var">n</var>th bit is set in at least
one of the arguments.  If there are no arguments, the result is zero,
which is an identity element for this operation.  If <code class="code">logior</code> is
passed just one argument, it returns that argument.
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">                   ; <span class="r">       30-bit binary values</span>

(logior 12 5)      ; 12  =  <span class="r">0000...001100</span>
                   ;  5  =  <span class="r">0000...000101</span>
     &rArr; 13         ; 13  =  <span class="r">0000...001101</span>
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(logior 12 5 7)    ; 12  =  <span class="r">0000...001100</span>
                   ;  5  =  <span class="r">0000...000101</span>
                   ;  7  =  <span class="r">0000...000111</span>
     &rArr; 15         ; 15  =  <span class="r">0000...001111</span>
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-logxor"><span class="category-def">Function: </span><span><strong class="def-name">logxor</strong> <var class="def-var-arguments">&amp;rest ints-or-markers</var><a class="copiable-link" href="#index-logxor"> &para;</a></span></dt>
<dd><p>This function returns the &ldquo;exclusive or&rdquo; of its arguments: the
<var class="var">n</var>th bit is set in the result if, and only if, the <var class="var">n</var>th bit is
set in an odd number of the arguments.  If there are no arguments, the
result is 0, which is an identity element for this operation.  If
<code class="code">logxor</code> is passed just one argument, it returns that argument.
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">                   ; <span class="r">       30-bit binary values</span>

(logxor 12 5)      ; 12  =  <span class="r">0000...001100</span>
                   ;  5  =  <span class="r">0000...000101</span>
     &rArr; 9          ;  9  =  <span class="r">0000...001001</span>
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(logxor 12 5 7)    ; 12  =  <span class="r">0000...001100</span>
                   ;  5  =  <span class="r">0000...000101</span>
                   ;  7  =  <span class="r">0000...000111</span>
     &rArr; 14         ; 14  =  <span class="r">0000...001110</span>
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-lognot"><span class="category-def">Function: </span><span><strong class="def-name">lognot</strong> <var class="def-var-arguments">integer</var><a class="copiable-link" href="#index-lognot"> &para;</a></span></dt>
<dd><p>This function returns the logical complement of its argument: the <var class="var">n</var>th
bit is one in the result if, and only if, the <var class="var">n</var>th bit is zero in
<var class="var">integer</var>, and vice-versa.
</p>
<div class="example">
<pre class="example-preformatted">(lognot 5)
     &rArr; -6
;;  5  =  <span class="r">0000...000101</span> (30 bits total)
;; <span class="r">becomes</span>
;; -6  =  <span class="r">1111...111010</span> (30 bits total)
</pre></div>
</dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Math-Functions.html">Standard Mathematical Functions</a>, Previous: <a href="Rounding-Operations.html">Rounding Operations</a>, Up: <a href="Numbers.html">Numbers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
