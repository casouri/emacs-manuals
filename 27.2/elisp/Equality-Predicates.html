<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 27.2.

Copyright Â© 1990-1996, 1998-2021 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Equality Predicates (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Equality Predicates (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Equality Predicates (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Lisp-Data-Types.html" rel="up" title="Lisp Data Types">
<link href="Mutability.html" rel="next" title="Mutability">
<link href="Type-Predicates.html" rel="prev" title="Type Predicates">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Equality-Predicates">
<div class="nav-panel">
<p>
Next: <a href="Mutability.html" accesskey="n" rel="next">Mutability</a>, Previous: <a href="Type-Predicates.html" accesskey="p" rel="prev">Type Predicates</a>, Up: <a href="Lisp-Data-Types.html" accesskey="u" rel="up">Lisp Data Types</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Equality-Predicates-1"><span>2.8 Equality Predicates<a class="copiable-link" href="#Equality-Predicates-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-equality"></a>

<p>Here we describe functions that test for equality between two
objects.  Other functions test equality of contents between objects of
specific types, e.g., strings.  For these predicates, see the
appropriate chapter describing the data type.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-eq"><span class="category-def">Function: </span><span><strong class="def-name">eq</strong> <var class="def-var-arguments">object1 object2</var><a class="copiable-link" href="#index-eq"> &para;</a></span></dt>
<dd><p>This function returns <code class="code">t</code> if <var class="var">object1</var> and <var class="var">object2</var> are
the same object, and <code class="code">nil</code> otherwise.
</p>
<p>If <var class="var">object1</var> and <var class="var">object2</var> are symbols with the
same name, they are normally the same object&mdash;but see <a class="ref" href="Creating-Symbols.html">Creating and Interning Symbols</a> for exceptions.  For other non-numeric types (e.g., lists, vectors,
strings), two arguments with the same contents or elements are not
necessarily <code class="code">eq</code> to each other: they are <code class="code">eq</code> only if they
are the same object, meaning that a change in the contents of one will
be reflected by the same change in the contents of the other.
</p>
<p>If <var class="var">object1</var> and <var class="var">object2</var> are numbers with differing types or values,
then they cannot be the same object and <code class="code">eq</code> returns <code class="code">nil</code>.
If they are fixnums with the same value,
then they are the same object and <code class="code">eq</code> returns <code class="code">t</code>.
If they were computed separately but happen to have the same value
and the same non-fixnum numeric type, then they might or might not be
the same object, and <code class="code">eq</code> returns <code class="code">t</code> or <code class="code">nil</code>
depending on whether the Lisp interpreter created one object or two.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(eq 'foo 'foo)
     &rArr; t
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(eq ?A ?A)
     &rArr; t
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(eq 3.0 3.0)
     &rArr; t <span class="r">or</span> nil
;; <span class="r">Equal floats may or may not be the same object.</span>
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(eq (make-string 3 ?A) (make-string 3 ?A))
     &rArr; nil
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(eq &quot;asdf&quot; &quot;asdf&quot;)
     &rArr; t <span class="r">or</span> nil
;; <span class="r">Equal string constants or may not be the same object.</span>
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(eq '(1 (2 (3))) '(1 (2 (3))))
     &rArr; nil
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(setq foo '(1 (2 (3))))
     &rArr; (1 (2 (3)))
(eq foo foo)
     &rArr; t
(eq foo '(1 (2 (3))))
     &rArr; nil
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(eq [(1 2) 3] [(1 2) 3])
     &rArr; nil
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(eq (point-marker) (point-marker))
     &rArr; nil
</pre></div></div>

<p>The <code class="code">make-symbol</code> function returns an uninterned symbol, distinct
from the symbol that is used if you write the name in a Lisp expression.
Distinct symbols with the same name are not <code class="code">eq</code>.  See <a class="xref" href="Creating-Symbols.html">Creating and Interning Symbols</a>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(eq (make-symbol &quot;foo&quot;) 'foo)
     &rArr; nil
</pre></div></div>

<a class="index-entry-id" id="index-identical_002dcontents-objects_002c-and-byte_002dcompiler"></a>
<a class="index-entry-id" id="index-objects-with-identical-contents_002c-and-byte_002dcompiler"></a>
<p>The Emacs Lisp byte compiler may collapse identical literal objects,
such as literal strings, into references to the same object, with the
effect that the byte-compiled code will compare such objects as
<code class="code">eq</code>, while the interpreted version of the same code will not.
Therefore, your code should never rely on objects with the same
literal contents being either <code class="code">eq</code> or not <code class="code">eq</code>, it should
instead use functions that compare object contents such as
<code class="code">equal</code>, described below.  Similarly, your code should not modify
literal objects (e.g., put text properties on literal strings), since
doing that might affect other literal objects of the same contents, if
the byte compiler collapses them.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-equal"><span class="category-def">Function: </span><span><strong class="def-name">equal</strong> <var class="def-var-arguments">object1 object2</var><a class="copiable-link" href="#index-equal"> &para;</a></span></dt>
<dd><p>This function returns <code class="code">t</code> if <var class="var">object1</var> and <var class="var">object2</var> have
equal components, and <code class="code">nil</code> otherwise.  Whereas <code class="code">eq</code> tests
if its arguments are the same object, <code class="code">equal</code> looks inside
nonidentical arguments to see if their elements or contents are the
same.  So, if two objects are <code class="code">eq</code>, they are <code class="code">equal</code>, but
the converse is not always true.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(equal 'foo 'foo)
     &rArr; t
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(equal 456 456)
     &rArr; t
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(equal &quot;asdf&quot; &quot;asdf&quot;)
     &rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(eq &quot;asdf&quot; &quot;asdf&quot;)
     &rArr; nil
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(equal '(1 (2 (3))) '(1 (2 (3))))
     &rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(eq '(1 (2 (3))) '(1 (2 (3))))
     &rArr; nil
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(equal [(1 2) 3] [(1 2) 3])
     &rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(eq [(1 2) 3] [(1 2) 3])
     &rArr; nil
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(equal (point-marker) (point-marker))
     &rArr; t
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(eq (point-marker) (point-marker))
     &rArr; nil
</pre></div></div>

<p>Comparison of strings is case-sensitive, but does not take account of
text properties&mdash;it compares only the characters in the strings.
See <a class="xref" href="Text-Properties.html">Text Properties</a>.  Use <code class="code">equal-including-properties</code> to also
compare text properties.  For technical reasons, a unibyte string and
a multibyte string are <code class="code">equal</code> if and only if they contain the
same sequence of character codes and all these codes are in the range
0 through 127 (<abbr class="acronym">ASCII</abbr>).
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(equal &quot;asdf&quot; &quot;ASDF&quot;)
     &rArr; nil
</pre></div></div>

<p>However, two distinct buffers are never considered <code class="code">equal</code>, even if
their textual contents are the same.
</p></dd></dl>

<p>For <code class="code">equal</code>, equality is defined recursively; for example, given
two cons cells <var class="var">x</var> and <var class="var">y</var>, <code class="code">(equal <var class="var">x</var> <var class="var">y</var>)</code>
returns <code class="code">t</code> if and only if both the expressions below return
<code class="code">t</code>:
</p>
<div class="example">
<pre class="example-preformatted">(equal (car <var class="var">x</var>) (car <var class="var">y</var>))
(equal (cdr <var class="var">x</var>) (cdr <var class="var">y</var>))
</pre></div>

<p>Comparing circular lists may therefore cause deep recursion that leads
to an error, and this may result in counterintuitive behavior such as
<code class="code">(equal a b)</code> returning <code class="code">t</code> whereas <code class="code">(equal b a)</code>
signals an error.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-equal_002dincluding_002dproperties"><span class="category-def">Function: </span><span><strong class="def-name">equal-including-properties</strong> <var class="def-var-arguments">object1 object2</var><a class="copiable-link" href="#index-equal_002dincluding_002dproperties"> &para;</a></span></dt>
<dd><p>This function behaves like <code class="code">equal</code> in all cases but also requires
that for two strings to be equal, they have the same text properties.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(equal &quot;asdf&quot; (propertize &quot;asdf&quot; 'asdf t))
     &rArr; t
</pre></div><div class="group"><pre class="example-preformatted">(equal-including-properties &quot;asdf&quot;
                            (propertize &quot;asdf&quot; 'asdf t))
     &rArr; nil
</pre></div></div>
</dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Mutability.html">Mutability</a>, Previous: <a href="Type-Predicates.html">Type Predicates</a>, Up: <a href="Lisp-Data-Types.html">Lisp Data Types</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
