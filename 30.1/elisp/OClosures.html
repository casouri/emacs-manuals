<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.1.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>OClosures (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="OClosures (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="OClosures (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Functions.html" rel="up" title="Functions">
<link href="Advising-Functions.html" rel="next" title="Advising Functions">
<link href="Closures.html" rel="prev" title="Closures">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="OClosures">
<div class="nav-panel">
<p>
Next: <a href="Advising-Functions.html" accesskey="n" rel="next">Advising Emacs Lisp Functions</a>, Previous: <a href="Closures.html" accesskey="p" rel="prev">Closures</a>, Up: <a href="Functions.html" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Open-Closures"><span>13.11 Open Closures<a class="copiable-link" href="#Open-Closures"> &para;</a></span></h3>
<a class="index-entry-id" id="index-oclosures"></a>
<a class="index-entry-id" id="index-open-closures"></a>

<p>Traditionally, functions are opaque objects which offer no other
functionality but to call them.  (Emacs Lisp functions aren&rsquo;t fully
opaque since you can extract some info out of them such as their
docstring, their arglist, or their interactive spec, but they are
still mostly opaque.)  This is usually what we want, but occasionally
we need functions to expose a bit more information about themselves.
</p>
<p><em class="dfn">Open closures</em>, or <em class="dfn">OClosures</em> for short, are function
objects which carry additional type information and expose some
information about themselves in the form of slots which you can access
via accessor functions.
</p>
<p>OClosures are defined in two steps: first you use
<code class="code">oclosure-define</code> to define a new OClosure type by specifying the
slots carried by the OClosures of this type, and then you use
<code class="code">oclosure-lambda</code> to create an OClosure object of a given type.
</p>
<p>Let&rsquo;s say we want to define keyboard macros, i.e. interactive
functions which re-execute a sequence of key events (see <a class="pxref" href="Keyboard-Macros.html">Keyboard Macros</a>).  You could do it with a plain function as follows:
</p>
<div class="example">
<pre class="example-preformatted">(defun kbd-macro (key-sequence)
  (lambda (&amp;optional arg)
    (interactive &quot;P&quot;)
    (execute-kbd-macro key-sequence arg)))
</pre></div>

<p>But with such a definition there is no easy way to extract the
<var class="var">key-sequence</var> from that function, for example to print it.
</p>
<p>We can solve this problem using OClosures as follows.  First we define
the type of our keyboard macros (to which we decided to add
a <code class="code">counter</code> slot while at it):
</p>
<div class="example">
<pre class="example-preformatted">(oclosure-define kbd-macro
  &quot;Keyboard macro.&quot;
  keys (counter :mutable t))
</pre></div>

<p>After which we can rewrite our <code class="code">kbd-macro</code> function:
</p>
<div class="example">
<pre class="example-preformatted">(defun kbd-macro (key-sequence)
  (oclosure-lambda (kbd-macro (keys key-sequence) (counter 0))
      (&amp;optional arg)
    (interactive &quot;P&quot;)
    (execute-kbd-macro keys arg)
    (setq counter (1+ counter))))
</pre></div>

<p>As you can see, the <code class="code">keys</code> and <code class="code">counter</code> slots of the
OClosure can be accessed as local variables from within the body
of the OClosure.  But we can now also access them from outside of the
body of the OClosure, for example to describe a keyboard macro:
</p>
<div class="example">
<pre class="example-preformatted">(defun describe-kbd-macro (km)
  (if (not (eq 'kbd-macro (oclosure-type km)))
      (message &quot;Not a keyboard macro&quot;)
    (let ((keys    (kbd-macro--keys km))
          (counter (kbd-macro--counter km)))
      (message &quot;Keys=%S, called %d times&quot; keys counter))))
</pre></div>

<p>Where <code class="code">kbd-macro--keys</code> and <code class="code">kbd-macro--counter</code> are
accessor functions generated by the <code class="code">oclosure-define</code> macro for
oclosures whose type is <code class="code">kbd-macro</code>.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-oclosure_002ddefine"><span class="category-def">Macro: </span><span><strong class="def-name">oclosure-define</strong> <var class="def-var-arguments">oname &amp;optional docstring &amp;rest slots</var><a class="copiable-link" href="#index-oclosure_002ddefine"> &para;</a></span></dt>
<dd><p>This macro defines a new OClosure type along with accessor functions
for its <var class="var">slots</var>.  <var class="var">oname</var> can be a symbol (the name of the new
type), or a list of the form
<code class="code">(<var class="var">oname</var>&nbsp;.&nbsp;<var class="var">type-props</var>)</code><!-- /@w -->, in which case
<var class="var">type-props</var> is a list of additional properties of this oclosure
type.  <var class="var">slots</var> is a list of slot descriptions where each slot can
be either a symbol (the name of the slot) or it can be of the form
<code class="code">(<var class="var">slot-name</var>&nbsp;.&nbsp;<var class="var">slot-props</var>)</code><!-- /@w -->, where
<var class="var">slot-props</var> is a property list of the corresponding slot
<var class="var">slot-name</var>.
The OClosure type&rsquo;s properties specified by <var class="var">type-props</var> can
include the following:
</p>
<dl class="table">
<dt><code class="code">(:predicate <var class="var">pred-name</var>)</code></dt>
<dd><p>This requests creation of a predicate function named <var class="var">pred-name</var>.
This function will be used to recognize OClosures of the type
<var class="var">oname</var>.  If this type property is not specified,
<code class="code">oclosure-define</code> will generate a default name for the
predicate.
</p></dd>
<dt><code class="code">(:parent <var class="var">otype</var>)</code></dt>
<dd><p>This makes type <var class="var">otype</var> of OClosures be the parent of the type
<var class="var">oname</var>.  The OClosures of type <var class="var">oname</var> inherit the
<var class="var">slots</var> defined by their parent type.
</p></dd>
<dt><code class="code">(:copier <var class="var">copier-name</var> <var class="var">copier-args</var>)</code></dt>
<dd><p>This causes the definition of a functional update function, knows as
the <em class="dfn">copier</em>, which takes an OClosure of type <var class="var">oname</var> as its
first argument and returns a copy of it with the slots named in
<var class="var">copier-args</var> modified to contain the value passed in the
corresponding argument in the actual call to <var class="var">copier-name</var>.
</p></dd>
</dl>

<p>For each slot in <var class="var">slots</var>, the <code class="code">oclosure-define</code> macro creates
an accessor function named <code class="code"><var class="var">oname</var>--<var class="var">slot-name</var></code>; these
can be used to access the values of the slots.  The slot definitions
in <var class="var">slots</var> can specify the following properties of the slots:
</p>
<dl class="table">
<dt><code class="code">:mutable <var class="var">val</var></code></dt>
<dd><p>By default, slots are immutable, but if you specify the
<code class="code">:mutable</code> property with a non-<code class="code">nil</code> value, the slot can be
mutated, for example with <code class="code">setf</code> (see <a class="pxref" href="Setting-Generalized-Variables.html">The <code class="code">setf</code> Macro</a>).
</p></dd>
<dt><code class="code">:type <var class="var">val-type</var></code></dt>
<dd><p>This specifies the type of the values expected to appear in the slot.
</p></dd>
</dl>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-oclosure_002dlambda"><span class="category-def">Macro: </span><span><strong class="def-name">oclosure-lambda</strong> <var class="def-var-arguments">(type . slots) arglist &amp;rest body</var><a class="copiable-link" href="#index-oclosure_002dlambda"> &para;</a></span></dt>
<dd><p>This macro creates an anonymous OClosure of type <var class="var">type</var>, which
should have been defined with <code class="code">oclosure-define</code>.  <var class="var">slots</var>
should be a list of elements of the form
<code class="code">(<var class="var">slot-name</var>&nbsp;<var class="var">expr</var>)</code><!-- /@w -->.  At run time, each <var class="var">expr</var>
is evaluated, in order, after which the OClosure is created with its
slots initialized with the resulting values.
</p>
<p>When called as a function (see <a class="pxref" href="Calling-Functions.html">Calling Functions</a>), the OClosure
created by this macro will accept arguments according to <var class="var">arglist</var>
and will execute the code in <var class="var">body</var>.  <var class="var">body</var> can refer to the
value of any of its slot directly as if it were a local variable that
had been captured by static scoping.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-oclosure_002dtype"><span class="category-def">Function: </span><span><strong class="def-name">oclosure-type</strong> <var class="def-var-arguments">object</var><a class="copiable-link" href="#index-oclosure_002dtype"> &para;</a></span></dt>
<dd><p>This function returns the OClosure type (a symbol) of <var class="var">object</var> if
it is an OClosure, and <code class="code">nil</code> otherwise.
</p></dd></dl>

<p>One other function related to OClosures is
<code class="code">oclosure-interactive-form</code>, which allows some types of OClosures
to compute their interactive forms dynamically.  See <a class="xref" href="Using-Interactive.html">oclosure-interactive-form</a>.
</p>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Advising-Functions.html">Advising Emacs Lisp Functions</a>, Previous: <a href="Closures.html">Closures</a>, Up: <a href="Functions.html">Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
