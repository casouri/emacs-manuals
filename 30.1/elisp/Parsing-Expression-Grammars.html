<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.1.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Parsing Expression Grammars (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Parsing Expression Grammars (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Parsing Expression Grammars (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html" rel="up" title="Top">
<link href="Parsing-Program-Source.html" rel="next" title="Parsing Program Source">
<link href="Syntax-Tables.html" rel="prev" title="Syntax Tables">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="chapter-level-extent" id="Parsing-Expression-Grammars">
<div class="nav-panel">
<p>
Next: <a href="Parsing-Program-Source.html" accesskey="n" rel="next">Parsing Program Source</a>, Previous: <a href="Syntax-Tables.html" accesskey="p" rel="prev">Syntax Tables</a>, Up: <a href="index.html" accesskey="u" rel="up">Emacs Lisp</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h2 class="chapter" id="Parsing-Expression-Grammars-1"><span>37 Parsing Expression Grammars<a class="copiable-link" href="#Parsing-Expression-Grammars-1"> &para;</a></span></h2>
<a class="index-entry-id" id="index-text-parsing-1"></a>
<a class="index-entry-id" id="index-parsing-expression-grammar"></a>
<a class="index-entry-id" id="index-PEG"></a>

<p>Emacs Lisp provides several tools for parsing and matching text,
from regular expressions (see <a class="pxref" href="Regular-Expressions.html">Regular Expressions</a>) to full
left-to-right (a.k.a. <abbr class="acronym">LL</abbr>) grammar parsers (see <a data-manual="bovine" href="https://www.gnu.org/software/emacs/manual/html_node/bovine/index.html#Top">Bovine parser development</a>).  <em class="dfn">Parsing Expression Grammars</em>
(<abbr class="acronym">PEG</abbr>) are another approach to text parsing that offer more
structure and composability than regular expressions, but less
complexity than context-free grammars.
</p>
<p>A Parsing Expression Grammar (<abbr class="acronym">PEG</abbr>) describes a formal language
in terms of a set of rules for recognizing strings in the language.  In
Emacs, a <abbr class="acronym">PEG</abbr> parser is defined as a list of named rules, each
of which matches text patterns and/or contains references to other
rules.  Parsing is initiated with the function <code class="code">peg-run</code> or the
macro <code class="code">peg-parse</code> (see below), and parses text after point in the
current buffer, using a given set of rules.
</p>
<a class="index-entry-id" id="index-parsing-expression"></a>
<a class="index-entry-id" id="index-root_002c-of-parsing-expression-grammar"></a>
<a class="index-entry-id" id="index-entry_002dpoint_002c-of-parsing-expression-grammar"></a>
<p>Each rule in a <abbr class="acronym">PEG</abbr> is referred to as a <em class="dfn">parsing
expression</em> (<abbr class="acronym">PEX</abbr>), and can be specified a literal string, a
regexp-like character range or set, a peg-specific construct resembling
an Emacs Lisp function call, a reference to another rule, or a
combination of any of these.  A grammar is expressed as a tree of rules
in which one rule is typically treated as a &ldquo;root&rdquo; or &ldquo;entry-point&rdquo;
rule.  For instance:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">((number sign digit (* digit))
 (sign   (or &quot;+&quot; &quot;-&quot; &quot;&quot;))
 (digit  [0-9]))
</pre></div></div>

<p>Once defined, grammars can be used to parse text after point in the
current buffer, in a number of ways.  The <code class="code">peg-parse</code> macro is the
simplest:
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-peg_002dparse"><span class="category-def">Macro: </span><span><strong class="def-name">peg-parse</strong> <var class="def-var-arguments">&amp;rest pexs</var><a class="copiable-link" href="#index-peg_002dparse"> &para;</a></span></dt>
<dd><p>Match <var class="var">pexs</var> at point.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(peg-parse
  (number sign digit (* digit))
  (sign   (or &quot;+&quot; &quot;-&quot; &quot;&quot;))
  (digit  [0-9]))
</pre></div></div>

<p>While this macro is simple it is also inflexible, as the rules must be
written directly into the source code.  More flexibility can be gained
by using a combination of other functions and macros.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-with_002dpeg_002drules"><span class="category-def">Macro: </span><span><strong class="def-name">with-peg-rules</strong> <var class="def-var-arguments">rules &amp;rest body</var><a class="copiable-link" href="#index-with_002dpeg_002drules"> &para;</a></span></dt>
<dd><p>Execute <var class="var">body</var> with <var class="var">rules</var>, a list of <abbr class="acronym">PEX</abbr>s, in
effect.  Within <var class="var">BODY</var>, parsing is initiated with a call to
<code class="code">peg-run</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-peg_002drun"><span class="category-def">Function: </span><span><strong class="def-name">peg-run</strong> <var class="def-var-arguments">peg-matcher &amp;optional failure-function success-function</var><a class="copiable-link" href="#index-peg_002drun"> &para;</a></span></dt>
<dd><p>This function accepts a single <var class="var">peg-matcher</var>, which is the result of
calling <code class="code">peg</code> (see below) on a named rule, usually the entry-point
of a larger grammar.
</p>
<p>At the end of parsing, one of <var class="var">failure-function</var> or
<var class="var">success-function</var> is called, depending on whether the parsing
succeeded or not.  If <var class="var">success-function</var> is provided, it should be a
function that receives as its only argument an anonymous function that
runs all the actions collected on the stack during parsing.  By default
this anonymous function is simply executed.  If parsing fails, a
function provided as <var class="var">failure-function</var> will be called with a list
of <abbr class="acronym">PEG</abbr> expressions that failed during parsing.  By default
this list is discarded.
</p></dd></dl>

<p>The <var class="var">peg-matcher</var> passed to <code class="code">peg-run</code> is produced by a call to
<code class="code">peg</code>:
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-peg"><span class="category-def">Macro: </span><span><strong class="def-name">peg</strong> <var class="def-var-arguments">&amp;rest pexs</var><a class="copiable-link" href="#index-peg"> &para;</a></span></dt>
<dd><p>Convert <var class="var">pexs</var> into a single peg-matcher suitable for passing to
<code class="code">peg-run</code>.
</p></dd></dl>

<p>The <code class="code">peg-parse</code> example above expands to a set of calls to these
functions, and could be written in full as:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(with-peg-rules
    ((number sign digit (* digit))
     (sign   (or &quot;+&quot; &quot;-&quot; &quot;&quot;))
     (digit  [0-9]))
  (peg-run (peg number)))
</pre></div></div>

<p>This approach allows more explicit control over the &ldquo;entry-point&rdquo; of
parsing, and allows the combination of rules from different sources.
</p>
<p>Individual rules can also be defined using a more <code class="code">defun</code>-like
syntax, using the macro <code class="code">define-peg-rule</code>:
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-define_002dpeg_002drule"><span class="category-def">Macro: </span><span><strong class="def-name">define-peg-rule</strong> <var class="def-var-arguments">name args &amp;rest pexs</var><a class="copiable-link" href="#index-define_002dpeg_002drule"> &para;</a></span></dt>
<dd><p>Define <var class="var">name</var> as a PEG rule that accepts <var class="var">args</var> and matches
<var class="var">pexs</var> at point.
</p></dd></dl>

<p>For instance:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(define-peg-rule digit ()
  [0-9])
</pre></div></div>

<p>Arguments can be supplied to rules by the <code class="code">funcall</code> PEG rule
(see <a class="pxref" href="PEX-Definitions.html">PEX Definitions</a>).
</p>
<p>Another possibility is to define a named set of rules with
<code class="code">define-peg-ruleset</code>:
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-define_002dpeg_002druleset"><span class="category-def">Macro: </span><span><strong class="def-name">define-peg-ruleset</strong> <var class="def-var-arguments">name &amp;rest rules</var><a class="copiable-link" href="#index-define_002dpeg_002druleset"> &para;</a></span></dt>
<dd><p>Define <var class="var">name</var> as an identifier for <var class="var">rules</var>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(define-peg-ruleset number-grammar
        '((number sign digit (* digit))
          digit  ;; A reference to the definition above.
          (sign (or &quot;+&quot; &quot;-&quot; &quot;&quot;))))
</pre></div></div>

<p>Rules and rulesets defined this way can be referred to by name in
later calls to <code class="code">peg-run</code> or <code class="code">with-peg-rules</code>:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(with-peg-rules number-grammar
  (peg-run (peg number)))
</pre></div></div>

<p>By default, calls to <code class="code">peg-run</code> or <code class="code">peg-parse</code> produce no
output: parsing simply moves point.  In order to return or otherwise
act upon parsed strings, rules can include <em class="dfn">actions</em>, see
<a class="ref" href="Parsing-Actions.html">Parsing Actions</a>.
</p>

<ul class="mini-toc">
<li><a href="PEX-Definitions.html" accesskey="1">PEX Definitions</a></li>
<li><a href="Parsing-Actions.html" accesskey="2">Parsing Actions</a></li>
<li><a href="Writing-PEG-Rules.html" accesskey="3">Writing PEG Rules</a></li>
</ul>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Parsing-Program-Source.html">Parsing Program Source</a>, Previous: <a href="Syntax-Tables.html">Syntax Tables</a>, Up: <a href="index.html">Emacs Lisp</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
