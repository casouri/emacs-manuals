<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 30.1.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Magic File Names (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Magic File Names (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Magic File Names (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Files.html" rel="up" title="Files">
<link href="Format-Conversion.html" rel="next" title="Format Conversion">
<link href="Create_002fDelete-Dirs.html" rel="prev" title="Create/Delete Dirs">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Magic-File-Names">
<div class="nav-panel">
<p>
Next: <a href="Format-Conversion.html" accesskey="n" rel="next">File Format Conversion</a>, Previous: <a href="Create_002fDelete-Dirs.html" accesskey="p" rel="prev">Creating, Copying and Deleting Directories</a>, Up: <a href="Files.html" accesskey="u" rel="up">Files</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Making-Certain-File-Names-_0060_0060Magic_0027_0027"><span>26.12 Making Certain File Names &ldquo;Magic&rdquo;<a class="copiable-link" href="#Making-Certain-File-Names-_0060_0060Magic_0027_0027"> &para;</a></span></h3>
<a class="index-entry-id" id="index-magic-file-names"></a>

<p>You can implement special handling for certain file names.  This is
called making those names <em class="dfn">magic</em>.  The principal use for this
feature is in implementing access to remote files (see <a data-manual="emacs" href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files">Remote Files</a> in <cite class="cite">The GNU Emacs Manual</cite>).
</p>
<p>To define a kind of magic file name, you must supply a regular
expression to define the class of names (all those that match the
regular expression), plus a handler that implements all the primitive
Emacs file operations for file names that match.
</p>
<a class="index-entry-id" id="index-file-name-handler"></a>
<a class="index-entry-id" id="index-file_002dname_002dhandler_002dalist"></a>
<p>The variable <code class="code">file-name-handler-alist</code> holds a list of handlers,
together with regular expressions that determine when to apply each
handler.  Each element has this form:
</p>
<div class="example">
<pre class="example-preformatted">(<var class="var">regexp</var> . <var class="var">handler</var>)
</pre></div>

<p>All the Emacs primitives for file access and file name transformation
check the given file name against <code class="code">file-name-handler-alist</code>.  If
the file name matches <var class="var">regexp</var>, the primitives handle that file by
calling <var class="var">handler</var>.
</p>
<p>The first argument given to <var class="var">handler</var> is the name of the
primitive, as a symbol; the remaining arguments are the arguments that
were passed to that primitive.  (The first of these arguments is most
often the file name itself.)  For example, if you do this:
</p>
<div class="example">
<pre class="example-preformatted">(file-exists-p <var class="var">filename</var>)
</pre></div>

<p>and <var class="var">filename</var> has handler <var class="var">handler</var>, then <var class="var">handler</var> is
called like this:
</p>
<div class="example">
<pre class="example-preformatted">(funcall <var class="var">handler</var> 'file-exists-p <var class="var">filename</var>)
</pre></div>

<p>When a function takes two or more arguments that must be file names,
it checks each of those names for a handler.  For example, if you do
this:
</p>
<div class="example">
<pre class="example-preformatted">(expand-file-name <var class="var">filename</var> <var class="var">dirname</var>)
</pre></div>

<p>then it checks for a handler for <var class="var">filename</var> and then for a handler
for <var class="var">dirname</var>.  In either case, the <var class="var">handler</var> is called like
this:
</p>
<div class="example">
<pre class="example-preformatted">(funcall <var class="var">handler</var> 'expand-file-name <var class="var">filename</var> <var class="var">dirname</var>)
</pre></div>

<p>The <var class="var">handler</var> then needs to figure out whether to handle
<var class="var">filename</var> or <var class="var">dirname</var>.
</p>
<p>If the specified file name matches more than one handler, the one
whose match starts last in the file name gets precedence.  This rule
is chosen so that handlers for jobs such as uncompression are handled
first, before handlers for jobs such as remote file access.
</p>
<p>Here are the operations that a magic file name handler gets to handle:
</p>
<p><code class="code">abbreviate-file-name</code>, <code class="code">access-file</code>,
<code class="code">add-name-to-file</code>, <code class="code">byte-compiler-base-file-name</code>,<br>
<code class="code">copy-directory</code>, <code class="code">copy-file</code>,
<code class="code">delete-directory</code>, <code class="code">delete-file</code>,
<code class="code">diff-latest-backup-file</code>,
<code class="code">directory-file-name</code>,
<code class="code">directory-files</code>,
<code class="code">directory-files-and-attributes</code>,
<code class="code">dired-compress-file</code>, <code class="code">dired-uncache</code>,
<code class="code">exec-path</code>, <code class="code">expand-file-name</code>,<br>
<code class="code">file-accessible-directory-p</code>,
<code class="code">file-acl</code>,
<code class="code">file-attributes</code>,
<code class="code">file-directory-p</code>,
<code class="code">file-equal-p</code>,
<code class="code">file-executable-p</code>, <code class="code">file-exists-p</code>,
<code class="code">file-group-gid</code>, <code class="code">file-in-directory-p</code>,
<code class="code">file-local-copy</code>, <code class="code">file-locked-p</code>,
<code class="code">file-modes</code>, <code class="code">file-name-all-completions</code>,
<code class="code">file-name-as-directory</code>,
<code class="code">file-name-case-insensitive-p</code>,
<code class="code">file-name-completion</code>,
<code class="code">file-name-directory</code>,
<code class="code">file-name-nondirectory</code>,
<code class="code">file-name-sans-versions</code>, <code class="code">file-newer-than-file-p</code>,
<code class="code">file-notify-add-watch</code>, <code class="code">file-notify-rm-watch</code>,
<code class="code">file-notify-valid-p</code>,
<code class="code">file-ownership-preserved-p</code>,
<code class="code">file-readable-p</code>, <code class="code">file-regular-p</code>,
<code class="code">file-remote-p</code>, <code class="code">file-selinux-context</code>,
<code class="code">file-symlink-p</code>, <code class="code">file-system-info</code>,
<code class="code">file-truename</code>, <code class="code">file-user-uid</code>,
<code class="code">file-writable-p</code>,
<code class="code">find-backup-file-name</code>,<br>
<code class="code">get-file-buffer</code>,
<code class="code">insert-directory</code>,
<code class="code">insert-file-contents</code>,<br>
<code class="code">list-system-processes</code>,
<code class="code">load</code>, <code class="code">lock-file</code>,
<code class="code">make-auto-save-file-name</code>,
<code class="code">make-directory</code>,
<code class="code">make-lock-file-name</code>,
<code class="code">make-nearby-temp-file</code>,
<code class="code">make-process</code>,
<code class="code">make-symbolic-link</code>,<br>
<code class="code">memory-info</code>, <code class="code">process-attributes</code>, <code class="code">process-file</code>,
<code class="code">rename-file</code>, <code class="code">set-file-acl</code>, <code class="code">set-file-modes</code>,
<code class="code">set-file-selinux-context</code>, <code class="code">set-file-times</code>,
<code class="code">set-visited-file-modtime</code>, <code class="code">shell-command</code>,
<code class="code">start-file-process</code>,
<code class="code">substitute-in-file-name</code>,<br>
<code class="code">temporary-file-directory</code>,
<code class="code">unhandled-file-name-directory</code>,
<code class="code">unlock-file</code>,
<code class="code">vc-registered</code>,
<code class="code">verify-visited-file-modtime</code>,<br>
<code class="code">write-region</code>.
</p>
<p>Handlers for <code class="code">insert-file-contents</code> typically need to clear the
buffer&rsquo;s modified flag, with <code class="code">(set-buffer-modified-p nil)</code>, if the
<var class="var">visit</var> argument is non-<code class="code">nil</code>.  This also has the effect of
unlocking the buffer if it is locked.
</p>
<p>The handler function must handle all of the above operations, and
possibly others to be added in the future.  It need not implement all
these operations itself&mdash;when it has nothing special to do for a
certain operation, it can reinvoke the primitive, to handle the
operation in the usual way.  It should always reinvoke the primitive
for an operation it does not recognize.  Here&rsquo;s one way to do this:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(defun my-file-handler (operation &amp;rest args)
  ;; <span class="r">First check for the specific operations</span>
  ;; <span class="r">that we have special handling for.</span>
  (cond ((eq operation 'insert-file-contents) ...)
        ((eq operation 'write-region) ...)
        ...
        ;; <span class="r">Handle any operation we don&rsquo;t know about.</span>
        (t (let ((inhibit-file-name-handlers
                  (cons 'my-file-handler
                        (and (eq inhibit-file-name-operation operation)
                             inhibit-file-name-handlers)))
                 (inhibit-file-name-operation operation))
             (apply operation args)))))
</pre></div>

<p>When a handler function decides to call the ordinary Emacs primitive for
the operation at hand, it needs to prevent the primitive from calling
the same handler once again, thus leading to an infinite recursion.  The
example above shows how to do this, with the variables
<code class="code">inhibit-file-name-handlers</code> and
<code class="code">inhibit-file-name-operation</code>.  Be careful to use them exactly as
shown above; the details are crucial for proper behavior in the case of
multiple handlers, and for operations that have two file names that may
each have handlers.
</p>
<a class="index-entry-id" id="index-safe_002dmagic-_0028property_0029"></a>
<p>Handlers that don&rsquo;t really do anything special for actual access to the
file&mdash;such as the ones that implement completion of host names for
remote file names&mdash;should have a non-<code class="code">nil</code> <code class="code">safe-magic</code>
property.  For instance, Emacs normally protects directory names
it finds in <code class="code">PATH</code> from becoming magic, if they look like magic
file names, by prefixing them with &lsquo;<samp class="samp">/:</samp>&rsquo;.  But if the handler that
would be used for them has a non-<code class="code">nil</code> <code class="code">safe-magic</code>
property, the &lsquo;<samp class="samp">/:</samp>&rsquo; is not added.
</p>
<a class="index-entry-id" id="index-operations-_0028property_0029"></a>
<p>A file name handler can have an <code class="code">operations</code> property to
declare which operations it handles in a nontrivial way.  If this
property has a non-<code class="code">nil</code> value, it should be a list of
operations; then only those operations will call the handler.  This
avoids inefficiency, but its main purpose is for autoloaded handler
functions, so that they won&rsquo;t be loaded except when they have real
work to do.
</p>
<p>Simply deferring all operations to the usual primitives does not
work.  For instance, if the file name handler applies to
<code class="code">file-exists-p</code>, then it must handle <code class="code">load</code> itself, because
the usual <code class="code">load</code> code won&rsquo;t work properly in that case.  However,
if the handler uses the <code class="code">operations</code> property to say it doesn&rsquo;t
handle <code class="code">file-exists-p</code>, then it need not handle <code class="code">load</code>
nontrivially.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-inhibit_002dfile_002dname_002dhandlers"><span class="category-def">Variable: </span><span><strong class="def-name">inhibit-file-name-handlers</strong><a class="copiable-link" href="#index-inhibit_002dfile_002dname_002dhandlers"> &para;</a></span></dt>
<dd><p>This variable holds a list of handlers whose use is presently inhibited
for a certain operation.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-inhibit_002dfile_002dname_002doperation"><span class="category-def">Variable: </span><span><strong class="def-name">inhibit-file-name-operation</strong><a class="copiable-link" href="#index-inhibit_002dfile_002dname_002doperation"> &para;</a></span></dt>
<dd><p>The operation for which certain handlers are presently inhibited.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-find_002dfile_002dname_002dhandler"><span class="category-def">Function: </span><span><strong class="def-name">find-file-name-handler</strong> <var class="def-var-arguments">file operation</var><a class="copiable-link" href="#index-find_002dfile_002dname_002dhandler"> &para;</a></span></dt>
<dd><p>This function returns the handler function for file name <var class="var">file</var>,
or <code class="code">nil</code> if there is none.  The argument <var class="var">operation</var> should
be the operation to be performed on the file&mdash;the value you will pass
to the handler as its first argument when you call it.  If
<var class="var">operation</var> equals <code class="code">inhibit-file-name-operation</code>, or if it is
not found in the <code class="code">operations</code> property of the handler, this
function returns <code class="code">nil</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-file_002dlocal_002dcopy"><span class="category-def">Function: </span><span><strong class="def-name">file-local-copy</strong> <var class="def-var-arguments">filename</var><a class="copiable-link" href="#index-file_002dlocal_002dcopy"> &para;</a></span></dt>
<dd><p>This function copies file <var class="var">filename</var> to an ordinary non-magic file
on the local machine, if it isn&rsquo;t on the local machine already.  Magic
file names should handle the <code class="code">file-local-copy</code> operation if they
refer to files on other machines.  A magic file name that is used for
other purposes than remote file access should not handle
<code class="code">file-local-copy</code>; then this function will treat the file as
local.
</p>
<p>If <var class="var">filename</var> is local, whether magic or not, this function does
nothing and returns <code class="code">nil</code>.  Otherwise it returns the file name
of the local copy file.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-file_002dremote_002dp"><span class="category-def">Function: </span><span><strong class="def-name">file-remote-p</strong> <var class="def-var-arguments">filename &amp;optional identification connected</var><a class="copiable-link" href="#index-file_002dremote_002dp"> &para;</a></span></dt>
<dd><p>This function tests whether <var class="var">filename</var> is a remote file.  If
<var class="var">filename</var> is local (not remote), the return value is <code class="code">nil</code>.
If <var class="var">filename</var> is indeed remote, the return value is a string that
identifies the remote system.
</p>
<p>This identifier string can include a host name and a user name, as
well as characters designating the method used to access the remote
system.  For example, the remote identifier string for the file name
<code class="code">/sudo::/some/file</code> is <code class="code">/sudo:root@localhost:</code>.
</p>
<p>If <code class="code">file-remote-p</code> returns the same identifier for two different
file names, that means they are stored on the same file system and can
be accessed locally with respect to each other.  This means, for
example, that it is possible to start a remote process accessing both
files at the same time.  Implementers of file name handlers need to
ensure this principle is valid.
</p>
<p><var class="var">identification</var> specifies which part of the identifier shall be
returned as string.  <var class="var">identification</var> can be the symbol
<code class="code">method</code>, <code class="code">user</code>, <code class="code">host</code> or <code class="code">localname</code>; any other
value is handled like <code class="code">nil</code> and means to return the complete
identifier string.  In the example above, the remote <code class="code">user</code>
identifier string would be <code class="code">root</code>.
</p>
<p>If the remote <var class="var">file</var> does not contain a method, a user name, or a
host name, the respective default value is returned.  The string
returned for <var class="var">identification</var> <code class="code">localname</code> can differ depending
on whether there is an existing connection.  File name handler specific
implementations could support further <var class="var">identification</var> symbols;
See <a data-manual="tramp" href="https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top">Tramp</a>, for example, knows also the <code class="code">hop</code>
symbol.
</p>
<p>If <var class="var">connected</var> is non-<code class="code">nil</code>, this function returns <code class="code">nil</code>
even if <var class="var">filename</var> is remote, if Emacs has no network connection
to its host.  This is useful when you want to avoid the delay of
making connections when they don&rsquo;t exist.  If <var class="var">connected</var> is
<code class="code">never</code>, <em class="emph">never</em> use an existing connection to return the
identification, even if one is already present (this is otherwise like
a value of <code class="code">nil</code>).  This lets you prevent any connection-specific
logic, such as expanding the local part of the file name.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-unhandled_002dfile_002dname_002ddirectory"><span class="category-def">Function: </span><span><strong class="def-name">unhandled-file-name-directory</strong> <var class="def-var-arguments">filename</var><a class="copiable-link" href="#index-unhandled_002dfile_002dname_002ddirectory"> &para;</a></span></dt>
<dd><p>This function returns the name of a directory that is not magic.  For
a non-magic <var class="var">filename</var> it returns the corresponding directory name
(see <a class="pxref" href="Directory-Names.html">Directory Names</a>).  For a magic <var class="var">filename</var>, it invokes the
file name handler, which therefore decides what value to return.  If
<var class="var">filename</var> is not accessible from a local process, then the file
name handler should indicate that by returning <code class="code">nil</code>.
</p>
<p>This is useful for running a subprocess; every subprocess must have a
non-magic directory to serve as its current directory, and this function
is a good way to come up with one.
</p></dd></dl>

<a class="index-entry-id" id="index-local-part-of-remote-file-name"></a>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-file_002dlocal_002dname"><span class="category-def">Function: </span><span><strong class="def-name">file-local-name</strong> <var class="def-var-arguments">filename</var><a class="copiable-link" href="#index-file_002dlocal_002dname"> &para;</a></span></dt>
<dd><p>This function returns the <em class="dfn">local part</em> of <var class="var">filename</var>.  This is
the part of the file&rsquo;s name that identifies it on the remote host, and
is typically obtained by removing from the remote file name the parts
that specify the remote host and the method of accessing it.  For
example:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(file-local-name &quot;/ssh:<var class="var">user</var>@<var class="var">host</var>:/foo/bar&quot;)
     &rArr; &quot;/foo/bar&quot;
</pre></div>

<p>For a remote <var class="var">filename</var>, this function returns a file name which
could be used directly as an argument of a remote process
(see <a class="pxref" href="Asynchronous-Processes.html">Creating an Asynchronous Process</a>, and see <a class="pxref" href="Synchronous-Processes.html">Creating a Synchronous Process</a>),
and as the program to run on the remote host.  If <var class="var">filename</var> is
local, this function returns it unchanged.
</p></dd></dl>

<dl class="first-defvr first-defopt-alias-first-defvr">
<dt class="defvr defopt-alias-defvr" id="index-remote_002dfile_002dname_002dinhibit_002dcache"><span class="category-def">User Option: </span><span><strong class="def-name">remote-file-name-inhibit-cache</strong><a class="copiable-link" href="#index-remote_002dfile_002dname_002dinhibit_002dcache"> &para;</a></span></dt>
<dd><p>The attributes of remote files can be cached for better performance.  If
they are changed outside of Emacs&rsquo;s control, the cached values become
invalid, and must be reread.
</p>
<p>When this variable is set to <code class="code">nil</code>, cached values are never
expired.  Use this setting with caution, only if you are sure nothing
other than Emacs ever changes the remote files.  If it is set to
<code class="code">t</code>, cached values are never used.  This is the safest value, but
could result in performance degradation.
</p>
<p>A compromise is to set it to a positive number.  This means that
cached values are used for that amount of seconds since they were
cached.  If a remote file is checked regularly, it might be a good
idea to let-bind this variable to a value less than the time period
between consecutive checks.  For example:
</p>
<div class="example">
<pre class="example-preformatted">(defun display-time-file-nonempty-p (file)
  (let ((remote-file-name-inhibit-cache
         (- display-time-interval 5)))
    (and (file-exists-p file)
         (&lt; 0 (file-attribute-size
               (file-attributes
                (file-chase-links file)))))))
</pre></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-without_002dremote_002dfiles"><span class="category-def">Macro: </span><span><strong class="def-name">without-remote-files</strong> <var class="def-var-arguments">body&hellip;</var><a class="copiable-link" href="#index-without_002dremote_002dfiles"> &para;</a></span></dt>
<dd><p>The <code class="code">without-remote-files</code> macro evaluates the <var class="var">body</var> forms
with deactivated file name handlers for remote files.  Those file
names would be handled literally.
</p>
<p>The macro should be used only in forms where it is obvious, that
remote files cannot appear or where it is intended not to handle
remote file names.  It also reduces checks with
<code class="code">file-name-handler-alist</code>, resulting in more performant code.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Format-Conversion.html">File Format Conversion</a>, Previous: <a href="Create_002fDelete-Dirs.html">Creating, Copying and Deleting Directories</a>, Up: <a href="Files.html">Files</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
