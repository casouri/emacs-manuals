<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the GNU Emacs Manual,
updated for Emacs version 29.0.50.

Copyright Â© 1985-1987, 1993-2021 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto," "Distribution" and
"GNU GENERAL PUBLIC LICENSE," with the Front-Cover Texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Single Shell (GNU Emacs Manual)</title>

<meta name="description" content="Single Shell (GNU Emacs Manual)">
<meta name="keywords" content="Single Shell (GNU Emacs Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Key-Index.html" rel="index" title="Key Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Shell.html" rel="up" title="Shell">
<link href="Interactive-Shell.html" rel="next" title="Interactive Shell">
<link href="Shell.html" rel="prev" title="Shell">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<span id="Single-Shell"></span><div class="header">
<p>
Next: <a href="Interactive-Shell.html" accesskey="n" rel="next">Interactive Shell</a>, Up: <a href="Shell.html" accesskey="u" rel="up">Shell</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Single-Shell-Commands"></span><h3 class="section">38.1 Single Shell Commands</h3>

<span id="index-M_002d_0021"></span>
<span id="index-shell_002dcommand"></span>
<span id="index-shell_002dcommand_002dbuffer_002dname"></span>
<p><kbd>M-!</kbd> (<code>shell-command</code>) reads a line of text using the
minibuffer and executes it as a shell command, in a subshell made just
for that command.  Standard input for the command comes from the null
device.  If the shell command produces any output, the output appears
either in the echo area (if it is short), or in the &lsquo;<samp>&quot;*Shell
Command Output*&quot;</samp>&rsquo; (<code>shell-command-buffer-name</code>) buffer (if the
output is long).  The variables <code>resize-mini-windows</code> and
<code>max-mini-window-height</code> (see <a href="Minibuffer-Edit.html">Minibuffer Edit</a>) control when
Emacs should consider the output to be too long for the echo area.
</p>
<p>For instance, one way to decompress a file named <samp>foo.gz</samp> is to
type <kbd>M-! gunzip foo.gz <span class="key">RET</span></kbd>.  That shell command normally
creates the file <samp>foo</samp> and produces no terminal output.
</p>
<p>A numeric argument to <code>shell-command</code>, e.g., <kbd>M-1 M-!</kbd>,
causes it to insert terminal output into the current buffer instead of
a separate buffer.  By default, it puts point before the output, and
sets the mark after the output (but a non-default value of
<code>shell-command-dont-erase-buffer</code> can change that, see below).
For instance, <kbd>M-1 M-! gunzip &lt; foo.gz <span class="key">RET</span></kbd> would insert the
uncompressed form of the file <samp>foo.gz</samp> into the current buffer.
</p>
<p>Provided the specified shell command does not end with &lsquo;<samp>&amp;</samp>&rsquo;, it
runs <em>synchronously</em>, and you must wait for it to exit before
continuing to use Emacs.  To stop waiting, type <kbd>C-g</kbd> to quit;
this sends a <code>SIGINT</code> signal to terminate the shell command (this
is the same signal that <kbd>C-c</kbd> normally generates in the shell).
Emacs then waits until the command actually terminates.  If the shell
command doesn&rsquo;t stop (because it ignores the <code>SIGINT</code> signal),
type <kbd>C-g</kbd> again; this sends the command a <code>SIGKILL</code> signal,
which is impossible to ignore.
</p>
<span id="index-M_002d_0026"></span>
<span id="index-async_002dshell_002dcommand"></span>
<span id="index-shell_002dcommand_002dbuffer_002dname_002dasync"></span>
<p>A shell command that ends in &lsquo;<samp>&amp;</samp>&rsquo; is executed
<em>asynchronously</em>, and you can continue to use Emacs as it runs.
You can also type <kbd>M-&amp;</kbd> (<code>async-shell-command</code>) to execute a
shell command asynchronously; this is exactly like calling <kbd>M-!</kbd>
with a trailing &lsquo;<samp>&amp;</samp>&rsquo;, except that you do not need the &lsquo;<samp>&amp;</samp>&rsquo;.
The output from asynchronous shell commands, by default, goes into the
&lsquo;<samp>&quot;*Async Shell Command*&quot;</samp>&rsquo; buffer
(<code>shell-command-buffer-name-async</code>).  Emacs inserts the output
into this buffer as it comes in, whether or not the buffer is visible
in a window.
</p>
<span id="index-async_002dshell_002dcommand_002dbuffer"></span>
<p>If you want to run more than one asynchronous shell command at the
same time, they could end up competing for the output buffer.  The
option <code>async-shell-command-buffer</code> specifies what to do about
this; e.g., whether to rename the pre-existing output buffer, or to
use a different buffer for the new command.  Consult the variable&rsquo;s
documentation for more possibilities.
</p>
<span id="index-async_002dshell_002dcommand_002ddisplay_002dbuffer"></span>
<p>If you want the output buffer for asynchronous shell commands to be
displayed only when the command generates output, set
<code>async-shell-command-display-buffer</code> to <code>nil</code>.
</p>
<span id="index-async_002dshell_002dcommand_002dwidth"></span>
<p>The option <code>async-shell-command-width</code> defines the number of display
columns available for output of asynchronous shell commands.
A positive integer tells the shell to use that number of columns for
command output.  The default value is <code>nil</code> that means to use
the same number of columns as provided by the shell.
</p>
<span id="index-shell_002dcommand_002dprompt_002dshow_002dcwd"></span>
<p>To make the above commands show the current directory in their
prompts, customize the variable <code>shell-command-prompt-show-cwd</code>
to a non-<code>nil</code> value.
</p>
<span id="index-M_002d_007c"></span>
<span id="index-shell_002dcommand_002don_002dregion"></span>
<p><kbd>M-|</kbd> (<code>shell-command-on-region</code>) is like <kbd>M-!</kbd>, but
passes the contents of the region as the standard input to the shell
command, instead of no input.  With a numeric argument, it deletes the
old region and replaces it with the output from the shell command.
</p>
<p>For example, you can use <kbd>M-|</kbd> with the <code>gpg</code> program to
see what keys are in the buffer.  If the buffer contains a GnuPG key,
type <kbd>C-x h M-| gpg <span class="key">RET</span></kbd> to feed the entire buffer contents
to <code>gpg</code>.  This will output the list of keys to the
buffer whose name is the value of <code>shell-command-buffer-name</code>.
</p>
<span id="index-shell_002dfile_002dname"></span>
<span id="index-SHELL-environment-variable"></span>
<p>The above commands use the shell specified by the variable
<code>shell-file-name</code>.  Its default value is determined by the
<code>SHELL</code> environment variable when Emacs is started.  If the file
name is relative, Emacs searches the directories listed in
<code>exec-path</code> (see <a href="Shell.html">Shell</a>).
</p>
<p>If the default directory is remote (see <a href="Remote-Files.html">Remote Files</a>), the
default value is <samp>/bin/sh</samp>.  This can be changed by declaring
<code>shell-file-name</code> connection-local (see <a href="Connection-Variables.html">Connection Variables</a>).
</p>
<p>To specify a coding system for <kbd>M-!</kbd> or <kbd>M-|</kbd>, use the command
<kbd>C-x <span class="key">RET</span> c</kbd> immediately beforehand.  See <a href="Communication-Coding.html">Communication Coding</a>.
</p>
<span id="index-shell_002dcommand_002ddefault_002derror_002dbuffer"></span>
<p>By default, error output is intermixed with the regular output in
the output buffer.  But if you change the value of the variable
<code>shell-command-default-error-buffer</code> to a string, error output is
inserted into a buffer of that name.
</p>
<span id="index-shell_002dcommand_002ddont_002derase_002dbuffer"></span>
<p>By default, the output buffer is erased between shell commands, except
when the output goes to the current buffer.  If you change the value
of the option <code>shell-command-dont-erase-buffer</code> to <code>erase</code>,
then the output buffer is always erased.  Other non-<code>nil</code> values
prevent erasing of the output buffer, and&mdash;if the output buffer is
not the current buffer&mdash;also control where to put point after
inserting the output of the shell command:
</p>
<dl compact="compact">
<dt><code>beg-last-out</code></dt>
<dd><p>Puts point at the beginning of the last shell-command output.
</p></dd>
<dt><code>end-last-out</code></dt>
<dd><p>Puts point at the end of the last shell-command output, i.e. at the
end of the output buffer.
</p></dd>
<dt><code>save-point</code></dt>
<dd><p>Restores the position of point as it was before inserting the
shell-command output.
</p></dd>
</dl>

<hr>
<div class="header">
<p>
Next: <a href="Interactive-Shell.html" accesskey="n" rel="next">Interactive Shell</a>, Up: <a href="Shell.html" accesskey="u" rel="up">Shell</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
