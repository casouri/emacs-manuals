<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 31.0.50.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Child Frame Properties (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Child Frame Properties (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Child Frame Properties (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Child-Frames.html" rel="up" title="Child Frames">
<link href="Child-Frame-Peculiarities.html" rel="next" title="Child Frame Peculiarities">
<link href="Child-Frame-Operations.html" rel="prev" title="Child Frame Operations">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Child-Frame-Properties">
<div class="nav-panel">
<p>
Next: <a href="Child-Frame-Peculiarities.html" accesskey="n" rel="next">Child Frame Peculiarities</a>, Previous: <a href="Child-Frame-Operations.html" accesskey="p" rel="prev">Child Frame Operations</a>, Up: <a href="Child-Frames.html" accesskey="u" rel="up">Child Frames</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Child-Frame-Properties-1"><span>30.14.2 Child Frame Properties<a class="copiable-link" href="#Child-Frame-Properties-1"> &para;</a></span></h4>

<p>Most window-systems clip child frames at the native edges (see <a class="pxref" href="Frame-Geometry.html">Frame Geometry</a>) of their parent frame&mdash;everything outside these edges is
usually invisible.  A child frame&rsquo;s <code class="code">left</code> and <code class="code">top</code>
parameters specify a position relative to the top-left corner of its
parent&rsquo;s native frame.  When the parent frame is resized, this position
remains conceptually unaltered.
</p>
<p>NS builds and text terminals do not clip child frames at the parent
frame&rsquo;s edges, allowing them to be positioned so they do not obscure the
parent frame while still being visible themselves.
</p>
<p>Note also the function <code class="code">window-largest-empty-rectangle</code>
(see <a class="pxref" href="Coordinates-and-Windows.html">Coordinates and Windows</a>) which can be used to inscribe a child
frame in the largest empty area of an existing window.  This can be
useful to avoid that a child frame obscures any text shown in that
window.
</p>
<p>Usually, moving a parent frame moves along all its child frames and
their descendants as well, keeping their relative positions unaltered.
Note that the hook <code class="code">move-frame-functions</code> (see <a class="pxref" href="Frame-Position.html">Frame Position</a>)
is run for a child frame only when the position of the child frame
relative to its parent frame changes.
</p>
<p>When a parent frame is resized, its child frames conceptually retain
their previous sizes and their positions relative to the left upper
corner of the parent.  This means that a child frame may become
(partially) invisible when its parent frame shrinks.  The parameter
<code class="code">keep-ratio</code> (see <a class="pxref" href="Frame-Interaction-Parameters.html">Frame Interaction Parameters</a>) can be used to
resize and reposition a child frame proportionally whenever its parent
frame is resized.  This may avoid obscuring parts of a frame when its
parent frame is shrunk.
</p>
<p>A visible child frame always appears on top of its parent frame thus
obscuring parts of it, except on NS builds where it may be positioned
beneath the parent.  This is comparable to the window-system window of a
top-level frame which also always appears on top of its parent
window&mdash;the desktop&rsquo;s root window.  When a parent frame is iconified or
made invisible (see <a class="pxref" href="Visibility-of-Frames.html">Visibility of Frames</a>), any child frames
descending from it will not be shown either even if
<code class="code">frame-visible-p</code> returns <code class="code">t</code> for them.  When a parent frame
is deiconified or made visible, any child frames descending from it will
be shown again (provided they and all their ancestor frames are visible
too).  If a child frame is used as surrogate minibuffer frame
(see <a class="pxref" href="Minibuffers-and-Frames.html">Minibuffers and Frames</a>), it&rsquo;s up to the application to
guarantee the frame&rsquo;s visibility whenever the minibuffer is activated.
</p>
<p>Whether a child frame can have a menu or tool bar is window-system or
window manager dependent.  Most window-systems explicitly disallow menu
bars for child frames.  It seems advisable to disable both, menu and
tool bars, via the frame&rsquo;s initial parameters settings.  On a text
terminal, child frames use the menu bar of their root frame (provided it
has one).
</p>
<p>Usually, child frames do not exhibit window manager decorations like a
title bar or external borders (see <a class="pxref" href="Frame-Geometry.html">Frame Geometry</a>).  When the child
frame does not show a menu or tool bar, any other of the frame&rsquo;s borders
(see <a class="pxref" href="Layout-Parameters.html">Layout Parameters</a>) can be used instead of the external borders.
</p>
<p>In particular, under X (but not when building with GTK+), the frame&rsquo;s
outer border can be used.  On MS-Windows, specifying a non-zero outer
border width will show a one-pixel wide external border.  Under all
window-systems, the internal border can be used.  In either case, it&rsquo;s
advisable to disable a child frame&rsquo;s window manager decorations with the
<code class="code">undecorated</code> frame parameter (see <a class="pxref" href="Management-Parameters.html">Window Management Parameters</a>).  On
a text terminal, on the other hand, it&rsquo;s better to leave that parameter
alone so your child frame will be drawn with an outer border.
</p>
<p>To resize or move a border-less child frame with the mouse, special
frame parameters (see <a class="pxref" href="Mouse-Dragging-Parameters.html">Mouse Dragging Parameters</a>) have to be used.
The internal border of a child frame, if present, can be used to resize
the frame with the mouse, provided that frame has a non-<code class="code">nil</code>
<code class="code">drag-internal-border</code> parameter.  If set, the <code class="code">snap-width</code>
parameter indicates the number of pixels where the frame <em class="dfn">snaps</em> at
the respective edge or corner of its parent frame.  On a text terminal,
the outer border can used for resizing.
</p>
<p>There are two ways to drag an entire child frame with the mouse: The
<code class="code">drag-with-mode-line</code> parameter, if non-<code class="code">nil</code>, enables
dragging a frame without minibuffer window (see <a class="pxref" href="Minibuffer-Windows.html">Minibuffer Windows</a>) via the mode line area of its bottommost window.  The
<code class="code">drag-with-header-line</code> parameter, if non-<code class="code">nil</code>, enables
dragging the frame via the header line area of its topmost window.
</p>
<p>In order to give a child frame a draggable header or mode line, the
window parameters <code class="code">mode-line-format</code> and <code class="code">header-line-format</code>
are handy (see <a class="pxref" href="Window-Parameters.html">Window Parameters</a>).  These allow removing an
unwanted mode line (when <code class="code">drag-with-header-line</code> is chosen) and to
remove mouse-sensitive areas which might interfere with frame dragging.
</p>
<p>When the user drags a frame with a mouse and overshoots, it&rsquo;s easy
to drag a frame out of the screen area of its parent.  Retrieving such
a frame can be hairy once the mouse button has been released.  To
prevent such a situation, it is advisable to set the frame&rsquo;s
<code class="code">top-visible</code> or <code class="code">bottom-visible</code> parameter (see <a class="pxref" href="Mouse-Dragging-Parameters.html">Mouse Dragging Parameters</a>).
</p>
<p>Set the <code class="code">top-visible</code> parameter of a child frame to a number
when you intend to allow the user dragging that frame by its header
line.  Setting <code class="code">top-visible</code> to a number inhibits dragging the
top edge of the child frame above the top edge of its parent.  Set the
<code class="code">bottom-visible</code> parameter to a number when you intend to drag
that frame via its mode line; this inhibits dragging the bottom edge
of the child frame beneath the bottom edge of its parent.  In either
case, that number also specifies width and height (in pixels) of the
area of the child frame that remains visible during dragging.
</p>
<p>When a child frame is used for displaying a buffer via
<code class="code">display-buffer-in-child-frame</code> (see <a class="pxref" href="Buffer-Display-Action-Functions.html">Action Functions for Buffer Display</a>), the frame&rsquo;s <code class="code">auto-hide-function</code> parameter
(see <a class="pxref" href="Frame-Interaction-Parameters.html">Frame Interaction Parameters</a>) can be set to a function, in
order to appropriately deal with the frame when the window displaying
the buffer shall be quit.
</p>
<p>When a child frame is used during minibuffer interaction, for example,
to display completions in a separate window, the <code class="code">minibuffer-exit</code>
parameter (see <a class="pxref" href="Frame-Interaction-Parameters.html">Frame Interaction Parameters</a>) is useful in order to
deal with the frame when the minibuffer is exited.
</p>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Child-Frame-Peculiarities.html">Child Frame Peculiarities</a>, Previous: <a href="Child-Frame-Operations.html">Child Frame Operations</a>, Up: <a href="Child-Frames.html">Child Frames</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
