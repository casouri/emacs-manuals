<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 31.0.50.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Defining New Types (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Defining New Types (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Defining New Types (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Customization-Types.html" rel="up" title="Customization Types">
<link href="Type-Keywords.html" rel="prev" title="Type Keywords">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
kbd.key {font-style: normal}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Defining-New-Types">
<div class="nav-panel">
<p>
Previous: <a href="Type-Keywords.html" accesskey="p" rel="prev">Type Keywords</a>, Up: <a href="Customization-Types.html" accesskey="u" rel="up">Customization Types</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Defining-New-Types-1"><span>15.4.5 Defining New Types<a class="copiable-link" href="#Defining-New-Types-1"> &para;</a></span></h4>
<a class="index-entry-id" id="index-customization-types_002c-define-new"></a>
<a class="index-entry-id" id="index-define-new-customization-types"></a>

<p>In the previous sections we have described how to construct elaborate
type specifications for <code class="code">defcustom</code>.  In some cases you may want
to give such a type specification a name.  The obvious case is when
you are using the same type for many user options: rather than repeat
the specification for each option, you can give the type specification
a name, and use that name each <code class="code">defcustom</code>.  The other case is
when a user option&rsquo;s value is a recursive data structure.  To make it
possible for a datatype to refer to itself, it needs to have a name.
</p>
<p>Since custom types are implemented as widgets, the way to define a new
customize type is to define a new widget.  We are not going to describe
the widget interface here in details, see <a data-manual="widget" href="https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top">Introduction</a> in <cite class="cite">The Emacs Widget Library</cite>, for that.  Instead we are going to
demonstrate the minimal functionality needed for defining new customize
types by a simple example.
</p>
<div class="example">
<pre class="example-preformatted">(define-widget 'binary-tree-of-string 'lazy
  &quot;A binary tree made of cons-cells and strings.&quot;
  :offset 4
  :tag &quot;Node&quot;
  :type '(choice (string :tag &quot;Leaf&quot; :value &quot;&quot;)
                 (cons :tag &quot;Interior&quot;
                       :value (&quot;&quot; . &quot;&quot;)
                       binary-tree-of-string
                       binary-tree-of-string)))

(defcustom foo-bar &quot;&quot;
  &quot;Sample variable holding a binary tree of strings.&quot;
  :type 'binary-tree-of-string)
</pre></div>

<p>The function to define a new widget is called <code class="code">define-widget</code>.  The
first argument is the symbol we want to make a new widget type.  The
second argument is a symbol representing an existing widget, the new
widget is going to be defined in terms of difference from the existing
widget.  For the purpose of defining new customization types, the
<code class="code">lazy</code> widget is perfect, because it accepts a <code class="code">:type</code> keyword
argument with the same syntax as the keyword argument to
<code class="code">defcustom</code> with the same name.  The third argument is a
documentation string for the new widget.  You will be able to see that
string with the <kbd class="kbd">M-x widget-browse <kbd class="key">RET</kbd> binary-tree-of-string
<kbd class="key">RET</kbd></kbd> command.
</p>
<p>After these mandatory arguments follow the keyword arguments.  The most
important is <code class="code">:type</code>, which describes the data type we want to match
with this widget.  Here a <code class="code">binary-tree-of-string</code> is described as
being either a string, or a cons-cell whose car and cdr are themselves
both <code class="code">binary-tree-of-string</code>.  Note the reference to the widget
type we are currently in the process of defining.  The <code class="code">:tag</code>
is another important keyword argument because we are using the
<code class="code">lazy</code> widget for our new widget.  By default, the <code class="code">lazy</code>
widget doesn&rsquo;t have a tag, and in its absence the customization buffer
will show the entire widget&rsquo;s value (that is, the value of the user
option being customized).  Since that&rsquo;s almost never a good idea, we
provide a string to name the <code class="code">binary-tree-or-string</code> widget.  The
<code class="code">:offset</code> argument is there to ensure that child nodes are indented
four spaces relative to the parent node, making the tree structure
apparent in the customization buffer.
</p>
<p>The <code class="code">defcustom</code> shows how the new widget can be used as an ordinary
customization type.
</p>
<p>The reason for the name <code class="code">lazy</code> is that the other composite
widgets convert their inferior widgets to internal form when the
widget is instantiated in a buffer.  This conversion is recursive, so
the inferior widgets will convert <em class="emph">their</em> inferior widgets.  If
the data structure is itself recursive, this conversion is an infinite
recursion.  The <code class="code">lazy</code> widget prevents the recursion: it convert
its <code class="code">:type</code> argument only when needed.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Type-Keywords.html">Type Keywords</a>, Up: <a href="Customization-Types.html">Customization Types</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
