<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 31.0.50.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Parsing JSON (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Parsing JSON (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Parsing JSON (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Text.html" rel="up" title="Text">
<link href="JSONRPC.html" rel="next" title="JSONRPC">
<link href="Parsing-HTML_002fXML.html" rel="prev" title="Parsing HTML/XML">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Parsing-JSON">
<div class="nav-panel">
<p>
Next: <a href="JSONRPC.html" accesskey="n" rel="next">JSONRPC communication</a>, Previous: <a href="Parsing-HTML_002fXML.html" accesskey="p" rel="prev">Parsing HTML and XML</a>, Up: <a href="Text.html" accesskey="u" rel="up">Text</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Parsing-and-generating-JSON-values"><span>33.31 Parsing and generating JSON values<a class="copiable-link" href="#Parsing-and-generating-JSON-values"> &para;</a></span></h3>
<a class="index-entry-id" id="index-JSON"></a>
<a class="index-entry-id" id="index-JavaScript-Object-Notation"></a>

<p>The Emacs <abbr class="acronym">JSON</abbr> (<em class="dfn">JavaScript Object Notation</em>) support
provides several functions to convert between Lisp objects and JSON
values.  Any JSON value can be converted to a Lisp object, but not vice
versa.  Specifically:
</p>
<ul class="itemize mark-bullet">
<li>JSON uses three keywords: <code class="code">true</code>, <code class="code">null</code>, <code class="code">false</code>.
<code class="code">true</code> is represented by the symbol <code class="code">t</code>.  By default, the
remaining two are represented, respectively, by the symbols
<code class="code">:null</code> and <code class="code">:false</code>.

</li><li>JSON only has floating-point numbers.  They can represent both Lisp
integers and Lisp floating-point numbers.

</li><li>JSON strings are always Unicode strings encoded in UTF-8.  Lisp
strings can contain non-Unicode characters.

</li><li>JSON has only one sequence type, the array.  JSON arrays are
represented using Lisp vectors.

</li><li>JSON has only one map type, the object.  JSON objects are represented
using Lisp hashtables, alists or plists.  When an alist or plist
contains several elements with the same key, Emacs uses only the first
element for serialization, in accordance with the behavior of
<code class="code">assq</code>.
</li></ul>

<p>Note that <code class="code">nil</code>, being both a valid alist and a valid plist,
represents <code class="code">{}</code>, the empty JSON object; not <code class="code">null</code>,
<code class="code">false</code>, or an empty array, all of which are different JSON
values.
</p>
<p>If some Lisp object can&rsquo;t be represented in JSON, the serialization
functions will signal an error of type <code class="code">wrong-type-argument</code>.
The parsing functions can also signal the following errors:
</p>
<dl class="table">
<dt><code class="code">json-unavailable</code></dt>
<dd><p>Signaled when the parsing library isn&rsquo;t available.
</p>
</dd>
<dt><code class="code">json-end-of-file</code></dt>
<dd><p>Signaled when encountering a premature end of the input text.
</p>
</dd>
<dt><code class="code">json-trailing-content</code></dt>
<dd><p>Signaled when encountering unexpected input after the first JSON
object parsed.
</p>
</dd>
<dt><code class="code">json-parse-error</code></dt>
<dd><p>Signaled when encountering invalid JSON syntax.
</p></dd>
</dl>

<p>Top-level values and the subobjects within these top-level values
can be serialized to JSON.  Likewise, the parsing functions will
return any of the possible types described above.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-json_002dserialize"><span class="category-def">Function: </span><span><strong class="def-name">json-serialize</strong> <var class="def-var-arguments">object &amp;rest args</var><a class="copiable-link" href="#index-json_002dserialize"> &para;</a></span></dt>
<dd><p>This function returns a new Lisp unibyte string which contains the JSON
representation of <var class="var">object</var>.  The argument <var class="var">args</var> is a list of
keyword/argument pairs.  The following keywords are accepted:
</p>
<dl class="table">
<dt><code class="code">:null-object</code></dt>
<dd><p>The value decides which Lisp object to use to represent the JSON
keyword <code class="code">null</code>.  It defaults to the symbol <code class="code">:null</code>.
</p>
</dd>
<dt><code class="code">:false-object</code></dt>
<dd><p>The value decides which Lisp object to use to represent the JSON
keyword <code class="code">false</code>.  It defaults to the symbol <code class="code">:false</code>.
</p></dd>
</dl>

</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-json_002dinsert"><span class="category-def">Function: </span><span><strong class="def-name">json-insert</strong> <var class="def-var-arguments">object &amp;rest args</var><a class="copiable-link" href="#index-json_002dinsert"> &para;</a></span></dt>
<dd><p>This function inserts the JSON representation of <var class="var">object</var> into the
current buffer before point.  The argument <var class="var">args</var> are interpreted
as in <code class="code">json-serialize</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-json_002dparse_002dstring"><span class="category-def">Function: </span><span><strong class="def-name">json-parse-string</strong> <var class="def-var-arguments">string &amp;rest args</var><a class="copiable-link" href="#index-json_002dparse_002dstring"> &para;</a></span></dt>
<dd><p>This function parses the JSON value in <var class="var">string</var>, which must be a
Lisp string.  If <var class="var">string</var> doesn&rsquo;t contain a valid JSON object,
this function signals the <code class="code">json-parse-error</code> error.
</p>
<p>The argument <var class="var">args</var> is a list of keyword/argument pairs.  The
following keywords are accepted:
</p>
<dl class="table">
<dt><code class="code">:object-type</code></dt>
<dd><p>The value decides which Lisp object to use for representing the
key-value mappings of a JSON object.  It can be either
<code class="code">hash-table</code>, the default, to make hashtables with strings as
keys; <code class="code">alist</code> to use alists with symbols as keys; or <code class="code">plist</code>
to use plists with keyword symbols as keys.
</p>
</dd>
<dt><code class="code">:array-type</code></dt>
<dd><p>The value decides which Lisp object to use for representing a JSON
array.  It can be either <code class="code">array</code>, the default, to use Lisp
arrays; or <code class="code">list</code> to use lists.
</p>
</dd>
<dt><code class="code">:null-object</code></dt>
<dd><p>The value decides which Lisp object to use to represent the JSON
keyword <code class="code">null</code>.  It defaults to the symbol <code class="code">:null</code>.
</p>
</dd>
<dt><code class="code">:false-object</code></dt>
<dd><p>The value decides which Lisp object to use to represent the JSON
keyword <code class="code">false</code>.  It defaults to the symbol <code class="code">:false</code>.
</p></dd>
</dl>

</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-json_002dparse_002dbuffer"><span class="category-def">Function: </span><span><strong class="def-name">json-parse-buffer</strong> <var class="def-var-arguments">&amp;rest args</var><a class="copiable-link" href="#index-json_002dparse_002dbuffer"> &para;</a></span></dt>
<dd><p>This function reads the next JSON value from the current buffer,
starting at point.  It moves point to the position immediately after
the value if contains a valid JSON object; otherwise it signals the
<code class="code">json-parse-error</code> error and doesn&rsquo;t move point.  The arguments
<var class="var">args</var> are interpreted as in <code class="code">json-parse-string</code>.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="JSONRPC.html">JSONRPC communication</a>, Previous: <a href="Parsing-HTML_002fXML.html">Parsing HTML and XML</a>, Up: <a href="Text.html">Text</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
