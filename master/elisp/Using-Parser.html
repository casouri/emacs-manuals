<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 31.0.50.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Using Parser (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Using Parser (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Using Parser (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-Program-Source.html" rel="up" title="Parsing Program Source">
<link href="Retrieving-Nodes.html" rel="next" title="Retrieving Nodes">
<link href="Language-Grammar.html" rel="prev" title="Language Grammar">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Using-Parser">
<div class="nav-panel">
<p>
Next: <a href="Retrieving-Nodes.html" accesskey="n" rel="next">Retrieving Nodes</a>, Previous: <a href="Language-Grammar.html" accesskey="p" rel="prev">Tree-sitter Language Grammar</a>, Up: <a href="Parsing-Program-Source.html" accesskey="u" rel="up">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Using-Tree_002dsitter-Parser"><span>38.2 Using Tree-sitter Parser<a class="copiable-link" href="#Using-Tree_002dsitter-Parser"> &para;</a></span></h3>
<a class="index-entry-id" id="index-tree_002dsitter-parser_002c-using"></a>

<p>This section describes how to create and configure a tree-sitter
parser.  In Emacs, each tree-sitter parser is associated with a
buffer.  As the user edits the buffer, the associated parser and
syntax tree are automatically kept up-to-date.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-treesit_002dmax_002dbuffer_002dsize"><span class="category-def">Variable: </span><span><strong class="def-name">treesit-max-buffer-size</strong><a class="copiable-link" href="#index-treesit_002dmax_002dbuffer_002dsize"> &para;</a></span></dt>
<dd><p>This variable contains the maximum size of buffers in which
tree-sitter can be activated.  Major modes should check this value
when deciding whether to enable tree-sitter features.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-treesit_002dlanguages_002drequire_002dline_002dcolumn_002dtracking"><span class="category-def">Variable: </span><span><strong class="def-name">treesit-languages-require-line-column-tracking</strong><a class="copiable-link" href="#index-treesit_002dlanguages_002drequire_002dline_002dcolumn_002dtracking"> &para;</a></span></dt>
<dd><p>Emacs by default doesn&rsquo;t keep track of line and column numbers for
positions in a buffer.  However, some language grammars utilize the line
and column information for parsing.  If parsers of these languages are
created in a buffer, Emacs will turn on line and column tracking and
report these information to these parsers.  Once the buffer starts
tracking line and column, it never stops doing so.  And once a parser is
created as tracking/not-tracking line and column, it stays that way
regardless of changes to this variable.
</p>
<p>This variable is a list of languages that require line and column
tracking.  The vast majority of languages don&rsquo;t need line and column
information.  So far, only Haskell is known to need it.
</p>
<a class="index-entry-id" id="index-treesit_002dtracking_002dline_002dcolumn_002dp"></a>
<a class="index-entry-id" id="index-treesit_002dparser_002dtracking_002dline_002dcolumn_002dp"></a>
<p>User can use <code class="code">treesit-tracking-line-column-p</code> and
<code class="code">treesit-parser-tracking-line-column-p</code> to check if a buffer or
parser is tracking line and column, respectively.
</p></dd></dl>

<a class="index-entry-id" id="index-creating-tree_002dsitter-parsers"></a>
<a class="index-entry-id" id="index-tree_002dsitter-parser_002c-creating"></a>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dcreate"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-create</strong> <var class="def-var-arguments">language &amp;optional buffer no-reuse tag</var><a class="copiable-link" href="#index-treesit_002dparser_002dcreate"> &para;</a></span></dt>
<dd><p>Create a parser for the specified <var class="var">buffer</var> and <var class="var">language</var>
(see <a class="pxref" href="Language-Grammar.html">Tree-sitter Language Grammar</a>), with <var class="var">tag</var>.  If <var class="var">buffer</var> is
omitted or <code class="code">nil</code>, it stands for the current buffer.
</p>
<p>By default, this function reuses a parser if one already exists for
<var class="var">language</var> with <var class="var">tag</var> in <var class="var">buffer</var>, but if <var class="var">no-reuse</var>
is non-<code class="code">nil</code>, this function always creates a new parser.
</p>
<p><var class="var">tag</var> can be any symbol except <code class="code">t</code>, and defaults to
<code class="code">nil</code>.  Different parsers can have the same tag.
</p></dd></dl>

<p>Given a parser, we can query information about it.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dbuffer"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-buffer</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002dbuffer"> &para;</a></span></dt>
<dd><p>This function returns the buffer associated with <var class="var">parser</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dlanguage"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-language</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002dlanguage"> &para;</a></span></dt>
<dd><p>This function returns the language used by <var class="var">parser</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dp"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-p</strong> <var class="def-var-arguments">object</var><a class="copiable-link" href="#index-treesit_002dparser_002dp"> &para;</a></span></dt>
<dd><p>This function checks if <var class="var">object</var> is a tree-sitter parser, and
returns non-<code class="code">nil</code> if it is, and <code class="code">nil</code> otherwise.
</p></dd></dl>

<p>There is no need to explicitly parse a buffer, because parsing is done
automatically and lazily.  A parser only parses when a Lisp program
queries for a node in its syntax tree.  Therefore, when a parser is
first created, it doesn&rsquo;t parse the buffer; it waits until the Lisp
program queries for a node for the first time.  Similarly, when some
change is made in the buffer, a parser doesn&rsquo;t re-parse immediately.
</p>
<a class="index-entry-id" id="index-treesit_002dbuffer_002dtoo_002dlarge"></a>
<p>When a parser does parse, it checks for the size of the buffer.
Tree-sitter can only handle buffers no larger than about 4GB.  If the
size exceeds that, Emacs signals the <code class="code">treesit-buffer-too-large</code>
error with signal data being the buffer size.
</p>
<p>Once a parser is created, Emacs automatically adds it to the
internal parser list.  Every time a change is made to the buffer,
Emacs updates parsers in this list so they can update their syntax
tree incrementally.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dlist"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-list</strong> <var class="def-var-arguments">&amp;optional buffer language tag</var><a class="copiable-link" href="#index-treesit_002dparser_002dlist"> &para;</a></span></dt>
<dd><p>This function returns the parser list of <var class="var">buffer</var>, filtered by
<var class="var">language</var> and <var class="var">tag</var>.  If <var class="var">buffer</var> is <code class="code">nil</code> or
omitted, it defaults to the current buffer.
</p>
<p>If <var class="var">language</var> is non-<var class="var">nil</var>, only include parsers for that
language, and only include parsers with <var class="var">tag</var>.  <var class="var">tag</var> defaults
to <code class="code">nil</code>.  If <var class="var">tag</var> is <code class="code">t</code>, include parsers in the
returned list regardless of their tag.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002ddelete"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-delete</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002ddelete"> &para;</a></span></dt>
<dd><p>This function deletes <var class="var">parser</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-tree_002dsitter-narrowing"></a>
<a class="anchor" id="tree_002dsitter-narrowing"></a><p>Normally, a parser &ldquo;sees&rdquo; the whole buffer, but when the buffer is
narrowed (see <a class="pxref" href="Narrowing.html">Narrowing</a>), the parser will only see the accessible
portion of the buffer.  As far as the parser can tell, the hidden
region was deleted.  When the buffer is later widened, the parser
thinks text is inserted at the beginning and at the end.  Although
parsers respect narrowing, modes should not use narrowing as a means
to handle a multi-language buffer; instead, set the ranges in which the
parser should operate.  See <a class="xref" href="Multiple-Languages.html">Parsing Text in Multiple Languages</a>.
</p>
<p>Because a parser parses lazily, when the user or a Lisp program
narrows the buffer, the parser is not affected immediately; as long as
the mode doesn&rsquo;t query for a node while the buffer is narrowed, the
parser is oblivious of the narrowing.
</p>
<a class="index-entry-id" id="index-tree_002dsitter-parse-string"></a>
<a class="index-entry-id" id="index-parse-string_002c-tree_002dsitter"></a>
<p>Besides creating a parser for a buffer, a Lisp program can also parse a
string.  Unlike a buffer, parsing a string is a one-off operation, and
there is no way to update the result.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparse_002dstring"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parse-string</strong> <var class="def-var-arguments">string language</var><a class="copiable-link" href="#index-treesit_002dparse_002dstring"> &para;</a></span></dt>
<dd><p>This function parses <var class="var">string</var> using <var class="var">language</var>, and returns the
root node of the generated syntax tree.  <em class="emph">Do not</em> use this function
in a loop: this is a convenience function intended for one-off use, and
it isn&rsquo;t optimized; for heavy workload, use a temporary buffer instead.
</p></dd></dl>

<h3 class="heading" id="Be-notified-by-changes-to-the-parse-tree"><span>Be notified by changes to the parse tree<a class="copiable-link" href="#Be-notified-by-changes-to-the-parse-tree"> &para;</a></span></h3>
<a class="index-entry-id" id="index-update-callback_002c-for-tree_002dsitter-parse_002dtree"></a>
<a class="index-entry-id" id="index-after_002dchange-notifier_002c-for-tree_002dsitter-parse_002dtree"></a>
<a class="index-entry-id" id="index-tree_002dsitter-parse_002dtree_002c-update-and-after_002dchange-callback"></a>
<a class="index-entry-id" id="index-notifiers_002c-tree_002dsitter"></a>

<p>A Lisp program might want to be notified of text affected by
incremental parsing.  For example, inserting a comment-closing token
converts text before that token into a comment.  Even
though the text is not directly edited, it is deemed to be &ldquo;changed&rdquo;
nevertheless.
</p>
<p>Emacs lets a Lisp program register callback functions (a.k.a.
<em class="dfn">notifiers</em>) for these kinds of changes.  A notifier function
takes two arguments: <var class="var">ranges</var> and <var class="var">parser</var>.  <var class="var">ranges</var> is a
list of cons cells of the form <code class="code">(<var class="var">start</var>&nbsp;.&nbsp;<var class="var">end</var>)</code><!-- /@w -->,
where <var class="var">start</var> and <var class="var">end</var> mark the start and the end positions
of a range.  <var class="var">parser</var> is the parser issuing the notification.
</p>
<p>Every time a parser reparses a buffer, it compares the old and new
parse-tree, computes the ranges in which nodes have changed, and
passes the ranges to notifier functions.  Note that the initial parse
is also considered a &ldquo;change&rdquo;, so notifier functions are called on
the initial parse, with range being the whole buffer.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dadd_002dnotifier"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-add-notifier</strong> <var class="def-var-arguments">parser function</var><a class="copiable-link" href="#index-treesit_002dparser_002dadd_002dnotifier"> &para;</a></span></dt>
<dd><p>This function adds <var class="var">function</var> to <var class="var">parser</var>&rsquo;s list of
after-change notifier functions.  <var class="var">function</var> must be a function
symbol, not a lambda function (see <a class="pxref" href="Anonymous-Functions.html">Anonymous Functions</a>).
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dremove_002dnotifier"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-remove-notifier</strong> <var class="def-var-arguments">parser function</var><a class="copiable-link" href="#index-treesit_002dparser_002dremove_002dnotifier"> &para;</a></span></dt>
<dd><p>This function removes <var class="var">function</var> from the list of <var class="var">parser</var>&rsquo;s
after-change notifier functions.  <var class="var">function</var> must be a function
symbol, rather than a lambda function.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dnotifiers"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-notifiers</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002dnotifiers"> &para;</a></span></dt>
<dd><p>This function returns the list of <var class="var">parser</var>&rsquo;s notifier functions.
</p></dd></dl>

<p>A lisp program can also choose to force a parser to reparse and get the
changed regions immediately with <code class="code">treesit-parser-changed-regions</code>.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dchanged_002dregions"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-changed-regions</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002dchanged_002dregions"> &para;</a></span></dt>
<dd><p>This function forces <var class="var">parser</var> to reparse, and returns the affected
regions: a list of <code class="code">(<var class="var">start</var>&nbsp;.&nbsp;<var class="var">end</var>)</code><!-- /@w -->.  If the parser
has nothing new to reparse, or the affected regions are empty, this
function returns <code class="code">nil</code>.
</p></dd></dl>


<h3 class="heading" id="Substitute-parser-for-another-language"><span>Substitute parser for another language<a class="copiable-link" href="#Substitute-parser-for-another-language"> &para;</a></span></h3>
<a class="index-entry-id" id="index-remap-language-grammar_002c-tree_002dsitter"></a>
<a class="index-entry-id" id="index-replace-language-grammar_002c-tree_002dsitter"></a>
<a class="index-entry-id" id="index-replace-parser-language_002c-tree_002dsitter"></a>
<a class="index-entry-id" id="index-extended-grammar_002c-tree_002dsitter"></a>

<p>Sometimes, a grammar for language B is a strict superset of the grammar
of another language A.  Then it makes sense to reuse configurations
(font-lock rules, indentation rules, etc.) of language A for language B.
For that purpose, <var class="var">treesit-language-remap-alist</var> allows users to
remap language A into language B.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-treesit_002dlanguage_002dremap_002dalist"><span class="category-def">Variable: </span><span><strong class="def-name">treesit-language-remap-alist</strong><a class="copiable-link" href="#index-treesit_002dlanguage_002dremap_002dalist"> &para;</a></span></dt>
<dd><p>The value of this variable should be an alist of
<code class="code">(<var class="var">language-a</var>&nbsp;.&nbsp;<var class="var">language-b</var>)</code><!-- /@w -->.  When such pair exists
in the alist, creating a parser for <var class="var">language-a</var> actually creates a
parser for <var class="var">language-b</var>.  By extension, anything that creates a node
or makes a query of <var class="var">language-a</var> will be redirected to use
<var class="var">language-b</var> instead.  This mapping is completely transparent, the
created parser will reported to use <var class="var">language-b</var>, and the same goes for
nodes created by this parser.
</p>
<p>Specifically, the parser created by <code class="code">treesit-parser-create</code> will
report to use whatever <var class="var">language</var> was given to it.  For example,
if language <code class="code">cpp</code> is mapped to <code class="code">cuda</code>:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(setq treesit-language-remap-alist '((cpp . cuda)))

(treesit-parser-language (treesit-parser-create 'cpp))
  &rArr; 'cpp

(treesit-parser-language (treesit-parser-create 'cuda))
  &rArr; 'cuda
</pre></div></div>

<p>Even though both parser are actually <code class="code">cuda</code> parser.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Retrieving-Nodes.html">Retrieving Nodes</a>, Previous: <a href="Language-Grammar.html">Tree-sitter Language Grammar</a>, Up: <a href="Parsing-Program-Source.html">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
