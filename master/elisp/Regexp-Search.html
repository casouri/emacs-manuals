<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 31.0.50.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Regexp Search (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Regexp Search (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Regexp Search (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Searching-and-Matching.html" rel="up" title="Searching and Matching">
<link href="Longest-Match.html" rel="next" title="Longest Match">
<link href="Regular-Expressions.html" rel="prev" title="Regular Expressions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Regexp-Search">
<div class="nav-panel">
<p>
Next: <a href="Longest-Match.html" accesskey="n" rel="next">Longest-match searching for regular expression matches</a>, Previous: <a href="Regular-Expressions.html" accesskey="p" rel="prev">Regular Expressions</a>, Up: <a href="Searching-and-Matching.html" accesskey="u" rel="up">Searching and Matching</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Regular-Expression-Searching"><span>35.4 Regular Expression Searching<a class="copiable-link" href="#Regular-Expression-Searching"> &para;</a></span></h3>
<a class="index-entry-id" id="index-regular-expression-searching"></a>
<a class="index-entry-id" id="index-regexp-searching"></a>
<a class="index-entry-id" id="index-searching-for-regexp"></a>

<p>In GNU Emacs, you can search for the next match for a regular
expression (see <a class="pxref" href="Syntax-of-Regexps.html">Syntax of Regular Expressions</a>) either incrementally or not.
For incremental search commands, see <a data-manual="emacs" href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search">Regular
Expression Search</a> in <cite class="cite">The GNU Emacs Manual</cite>.  Here we describe
only the search functions useful in programs.  The principal one is
<code class="code">re-search-forward</code>.
</p>
<p>These search functions convert the regular expression to multibyte if
the buffer is multibyte; they convert the regular expression to unibyte
if the buffer is unibyte.  See <a class="xref" href="Text-Representations.html">Text Representations</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-re_002dsearch_002dforward"><span class="category-def">Command: </span><span><strong class="def-name">re-search-forward</strong> <var class="def-var-arguments">regexp &amp;optional limit noerror count</var><a class="copiable-link" href="#index-re_002dsearch_002dforward"> &para;</a></span></dt>
<dd><p>This function searches forward in the current buffer for a string of
text that is matched by the regular expression <var class="var">regexp</var>.  The
function skips over any amount of text that is not matched by
<var class="var">regexp</var>, and leaves point at the end of the first match found.
It returns the new value of point.
</p>
<p>If <var class="var">limit</var> is non-<code class="code">nil</code>, it must be a position in the current
buffer.  It specifies the upper bound to the search.  No match
extending after that position is accepted.  If <var class="var">limit</var> is omitted
or <code class="code">nil</code>, it defaults to the end of the accessible portion of the
buffer.
</p>
<p>What <code class="code">re-search-forward</code> does when the search fails depends on
the value of <var class="var">noerror</var>:
</p>
<dl class="table">
<dt><code class="code">nil</code></dt>
<dd><p>Signal a <code class="code">search-failed</code> error.
</p></dd>
<dt><code class="code">t</code></dt>
<dd><p>Do nothing and return <code class="code">nil</code>.
</p></dd>
<dt>anything else</dt>
<dd><p>Move point to <var class="var">limit</var> (or the end of the accessible portion of the
buffer) and return <code class="code">nil</code>.
</p></dd>
</dl>

<p>The argument <var class="var">noerror</var> only affects valid searches which fail to
find a match.  Invalid arguments cause errors regardless of
<var class="var">noerror</var>.
</p>
<p>If <var class="var">count</var> is a positive number <var class="var">n</var>, the search is done
<var class="var">n</var> times; each successive search starts at the end of the
previous match.  If all these successive searches succeed, the
function call succeeds, moving point and returning its new value.
Otherwise the function call fails, with results depending on the value
of <var class="var">noerror</var>, as described above.  If <var class="var">count</var> is a negative
number &minus;<var class="var">n</var>, the search is done <var class="var">n</var> times in the opposite
(backward) direction.
</p>
<p>In the following example, point is initially before the &lsquo;<samp class="samp">T</samp>&rsquo;.
Evaluating the search call moves point to the end of that line (between
the &lsquo;<samp class="samp">t</samp>&rsquo; of &lsquo;<samp class="samp">hat</samp>&rsquo; and the newline).
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">---------- Buffer: foo ----------
I read &quot;&lowast;The cat in the hat
comes back&quot; twice.
---------- Buffer: foo ----------
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(re-search-forward &quot;[a-z]+&quot; nil t 5)
     &rArr; 27

---------- Buffer: foo ----------
I read &quot;The cat in the hat&lowast;
comes back&quot; twice.
---------- Buffer: foo ----------
</pre></div></div>
</dd></dl>

<a class="anchor" id="re_002dsearch_002dbackward"></a><dl class="first-deffn">
<dt class="deffn" id="index-re_002dsearch_002dbackward"><span class="category-def">Command: </span><span><strong class="def-name">re-search-backward</strong> <var class="def-var-arguments">regexp &amp;optional limit noerror count</var><a class="copiable-link" href="#index-re_002dsearch_002dbackward"> &para;</a></span></dt>
<dd><p>This function searches backward in the current buffer for a string of
text that is matched by the regular expression <var class="var">regexp</var>, leaving
point at the beginning of the first text found.
</p>
<p>This function is analogous to <code class="code">re-search-forward</code>, but they are not
simple mirror images.  <code class="code">re-search-forward</code> finds the match whose
beginning is as close as possible to the starting point.  If
<code class="code">re-search-backward</code> were a perfect mirror image, it would find the
match whose end is as close as possible.  However, in fact it finds the
match whose beginning is as close as possible (and yet ends before the
starting point).  The reason for this is that matching a regular
expression at a given spot always works from beginning to end, and
starts at a specified beginning position.
</p>
<p>A true mirror-image of <code class="code">re-search-forward</code> would require a special
feature for matching regular expressions from end to beginning.  It&rsquo;s
not worth the trouble of implementing that.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-string_002dmatch"><span class="category-def">Function: </span><span><strong class="def-name">string-match</strong> <var class="def-var-arguments">regexp string &amp;optional start inhibit-modify</var><a class="copiable-link" href="#index-string_002dmatch"> &para;</a></span></dt>
<dd><p>This function returns the index of the start of the first match for
the regular expression <var class="var">regexp</var> in <var class="var">string</var>, or <code class="code">nil</code> if
there is no match.  If <var class="var">start</var> is non-<code class="code">nil</code>, the search starts
at that index in <var class="var">string</var>.
</p>
<p>For example,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(string-match
 &quot;quick&quot; &quot;The quick brown fox jumped quickly.&quot;)
     &rArr; 4
</pre></div><div class="group"><pre class="example-preformatted">(string-match
 &quot;quick&quot; &quot;The quick brown fox jumped quickly.&quot; 8)
     &rArr; 27
</pre></div></div>

<p>The index of the first character of the
string is 0, the index of the second character is 1, and so on.
</p>
<p>By default, if this function finds a match, the index of the first
character beyond the match is available as <code class="code">(match-end 0)</code>.
See <a class="xref" href="Match-Data.html">The Match Data</a>.  If <var class="var">inhibit-modify</var> is non-<code class="code">nil</code>, the
match data isn&rsquo;t modified.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(string-match
 &quot;quick&quot; &quot;The quick brown fox jumped quickly.&quot; 8)
     &rArr; 27
</pre></div><pre class="example-preformatted">

</pre><div class="group"><pre class="example-preformatted">(match-end 0)
     &rArr; 32
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-string_002dmatch_002dp"><span class="category-def">Function: </span><span><strong class="def-name">string-match-p</strong> <var class="def-var-arguments">regexp string &amp;optional start</var><a class="copiable-link" href="#index-string_002dmatch_002dp"> &para;</a></span></dt>
<dd><p>This predicate function does what <code class="code">string-match</code> does, but it
avoids modifying the match data.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-looking_002dat"><span class="category-def">Function: </span><span><strong class="def-name">looking-at</strong> <var class="def-var-arguments">regexp &amp;optional inhibit-modify</var><a class="copiable-link" href="#index-looking_002dat"> &para;</a></span></dt>
<dd><p>This function determines whether the text in the current buffer directly
following point matches the regular expression <var class="var">regexp</var>.  &ldquo;Directly
following&rdquo; means precisely that: the search is &ldquo;anchored&rdquo; and it can
succeed only starting with the first character following point.  The
result is <code class="code">t</code> if so, <code class="code">nil</code> otherwise.
</p>
<p>This function does not move point, but it does update the match data
(if <var class="var">inhibit-modify</var> is <code class="code">nil</code> or missing, which is the
default).  See <a class="xref" href="Match-Data.html">The Match Data</a>.  As a convenience, instead of using the
<var class="var">inhibit-modify</var> argument, you can use <code class="code">looking-at-p</code>,
described below.
</p>
<p>In this example, point is located directly before the &lsquo;<samp class="samp">T</samp>&rsquo;.  If it
were anywhere else, the result would be <code class="code">nil</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">---------- Buffer: foo ----------
I read &quot;&lowast;The cat in the hat
comes back&quot; twice.
---------- Buffer: foo ----------

(looking-at &quot;The cat in the hat$&quot;)
     &rArr; t
</pre></div></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-looking_002dback"><span class="category-def">Function: </span><span><strong class="def-name">looking-back</strong> <var class="def-var-arguments">regexp limit &amp;optional greedy</var><a class="copiable-link" href="#index-looking_002dback"> &para;</a></span></dt>
<dd><p>This function returns <code class="code">t</code> if <var class="var">regexp</var> matches the text
immediately before point (i.e., ending at point), and <code class="code">nil</code> otherwise.
</p>
<p>Because regular expression matching works only going forward, this is
implemented by searching backwards from point for a match that ends at
point.  That can be quite slow if it has to search a long distance.
You can bound the time required by specifying a non-<code class="code">nil</code> value
for <var class="var">limit</var>, which says not to search before <var class="var">limit</var>.  In this
case, the match that is found must begin at or after <var class="var">limit</var>.
Here&rsquo;s an example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">---------- Buffer: foo ----------
I read &quot;&lowast;The cat in the hat
comes back&quot; twice.
---------- Buffer: foo ----------

(looking-back &quot;read \&quot;&quot; 3)
     &rArr; t
(looking-back &quot;read \&quot;&quot; 4)
     &rArr; nil
</pre></div></div>

<p>If <var class="var">greedy</var> is non-<code class="code">nil</code>, this function extends the match
backwards as far as possible, stopping when a single additional
previous character cannot be part of a match for <var class="var">regexp</var>.  When
the match is extended, its starting position is allowed to occur
before <var class="var">limit</var>.
</p>
<p>As a general recommendation, try to avoid using <code class="code">looking-back</code>
wherever possible, since it is slow.  For this reason, there are no
plans to add a <code class="code">looking-back-p</code> function.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-looking_002dat_002dp"><span class="category-def">Function: </span><span><strong class="def-name">looking-at-p</strong> <var class="def-var-arguments">regexp</var><a class="copiable-link" href="#index-looking_002dat_002dp"> &para;</a></span></dt>
<dd><p>This predicate function works like <code class="code">looking-at</code>, but without
updating the match data.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-search_002dspaces_002dregexp"><span class="category-def">Variable: </span><span><strong class="def-name">search-spaces-regexp</strong><a class="copiable-link" href="#index-search_002dspaces_002dregexp"> &para;</a></span></dt>
<dd><p>If this variable is non-<code class="code">nil</code>, it should be a regular expression
that says how to search for whitespace.  In that case, any group of
spaces in a regular expression being searched for stands for use of
this regular expression.  However, spaces inside of constructs such as
&lsquo;<samp class="samp">[&hellip;]</samp>&rsquo; and &lsquo;<samp class="samp">*</samp>&rsquo;, &lsquo;<samp class="samp">+</samp>&rsquo;, &lsquo;<samp class="samp">?</samp>&rsquo; are not affected by
<code class="code">search-spaces-regexp</code>.
</p>
<p>Since this variable affects all regular expression search and match
constructs, you should bind it temporarily for as small as possible
a part of the code, and only where the Lisp code affected by the
binding performs searches whose regexp was produced from interactive
user input.  In other words, this variable should only be used to tell
regexp search primitives how to interpret whitespace typed by the
user.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Longest-Match.html">Longest-match searching for regular expression matches</a>, Previous: <a href="Regular-Expressions.html">Regular Expressions</a>, Up: <a href="Searching-and-Matching.html">Searching and Matching</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
