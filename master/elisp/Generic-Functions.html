<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 31.0.50.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Generic Functions (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Generic Functions (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Generic Functions (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Functions.html" rel="up" title="Functions">
<link href="Function-Cells.html" rel="next" title="Function Cells">
<link href="Anonymous-Functions.html" rel="prev" title="Anonymous Functions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Generic-Functions">
<div class="nav-panel">
<p>
Next: <a href="Function-Cells.html" accesskey="n" rel="next">Accessing Function Cell Contents</a>, Previous: <a href="Anonymous-Functions.html" accesskey="p" rel="prev">Anonymous Functions</a>, Up: <a href="Functions.html" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Generic-Functions-1"><span>13.8 Generic Functions<a class="copiable-link" href="#Generic-Functions-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-generic-functions"></a>
<a class="index-entry-id" id="index-polymorphism"></a>

<p>Functions defined using <code class="code">defun</code> have a hard-coded set of
assumptions about the types and expected values of their arguments.
For example, a function that was designed to handle values of its
argument that are either numbers or lists of numbers will fail or
signal an error if called with a value of any other type, such as a
vector or a string.  This happens because the implementation of the
function is not prepared to deal with types other than those assumed
during the design.
</p>
<p>By contrast, object-oriented programs use <em class="dfn">polymorphic
functions</em>: a set of specialized functions having the same name, each
one of which was written for a certain specific set of argument types.
Which of the functions is actually called is decided at run time based
on the types of the actual arguments.
</p>
<a class="index-entry-id" id="index-CLOS"></a>
<p>Emacs provides support for polymorphism.  Like other Lisp
environments, notably Common Lisp and its Common Lisp Object System
(<abbr class="acronym">CLOS</abbr>), this support is based on <em class="dfn">generic functions</em>.
The Emacs generic functions closely follow <abbr class="acronym">CLOS</abbr>, including
use of similar names, so if you have experience with <abbr class="acronym">CLOS</abbr>,
the rest of this section will sound very familiar.
</p>
<p>A generic function specifies an abstract operation, by defining its
name and list of arguments, but (usually) no implementation.  The
actual implementation for several specific classes of arguments is
provided by <em class="dfn">methods</em>, which should be defined separately.  Each
method that implements a generic function has the same name as the
generic function, but the method&rsquo;s definition indicates what kinds of
arguments it can handle by <em class="dfn">specializing</em> the arguments defined by
the generic function.  These <em class="dfn">argument specializers</em> can be more
or less specific; for example, a <code class="code">string</code> type is more specific
than a more general type, such as <code class="code">sequence</code>.
</p>
<p>Note that, unlike in message-based OO languages, such as C<code class="t">++</code> and
Simula, methods that implement generic functions don&rsquo;t belong to a
class, they belong to the generic function they implement.
</p>
<p>When a generic function is invoked, it selects the applicable
methods by comparing the actual arguments passed by the caller with
the argument specializers of each method.  A method is applicable if
the actual arguments of the call are compatible with the method&rsquo;s
specializers.  If more than one method is applicable, they are
combined using certain rules, described below, and the combination
then handles the call.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-cl_002ddefgeneric"><span class="category-def">Macro: </span><span><strong class="def-name">cl-defgeneric</strong> <var class="def-var-arguments">name arguments [documentation] [options-and-methods&hellip;] &amp;rest body</var><a class="copiable-link" href="#index-cl_002ddefgeneric"> &para;</a></span></dt>
<dd><p>This macro defines a generic function with the specified <var class="var">name</var>
and <var class="var">arguments</var>.  If <var class="var">body</var> is present, it provides the
default implementation.  If <var class="var">documentation</var> is present (it should
always be), it specifies the documentation string for the generic
function, in the form <code class="code">(:documentation <var class="var">docstring</var>)</code>.  The
optional <var class="var">options-and-methods</var> can be one of the following forms:
</p>
<dl class="table">
<dt><code class="code">(declare <var class="var">declarations</var>)</code></dt>
<dd><p>A declare form, as described in <a class="ref" href="Declare-Form.html">The <code class="code">declare</code> Form</a>.
</p></dd>
<dt><code class="code">(:argument-precedence-order &amp;rest <var class="var">args</var>)</code></dt>
<dd><p>This form affects the sorting order for combining applicable methods.
Normally, when two methods are compared during combination, method
arguments are examined left to right, and the first method whose
argument specializer is more specific will come before the other one.
The order defined by this form overrides that, and the arguments are
examined according to their order in this form, and not left to right.
</p></dd>
<dt><code class="code">(:method [<var class="var">qualifiers</var>&hellip;] args &amp;rest body)</code></dt>
<dd><p>This form defines a method like <code class="code">cl-defmethod</code> does.
</p></dd>
</dl>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-cl_002ddefmethod"><span class="category-def">Macro: </span><span><strong class="def-name">cl-defmethod</strong> <var class="def-var-arguments">name [extra] [qualifier] arguments [&amp;context (expr spec)&hellip;] &amp;rest [docstring] body</var><a class="copiable-link" href="#index-cl_002ddefmethod"> &para;</a></span></dt>
<dd><p>This macro defines a particular implementation for the generic
function called <var class="var">name</var>.  The implementation code is given by
<var class="var">body</var>.  If present, <var class="var">docstring</var> is the documentation string
for the method.  The <var class="var">arguments</var> list, which must be identical in
all the methods that implement a generic function, and must match the
argument list of that function, provides argument specializers of the
form <code class="code">(<var class="var">arg</var> <var class="var">spec</var>)</code>, where <var class="var">arg</var> is the argument
name as specified in the <code class="code">cl-defgeneric</code> call, and <var class="var">spec</var> is
one of the following specializer forms:
</p>
<dl class="table">
<dt><code class="code"><var class="var">type</var></code></dt>
<dd><p>This specializer requires the argument to be of the given <var class="var">type</var>,
one of the types from the type hierarchy described below.
</p></dd>
<dt><code class="code">(eql <var class="var">object</var>)</code></dt>
<dd><p>This specializer requires the argument be <code class="code">eql</code> to the given
<var class="var">object</var>.
</p></dd>
<dt><code class="code">(head <var class="var">object</var>)</code></dt>
<dd><p>The argument must be a cons cell whose <code class="code">car</code> is <code class="code">eql</code> to
<var class="var">object</var>.
</p></dd>
<dt><code class="code"><var class="var">struct-type</var></code></dt>
<dd><p>The argument must be an instance of a class named <var class="var">struct-type</var>
defined with <code class="code">cl-defstruct</code> (see <a data-manual="cl" href="https://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html#Structures">Structures</a> in <cite class="cite">Common Lisp
Extensions for GNU Emacs Lisp</cite>), or of one of its child classes.
</p></dd>
</dl>

<p>Method definitions can make use of a new argument-list keyword,
<code class="code">&amp;context</code>, which introduces extra specializers that test the
environment at the time the method is run.  This keyword should appear
after the list of required arguments, but before any <code class="code">&amp;rest</code> or
<code class="code">&amp;optional</code> keywords.  The <code class="code">&amp;context</code> specializers look much
like regular argument specializers&mdash;(<var class="var">expr</var> <var class="var">spec</var>)&mdash;except
that <var class="var">expr</var> is an expression to be evaluated in the current
context, and the <var class="var">spec</var> is a value to compare against.  For
example, <code class="code">&amp;context (overwrite-mode (eql t))</code> will make the method
applicable only when <code class="code">overwrite-mode</code> is turned on.  The
<code class="code">&amp;context</code> keyword can be followed by any number of context
specializers.  Because the context specializers are not part of the
generic function&rsquo;s argument signature, they may be omitted in methods
that don&rsquo;t require them.
</p>
<p>The type specializer, <code class="code">(<var class="var">arg</var> <var class="var">type</var>)</code>, can specify one
of the <em class="dfn">system types</em> in the following list.  When a parent type
is specified, an argument whose type is any of its more specific child
types, as well as grand-children, grand-grand-children, etc. will also
be compatible.
</p>
<dl class="table">
<dt><code class="code">integer</code></dt>
<dd><p>Parent type: <code class="code">number</code>.
</p></dd>
<dt><code class="code">number</code></dt>
<dt><code class="code">null</code></dt>
<dd><p>Parent type: <code class="code">symbol</code>
</p></dd>
<dt><code class="code">symbol</code></dt>
<dt><code class="code">string</code></dt>
<dd><p>Parent type: <code class="code">array</code>.
</p></dd>
<dt><code class="code">array</code></dt>
<dd><p>Parent type: <code class="code">sequence</code>.
</p></dd>
<dt><code class="code">cons</code></dt>
<dd><p>Parent type: <code class="code">list</code>.
</p></dd>
<dt><code class="code">list</code></dt>
<dd><p>Parent type: <code class="code">sequence</code>.
</p></dd>
<dt><code class="code">marker</code></dt>
<dt><code class="code">overlay</code></dt>
<dt><code class="code">float</code></dt>
<dd><p>Parent type: <code class="code">number</code>.
</p></dd>
<dt><code class="code">window-configuration</code></dt>
<dt><code class="code">process</code></dt>
<dt><code class="code">window</code></dt>
<dt><code class="code">subr</code></dt>
<dt><code class="code">compiled-function</code></dt>
<dt><code class="code">buffer</code></dt>
<dt><code class="code">char-table</code></dt>
<dd><p>Parent type: <code class="code">array</code>.
</p></dd>
<dt><code class="code">bool-vector</code></dt>
<dd><p>Parent type: <code class="code">array</code>.
</p></dd>
<dt><code class="code">vector</code></dt>
<dd><p>Parent type: <code class="code">array</code>.
</p></dd>
<dt><code class="code">frame</code></dt>
<dt><code class="code">hash-table</code></dt>
<dt><code class="code">font-spec</code></dt>
<dt><code class="code">font-entity</code></dt>
<dt><code class="code">font-object</code></dt>
</dl>

<p>The optional <var class="var">extra</var> element, expressed as &lsquo;<samp class="samp">:extra
<var class="var">string</var></samp>&rsquo;, allows you to add more methods, distinguished by
<var class="var">string</var>, for the same specializers and qualifiers.
</p>
<p>The optional <var class="var">qualifier</var> allows combining several applicable
methods.  If it is not present, the defined method is a <em class="dfn">primary</em>
method, responsible for providing the primary implementation of the
generic function for the specialized arguments.  You can also define
<em class="dfn">auxiliary methods</em>, by using one of the following values as
<var class="var">qualifier</var>:
</p>
<dl class="table">
<dt><code class="code">:before</code></dt>
<dd><p>This auxiliary method will run before the primary method.  More
accurately, all the <code class="code">:before</code> methods will run before the
primary, in the most-specific-first order.
</p></dd>
<dt><code class="code">:after</code></dt>
<dd><p>This auxiliary method will run after the primary method.  More
accurately, all such methods will run after the primary, in the
most-specific-last order.
</p></dd>
<dt><code class="code">:around</code></dt>
<dd><p>This auxiliary method will run <em class="emph">instead</em> of the primary method.
The most specific of such methods will be run before any other method.
Such methods normally use <code class="code">cl-call-next-method</code>, described below,
to invoke the other auxiliary or primary methods.
</p></dd>
</dl>

<p>Functions defined using <code class="code">cl-defmethod</code> cannot be made
interactive, i.e. commands (see <a class="pxref" href="Defining-Commands.html">Defining Commands</a>), by adding
the <code class="code">interactive</code> form to them.  If you need a polymorphic
command, we recommend defining a normal command that calls a
polymorphic function defined via <code class="code">cl-defgeneric</code> and
<code class="code">cl-defmethod</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-dispatch-of-methods-for-generic-function"></a>
<a class="index-entry-id" id="index-multiple_002ddispatch-methods"></a>
<p>Each time a generic function is called, it builds the <em class="dfn">effective
method</em> which will handle this invocation by combining the applicable
methods defined for the function.  The process of finding the
applicable methods and producing the effective method is called
<em class="dfn">dispatch</em>.  The applicable methods are those all of whose
specializers are compatible with the actual arguments of the call.
Since all of the arguments must be compatible with the specializers,
they all determine whether a method is applicable.  Methods that
explicitly specialize more than one argument are called
<em class="dfn">multiple-dispatch methods</em>.
</p>
<p>The applicable methods are sorted into the order in which they will be
combined.  The method whose left-most argument specializer is the most
specific one will come first in the order.  (Specifying
<code class="code">:argument-precedence-order</code> as part of <code class="code">cl-defmethod</code>
overrides that, as described above.)  If the method body calls
<code class="code">cl-call-next-method</code>, the next most-specific method will run.
If there are applicable <code class="code">:around</code> methods, the most-specific of
them will run first; it should call <code class="code">cl-call-next-method</code> to run
any of the less specific <code class="code">:around</code> methods.  Next, the
<code class="code">:before</code> methods run in the order of their specificity, followed
by the primary method, and lastly the <code class="code">:after</code> methods in the
reverse order of their specificity.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-cl_002dcall_002dnext_002dmethod"><span class="category-def">Function: </span><span><strong class="def-name">cl-call-next-method</strong> <var class="def-var-arguments">&amp;rest args</var><a class="copiable-link" href="#index-cl_002dcall_002dnext_002dmethod"> &para;</a></span></dt>
<dd><p>When invoked from within the lexical body of a primary or an
<code class="code">:around</code> auxiliary method, call the next applicable method for
the same generic function.  Normally, it is called with no arguments,
which means to call the next applicable method with the same arguments
that the calling method was invoked.  Otherwise, the specified
arguments are used instead.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-cl_002dnext_002dmethod_002dp"><span class="category-def">Function: </span><span><strong class="def-name">cl-next-method-p</strong><a class="copiable-link" href="#index-cl_002dnext_002dmethod_002dp"> &para;</a></span></dt>
<dd><p>This function, when called from within the lexical body of a primary
or an <code class="code">:around</code> auxiliary method, returns non-<code class="code">nil</code> if there
is a next method to call.
</p></dd></dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Function-Cells.html">Accessing Function Cell Contents</a>, Previous: <a href="Anonymous-Functions.html">Anonymous Functions</a>, Up: <a href="Functions.html">Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
