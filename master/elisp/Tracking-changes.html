<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 31.0.50.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Tracking changes (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Tracking changes (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Tracking changes (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Change-Hooks.html" rel="up" title="Change Hooks">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Tracking-changes">
<div class="nav-panel">
<p>
Up: <a href="Change-Hooks.html" accesskey="u" rel="up">Change Hooks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Keeping-track-of-buffer-modifications"><span>33.34.1 Keeping track of buffer modifications<a class="copiable-link" href="#Keeping-track-of-buffer-modifications"> &para;</a></span></h4>
<a class="index-entry-id" id="index-track_002dchanges"></a>
<a class="index-entry-id" id="index-change-tracker"></a>

<p>Using <code class="code">before-change-functions</code> and <code class="code">after-change-functions</code>
can be difficult in practice because of a number of pitfalls, such as
the fact that the two calls are not always properly paired, or some
calls may be missing, either because some Emacs primitives failed to
properly pair them or because of incorrect use of
<code class="code">inhibit-modification-hooks</code>.  Furthermore,
many restrictions apply to those hook functions, such as the fact that
they basically should never modify the current buffer, nor use an
operation that may block, and they proceed quickly because
some commands may call these hooks a large number of times.
</p>
<p>The Track-Changes library fundamentally provides an alternative API,
built on top of those hooks.  Compared to <code class="code">after-change-functions</code>,
the first important difference is that, instead of providing the bounds
of the change and the previous length, it provides the bounds of the
change and the actual previous content of that region.  The need to
extract information from the original contents of the buffer is one of
the main reasons why some packages need to use both
<code class="code">before-change-functions</code> and <code class="code">after-change-functions</code> and
then try to match them up.
</p>
<p>The second difference is that it decouples the notification of a change
from the act of processing it, and it automatically combines into
a single change operation all the changes that occur between the first
change and the actual processing.  This makes it natural and easy to
process the changes at a larger granularity, such as once per command,
and eliminates most of the restrictions that apply to the usual change
hook functions, making it possible to use blocking operations or to
modify the buffer.
</p>
<p>To start tracking changes, you have to call
<code class="code">track-changes-register</code>, passing it a <var class="var">signal</var> function as
argument.  This returns a tracker <var class="var">id</var> which is used to identify
your change tracker to the other functions of the library.
When the buffer is modified, the library calls the <var class="var">signal</var>
function to inform you of that change and immediately starts
accumulating subsequent changes into a single combined change.
The <var class="var">signal</var> function serves only to warn that a modification
occurred but does not receive a description of the change.  Also the
library will not call it again until after you retrieved the change.
</p>
<p>To retrieve changes, you need to call <code class="code">track-changes-fetch</code>, which
provides you with the bounds of the changes accumulated since the
last call, as well as the previous content of that region.  It also
&ldquo;re-arms&rdquo; the <var class="var">signal</var> function so that the library will call it
again after the next buffer modification.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-track_002dchanges_002dregister"><span class="category-def">Function: </span><span><strong class="def-name">track-changes-register</strong> <var class="def-var-arguments">signal &amp;key nobefore disjoint immediate</var><a class="copiable-link" href="#index-track_002dchanges_002dregister"> &para;</a></span></dt>
<dd><p>This function creates a new <em class="dfn">change tracker</em>.  Change trackers are kept
abstract, so we refer to them as mere identities, and the function thus
returns the tracker&rsquo;s <var class="var">id</var>.
</p>
<p><var class="var">signal</var> is a function that the library will call to notify of
a change.  It will sometimes call it with a single argument and
sometimes with two.  Upon the first change to the buffer since this
tracker last called <code class="code">track-changes-fetch</code>, the library calls this
<var class="var">signal</var> function with a single argument holding the <var class="var">id</var> of
the tracker.
</p>
<p>By default, the call to the <var class="var">signal</var> function does not happen
immediately, but is instead postponed with a 0 seconds timer
(see <a class="pxref" href="Timers.html">Timers for Delayed Execution</a>).  This is usually desired to make sure the <var class="var">signal</var>
function is not called too frequently and runs in a permissive context,
freeing the client from performance concerns or worries about which
operations might be problematic.  If a client wants to have more
control, they can provide a non-<code class="code">nil</code> value as the <var class="var">immediate</var>
argument in which case the library calls the <var class="var">signal</var> function
directly from <code class="code">after-change-functions</code>.  Beware that it means that
the <var class="var">signal</var> function has to be careful not to modify the buffer or
use operations that may block.
</p>
<p>If you&rsquo;re not interested in the actual previous content of the buffer,
but are using this library only for its ability to combine many small
changes into a larger one and to delay the processing to a more
convenient time, you can specify a non-<code class="code">nil</code> value for the
<var class="var">nobefore</var> argument.  In that case, <code class="code">track-change-fetch</code>
provides you only with the length of the previous content, just like
<code class="code">after-change-functions</code>.  It also allows the library to save
some work.
</p>
<p>While you may like to accumulate many small changes into larger ones,
you may not want to do that if the changes are too far apart.  If you
specify a non-<code class="code">nil</code> value for the <var class="var">disjoint</var> argument, the library
will let you know when a change is about to occur &ldquo;far&rdquo; from the
currently pending ones by calling the <var class="var">signal</var> function right away,
passing it two arguments this time: the <var class="var">id</var> of the tracker, and the
number of characters that separates the upcoming change from the
already pending changes.  This in itself does not prevent combining this
new change with the previous ones, so if you think the upcoming change
is indeed too far, you need to call <code class="code">track-change-fetch</code>
right away.
Beware that when the <var class="var">signal</var> function is called because of
a disjoint change, this happens directly from
<code class="code">before-change-functions</code>, so the usual restrictions apply about
modifying the buffer or using operations that may block.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-track_002dchanges_002dfetch"><span class="category-def">Function: </span><span><strong class="def-name">track-changes-fetch</strong> <var class="def-var-arguments">id func</var><a class="copiable-link" href="#index-track_002dchanges_002dfetch"> &para;</a></span></dt>
<dd><p>This is the function that lets you find out what has changed in the
buffer.  By providing the tracker <var class="var">id</var> you let the library figure
out which changes have already been seen by your tracker.  Instead of
returning a description of the changes, <code class="code">track-changes-fetch</code> calls
the <var class="var">func</var> function with that description in the form of
3 arguments: <var class="var">beg</var>, <var class="var">end</var>, and <var class="var">before</var>, where
<code class="code"><var class="var">beg</var>..<var class="var">end</var></code> delimit the region that was modified and
<var class="var">before</var> describes the previous content of that region.
Usually <var class="var">before</var> is a string containing the previous text of the
modified region, but if you specified a non-<code class="code">nil</code> <var class="var">nobefore</var> argument
to <code class="code">track-changes-register</code>, then it is replaced by the number of
characters of that previous text.
</p>
<p>In case no changes occurred since the last call,
<code class="code">track-changes-fetch</code> simply does not call <var class="var">func</var> and returns
<code class="code">nil</code>.  If changes did occur, it calls <var class="var">func</var> and returns the value
returned by <var class="var">func</var>.  But note that <var class="var">func</var> is called just once
regardless of how many changes occurred: those are summarized into
a single <var class="var">beg</var>/<var class="var">end</var>/<var class="var">before</var> triplet.
</p>
<p>In some cases, the library is not properly notified of all changes,
for example because of a bug in the low-level C code or because of an
improper use of <code class="code">inhibit-modification-hooks</code>.  When it detects such
a problem, <var class="var">func</var> receives a <code class="code"><var class="var">beg</var>..<var class="var">end</var></code> region
which covers the whole buffer and the <var class="var">before</var> argument is the
symbol <code class="code">error</code> to indicate that the library was unable to determine
what was changed.
</p>
<p>Once <var class="var">func</var> finishes, <code class="code">track-changes-fetch</code> re-enables the
<var class="var">signal</var> function so that it will be called the next time a change
occurs.  This is the reason why it calls <var class="var">func</var> instead of returning
a description: it lets you process the change without worrying about the
risk that the <var class="var">signal</var> function gets triggered in the middle of it,
because the <var class="var">signal</var> is re-enabled only after <var class="var">func</var> finishes.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-track_002dchanges_002dundo_002donly"><span class="category-def">Variable: </span><span><strong class="def-name">track-changes-undo-only</strong><a class="copiable-link" href="#index-track_002dchanges_002dundo_002donly"> &para;</a></span></dt>
<dd><p>If your code uses <code class="code">track-changes</code> to perform further modifications
to the buffer (for example, to mark the parts of the buffer that have
been edited), then you may want to refrain from making those
modifications when the changes are the result of an undo (which
presumably also undoes the modifications you had applied back when the
corresponding edit was made).
To that end <code class="code">track-changes-fetch</code> binds
<code class="code">track-changes-undo-only</code> to non-<code class="code">nil</code> during calls to
<var class="var">func</var> if the changes were the result of undo.
</p></dd></dl>


<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-track_002dchanges_002dunregister"><span class="category-def">Function: </span><span><strong class="def-name">track-changes-unregister</strong> <var class="def-var-arguments">id</var><a class="copiable-link" href="#index-track_002dchanges_002dunregister"> &para;</a></span></dt>
<dd><p>This function tells the library that the tracker <var class="var">id</var> does not need
to know about buffer changes any more.  Most clients will never want to
stop tracking changes, but for clients such as minor modes, it is
important to call this function when the minor mode is disabled,
otherwise the tracker will keep accumulating changes and consume more
and more resources.
</p></dd></dl>
</div>
<hr>
<div class="nav-panel">
<p>
Up: <a href="Change-Hooks.html">Change Hooks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
