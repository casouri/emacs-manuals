<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 31.0.50.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>cond* Macro (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="cond* Macro (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="cond* Macro (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Pattern_002dMatching-Conditional.html" rel="up" title="Pattern-Matching Conditional">
<link href="Destructuring-with-pcase-Patterns.html" rel="prev" title="Destructuring with pcase Patterns">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="cond_002a-Macro">
<div class="nav-panel">
<p>
Previous: <a href="Destructuring-with-pcase-Patterns.html" accesskey="p" rel="prev">Destructuring with <code class="code">pcase</code> Patterns</a>, Up: <a href="Pattern_002dMatching-Conditional.html" accesskey="u" rel="up">Pattern-Matching Conditional</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="The-cond_002a-macro"><span>11.4.5 The <code class="code">cond*</code> macro<a class="copiable-link" href="#The-cond_002a-macro"> &para;</a></span></h4>
<a class="index-entry-id" id="index-cond_002a_002c-a-macro"></a>

<p>The <code class="code">cond*</code> macro is an alternative to <code class="code">pcase</code>, and supports
the same functionality, but using syntax that some might find less
cryptic.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-cond_002a"><span class="category-def">Macro: </span><span><strong class="def-name">cond*</strong> <var class="def-var-arguments">&amp;rest clauses</var><a class="copiable-link" href="#index-cond_002a"> &para;</a></span></dt>
<dd><p>The <code class="code">cond*</code> macro is an extended form of the traditional
<code class="code">cond</code>.  A <code class="code">cond*</code> expression contains a series of
<var class="var">clauses</var>, each of which can use <code class="code">bind*</code> to specify binding
variables, use <code class="code">match*</code> to specify matching a pattern as a
condition, or specify an expression as a condition to evaluate as a
test.
</p>
<p>Each clause normally has the form <code class="code">(<var class="var">condition</var>&nbsp;<var class="var">body</var>&hellip;)</code><!-- /@w -->.
</p>
<p><var class="var">condition</var> can be a Lisp expression, as in <code class="code">cond</code>
(see <a class="pxref" href="Conditionals.html">Conditionals</a>).  Or it can be <code class="code">(bind*&nbsp;<var class="var">bindings</var>&hellip;)</code><!-- /@w --> or <code class="code">(match*&nbsp;<var class="var">pattern</var>&nbsp;<var class="var">datum</var>)</code><!-- /@w -->.
</p>
<a class="index-entry-id" id="index-bind_002a"></a>
<p><code class="code">(bind* <var class="var">bindings</var>&hellip;)</code> means to bind <var class="var">bindings</var> (like
the bindings list in <code class="code">let*</code>, see <a class="pxref" href="Local-Variables.html">Local Variables</a>) for the body
of the clause, and all subsequent clauses.  As a condition, it counts as
true if the first binding&rsquo;s value is non-<code class="code">nil</code>.
</p>
<a class="index-entry-id" id="index-bind_002dand_002a"></a>
<p><code class="code">(bind-and* <var class="var">bindings</var>&hellip;)</code> means to bind <var class="var">bindings</var>
(like the bindings list in <code class="code">if-let*</code>, see <a class="pxref" href="Conditionals.html">Conditionals</a>) for
only the body of the clause.  As a condition, it counts as true if none
of the bindings evaluate to <code class="code">nil</code>.  In addition, if any binding
evaluates to <code class="code">nil</code>, the expressions for the values of subsequent
bindings are not evaluated.
</p>
<a class="index-entry-id" id="index-match_002a"></a>
<a class="index-entry-id" id="index-pcase_002a"></a>
<p><code class="code">(match* <var class="var">pattern</var> <var class="var">datum</var>)</code> means to match <var class="var">datum</var>
against the specified <var class="var">pattern</var>.  The condition counts as true if
<var class="var">pattern</var> matches <var class="var">datum</var>.  The pattern can specify variables to
bind to the parts of <var class="var">datum</var> that they match.
<code class="code">(pcase* <var class="var">pattern</var> <var class="var">datum</var>)</code> works in the same way except it
uses the Pcase syntax for <var class="var">pattern</var>.
</p>
<p><code class="code">bind*</code>, <code class="code">match*</code>, and <code class="code">pcase*</code> normally bind their bindings over
the execution of the whole containing clause.  However, if the clause is
written to specify &ldquo;non-exit&rdquo;, the clause&rsquo;s bindings cover the whole
rest of the <code class="code">cond*</code>.
</p>
<p>When a clause&rsquo;s condition is true, and it exits the <code class="code">cond*</code> or is
the last clause, the value of the last expression in the clause&rsquo;s body
becomes the return value of the <code class="code">cond*</code> construct.
</p>
<h4 class="subheading" id="Non_002dexit-clause"><span>Non-exit clause<a class="copiable-link" href="#Non_002dexit-clause"> &para;</a></span></h4>

<p>If a clause has only one element, or if its first element is <code class="code">t</code>,
or if it ends with the keyword <code class="code">:non-exit</code>, then this clause never
exits the <code class="code">cond*</code> construct.  Instead, control falls through to the
next clause (if any).  The bindings made in <var class="var">condition</var> for the
<var class="var">body</var> of the non-exit clause are passed along to the rest of the
clauses in this <code class="code">cond*</code> construct.
</p>
<p>Note: <code class="code">pcase*</code> does not support <code class="code">:non-exit</code>, and when used in
a non-exit clause, it follows the semantics of <code class="code">pcase-let</code>, see
<a class="ref" href="Destructuring-with-pcase-Patterns.html">Destructuring with <code class="code">pcase</code> Patterns</a>.
</p>
<h4 class="subheading" id="Matching-clauses"><span>Matching clauses<a class="copiable-link" href="#Matching-clauses"> &para;</a></span></h4>

<p>A matching clause looks like <code class="code">(match* <var class="var">pattern</var> <var class="var">datum</var>)</code>.
It evaluates the expression <var class="var">datum</var> and matches the pattern
<var class="var">pattern</var> (which is not evaluated) against it.
</p>
<p><var class="var">pattern</var> allows these kinds of patterns, and those that are lists
often include other patterns within them:
</p>
<dl class="table">
<dt><code class="code">_</code></dt>
<dd><p>Matches any value.
</p></dd>
<dt><code class="code"><var class="var">keyword</var></code></dt>
<dd><p>Matches that keyword.
</p></dd>
<dt><code class="code">nil</code></dt>
<dd><p>Matches <code class="code">nil</code>.
</p></dd>
<dt><code class="code">t</code></dt>
<dd><p>Matches <code class="code">t</code>.
</p></dd>
<dt><code class="code"><var class="var">symbol</var></code></dt>
<dd><p>Matches any value and binds <var class="var">symbol</var> to that value.  If <var class="var">symbol</var>
has been matched and bound earlier in this pattern, it matches here the
same value that it matched before.
</p></dd>
<dt><code class="code"><var class="var">regexp</var></code></dt>
<dd><p>Matches a string if <var class="var">regexp</var> matches it.  The match must cover the
entire string from its first char to its last.
</p></dd>
<dt><code class="code"><var class="var">atom</var></code></dt>
<dd><p>(Meaning any other kind of non-list not described above.)  Matches
anything &lsquo;equal&rsquo; to it.
</p></dd>
<dt><code class="code">(rx <var class="var">regexp</var>)</code></dt>
<dd><p>Uses a regexp specified in s-expression form, as in the function
<code class="code">rx</code> (see <a class="pxref" href="Rx-Notation.html">The <code class="code">rx</code> Structured Regexp Notation</a>, and matches the data that way.
</p></dd>
<dt><code class="code">(rx <var class="var">regexp</var> <var class="var">sym0</var> <var class="var">sym1</var>&hellip;)</code></dt>
<dd><p>Uses a regexp specified in s-expression form, and binds the symbols
<var class="var">sym0</var>, <var class="var">sym1</var>, and so on to <code class="code">(match-string&nbsp;0&nbsp;<var class="var">datum</var>)</code><!-- /@w -->, <code class="code">(match-string&nbsp;1&nbsp;<var class="var">datum</var>)</code><!-- /@w -->, and so on.  You
can use as many <var class="var">sym</var>s as regexp matching supports.
</p></dd>
<dt><code class="code">`<var class="var">object</var></code></dt>
<dd><p>Matches any value <code class="code">equal</code> to <var class="var">object</var>.
</p></dd>
<dt><code class="code">(cons <var class="var">carpat</var> <code class="code">cdrpat</code>)</code></dt>
<dd><p>Matches a cons cell if <var class="var">carpat</var> matches its <code class="code">car</code> and
<var class="var">cdrpat</var> matches its <code class="code">cdr</code>.
</p></dd>
<dt><code class="code">(list <var class="var">eltpats</var>&hellip;)</code></dt>
<dd><p>Matches a list if the <var class="var">eltpats</var> match its elements.  The first
<var class="var">eltpat</var> should match the list&rsquo;s first element.  The second
<var class="var">eltpat</var> should match the list&rsquo;s second element.  And so on.
</p></dd>
<dt><code class="code">(vector <var class="var">eltpats</var>&hellip;)</code></dt>
<dd><p>Matches a vector if the <var class="var">eltpats</var> match its elements.  The first
<var class="var">eltpat</var> should match the vector&rsquo;s first element.  The second
<var class="var">eltpat</var> should match the vector&rsquo;s second element.  And so on.
</p></dd>
<dt><code class="code">(cdr <var class="var">pattern</var>)</code></dt>
<dd><p>Matches <var class="var">pattern</var> with strict checking of <code class="code">cdr</code>s.  That means
that <code class="code">list</code> patterns verify that the final <code class="code">cdr</code> is
<code class="code">nil</code>.  Strict checking is the default.
</p></dd>
<dt><code class="code">(cdr-safe <var class="var">pattern</var>)</code></dt>
<dd><p>Matches <var class="var">pattern</var> with lax checking of <code class="code">cdr</code>s.  That means that
<code class="code">list</code> patterns do not examine the final <code class="code">cdr</code>.
</p></dd>
<dt><code class="code">(and <var class="var">conjuncts</var>&hellip;)</code></dt>
<dd><p>Matches each of the <var class="var">conjuncts</var> against the same data.  If all of
them match, this pattern succeeds.  If one <var class="var">conjunct</var> fails, this
pattern fails and does not try more <var class="var">conjuncts</var>.
</p></dd>
<dt><code class="code">(or <var class="var">disjuncts</var>&hellip;)</code></dt>
<dd><p>Matches each of the <var class="var">disjuncts</var> against the same data.  If one
<var class="var">disjunct</var> succeeds, this pattern succeeds and does not try more
<var class="var">disjuncts</var>.  If all of them fail, this pattern fails.
</p></dd>
<dt><code class="code">(<var class="var">cond*-expander</var> &hellip;)</code></dt>
<dd><p>Here the <code class="code">car</code> is a symbol that has a <code class="code">cond*-expander</code>
property which defines how to handle it in a pattern.  The property
value is a function.  Trying to match such a pattern calls that function
with one argument, the pattern in question (including its <code class="code">car</code>).
The function should return an equivalent pattern to be matched instead.
</p></dd>
<dt><code class="code">(<var class="var">predicate</var> <var class="var">symbol</var>)</code></dt>
<dd><p>Matches datum if <code class="code">(<var class="var">predicate</var> <var class="var">datum</var>)</code> is true, then
binds <var class="var">symbol</var> to <var class="var">datum</var>.
</p></dd>
<dt><code class="code">(<var class="var">predicate</var> <var class="var">SYMBOL</var> <var class="var">more-args</var>&hellip;)</code></dt>
<dd><p>Matches datum if <code class="code">(<var class="var">predicate</var>&nbsp;<var class="var">datum</var>&nbsp;<var class="var">more-args</var>&hellip;)</code><!-- /@w --> is true, then binds <var class="var">symbol</var> to
<var class="var">datum</var>.  <var class="var">more-args</var>&hellip; can refer to symbols bound earlier
in the pattern.
</p></dd>
<dt><code class="code">(constrain <var class="var">symbol</var> <var class="var">exp</var>)</code></dt>
<dd><p>Matches datum if the form <var class="var">exp</var> is true.  <var class="var">exp</var> can refer to
symbols bound earlier in the pattern.
</p></dd>
</dl>

</dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Destructuring-with-pcase-Patterns.html">Destructuring with <code class="code">pcase</code> Patterns</a>, Up: <a href="Pattern_002dMatching-Conditional.html">Pattern-Matching Conditional</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
