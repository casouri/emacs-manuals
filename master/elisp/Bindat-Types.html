<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.0.50.

Copyright © 1990-1996, 1998-2021 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Bindat Types (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Bindat Types (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Bindat Types (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Byte-Packing.html" rel="up" title="Byte Packing">
<link href="Bindat-Functions.html" rel="next" title="Bindat Functions">
<link href="Byte-Packing.html" rel="prev" title="Byte Packing">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<span id="Bindat-Types"></span><div class="header">
<p>
Next: <a href="Bindat-Functions.html" accesskey="n" rel="next">Bindat Functions</a>, Up: <a href="Byte-Packing.html" accesskey="u" rel="up">Byte Packing</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Describing-Data-Layout"></span><h4 class="subsection">39.20.1 Describing Data Layout</h4>
<span id="index-bindat-types"></span>

<span id="index-data-layout-specification"></span>
<span id="index-bindat-type-expression"></span>
<span id="index-base-type_002c-in-bindat-specification"></span>
<span id="index-composite-type_002c-in-bindat-specification"></span>
<p>To control unpacking and packing, you write a <em>data layout
specification</em>, also called a <em>Bindat type expression</em>.  This can
be a <em>base type</em> or a <em>composite type</em> made of several fields,
where the specification controls the length of each field to be
processed, and how to pack or unpack it.  We normally keep bindat type
values in variables whose names end in <code>-bindat-spec</code>; that kind
of name is automatically recognized as risky (see <a href="File-Local-Variables.html">File Local Variables</a>).
</p>
<dl>
<dt id="index-bindat_002dtype">Macro: <strong>bindat-type</strong> <em>&amp;rest type</em></dt>
<dd><p>Creates a Bindat type <em>value</em> object according to the Bindat type
<em>expression</em> <var>type</var>.
</p></dd></dl>

<span id="index-endianness_002c-in-bindat-specification"></span>
<span id="index-big-endian_002c-in-bindat-specification"></span>
<span id="index-little-endian_002c-in-bindat-specification"></span>
<span id="index-network-byte-ordering_002c-in-Bindat-specification"></span>
<p>A field&rsquo;s <em>type</em> describes the size (in bytes) of the object
that the field represents and, in the case of multibyte fields, how
the bytes are ordered within the field.  The two possible orderings
are <em>big endian</em> (also known as &ldquo;network byte ordering&rdquo;) and
<em>little endian</em>.  For instance, the number <code>#x23cd</code> (decimal
9165) in big endian would be the two bytes <code>#x23</code> <code>#xcd</code>;
and in little endian, <code>#xcd</code> <code>#x23</code>.  Here are the possible
type values:
</p>
<dl compact="compact">
<dt><code>u8</code></dt>
<dt><code>byte</code></dt>
<dd><p>Unsigned byte, with length 1.
</p>
</dd>
<dt><code>uint <var>bitlen</var></code></dt>
<dd><p>Unsigned integer in network byte order, with <var>bitlen</var> bits.
<var>bitlen</var> has to be a multiple of 8.
</p>
</dd>
<dt><code>uintr <var>bitlen</var></code></dt>
<dd><p>Unsigned integer in little endian order, with <var>bitlen</var> bits.
<var>bitlen</var> has to be a multiple of 8.
</p>
</dd>
<dt><code>str <var>len</var></code></dt>
<dd><p>String of bytes of length <var>len</var>.
</p>
</dd>
<dt><code>strz &amp;optional <var>len</var></code></dt>
<dd><p>Zero-terminated string of bytes, can be of arbitrary length or in a fixed-size
field with length <var>len</var>.
</p>
</dd>
<dt><code>vec <var>len</var> [<var>type</var>]</code></dt>
<dd><p>Vector of <var>len</var> elements.  The type of the elements is given by
<var>type</var>, defaulting to bytes.  The <var>type</var> can be any Bindat
type expression.
</p>
</dd>
<dt><code>repeat <var>len</var> [<var>type</var>]</code></dt>
<dd><p>Like <code>vec</code>, but it unpacks to and packs from lists, whereas
<code>vec</code> unpacks to vectors.
</p>
</dd>
<dt><code>bits <var>len</var></code></dt>
<dd><p>List of bits that are set to 1 in <var>len</var> bytes.  The bytes are
taken in big-endian order, and the bits are numbered starting with
<code>8 * <var>len</var> − 1</code> and ending with zero.  For example:
<code>bits 2</code> unpacks <code>#x28</code> <code>#x1c</code> to <code>(2&nbsp;3&nbsp;4&nbsp;11&nbsp;13)</code><!-- /@w -->
and <code>#x1c</code> <code>#x28</code> to <code>(3&nbsp;5&nbsp;10&nbsp;11&nbsp;12)</code><!-- /@w -->.
</p>
</dd>
<dt><code>fill <var>len</var></code></dt>
<dd><p><var>len</var> bytes used as a mere filler.  In packing, these bytes are
are left unchanged, which normally means they remain zero.
When unpacking, this just returns nil.
</p>
</dd>
<dt><code>align <var>len</var></code></dt>
<dd><p>Same as <code>fill</code> except the number of bytes is that needed to skip
to the next multiple of <var>len</var> bytes.
</p>
</dd>
<dt><code>type <var>exp</var></code></dt>
<dd><p>This lets you refer to a type indirectly: <var>exp</var> is a Lisp
expression which should return a Bindat type <em>value</em>.
</p>
</dd>
<dt><code>unit <var>exp</var></code></dt>
<dd><p>This is a trivial type which uses up 0 bits of space.  <var>exp</var>
describes the value returned when we try to &ldquo;unpack&rdquo; such a field.
</p>
</dd>
<dt><code>struct <var>fields</var>...</code></dt>
<dd><p>Composite type made of several fields.  Every field is of the form
<code>(<var>name</var> <var>type</var>)</code> where <var>type</var> can be any Bindat
type expression.  <var>name</var> can be <code>_</code> when the field&rsquo;s value
does not deserve to be named, as is often the case for <code>align</code>
and <code>fill</code> fields.
When the context makes it clear that this is a Bindat type expression,
the symbol <code>struct</code> can be omitted.
</p></dd>
</dl>

<p>In the types above, <var>len</var> and <var>bitlen</var> are given as an integer
specifying the number of bytes (or bits) in the field.  When the
length of a field is not fixed, it typically depends on the value of
preceding fields.  For this reason, the length <var>len</var> does not have
to be a constant but can be any Lisp expression and it can refer to
the value of previous fields via their name.
</p>
<p>For example, the specification of a data layout where a leading byte gives
the size of a subsequent vector of 16 bit integers could be:
</p><div class="example">
<pre class="example">(bindat-type
  (len      u8)
  (payload  vec (1+ len) uint 16))
</pre></div>

<hr>
<div class="header">
<p>
Next: <a href="Bindat-Functions.html" accesskey="n" rel="next">Bindat Functions</a>, Up: <a href="Byte-Packing.html" accesskey="u" rel="up">Byte Packing</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
