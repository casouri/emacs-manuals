<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 31.0.50.

Copyright Â© 1990-1996, 1998-2025 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Lexical Binding (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Lexical Binding (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Lexical Binding (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Variable-Scoping.html" rel="up" title="Variable Scoping">
<link href="Dynamic-Binding.html" rel="next" title="Dynamic Binding">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Lexical-Binding">
<div class="nav-panel">
<p>
Next: <a href="Dynamic-Binding.html" accesskey="n" rel="next">Dynamic Binding</a>, Up: <a href="Variable-Scoping.html" accesskey="u" rel="up">Scoping Rules for Variable Bindings</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Lexical-Binding-1"><span>12.10.1 Lexical Binding<a class="copiable-link" href="#Lexical-Binding-1"> &para;</a></span></h4>

<p>Lexical binding is only available in the modern Emacs Lisp dialect.
(See <a class="xref" href="Selecting-Lisp-Dialect.html">Selecting Lisp Dialect</a>.)
A lexically-bound variable has <em class="dfn">lexical scope</em>, meaning that any
reference to the variable must be located textually within the binding
construct.  Here is an example
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(let ((x 1))    ; <span class="r"><code class="code">x</code> is lexically bound.</span>
  (+ x 3))
     &rArr; 4

(defun getx ()
  x)            ; <span class="r"><code class="code">x</code> is used free in this function.</span>

(let ((x 1))    ; <span class="r"><code class="code">x</code> is lexically bound.</span>
  (getx))
error&rarr; Symbol's value as variable is void: x
</pre></div></div>

<p>Here, the variable <code class="code">x</code> has no global value.  When it is lexically
bound within a <code class="code">let</code> form, it can be used in the textual confines
of that <code class="code">let</code> form.  But it can <em class="emph">not</em> be used from within a
<code class="code">getx</code> function called from the <code class="code">let</code> form, since the
function definition of <code class="code">getx</code> occurs outside the <code class="code">let</code> form
itself.
</p>
<a class="index-entry-id" id="index-lexical-environment"></a>
<p>Here is how lexical binding works.  Each binding construct defines a
<em class="dfn">lexical environment</em>, specifying the variables that are bound
within the construct and their local values.  When the Lisp evaluator
wants the current value of a variable, it looks first in the lexical
environment; if the variable is not specified in there, it looks in
the symbol&rsquo;s value cell, where the dynamic value is stored.
</p>
<a class="index-entry-id" id="index-closures_002c-example-of-using"></a>
<p>Lexical bindings have indefinite extent.  Even after a binding
construct has finished executing, its lexical environment can be
&ldquo;kept around&rdquo; in Lisp objects called <em class="dfn">closures</em>.  A closure is
created when you define a named or anonymous function with lexical
binding enabled.  See <a class="xref" href="Closures.html">Closures</a>, for details.
</p>
<p>When a closure is called as a function, any lexical variable
references within its definition use the retained lexical environment.
Here is an example:
</p>
<div class="example">
<pre class="example-preformatted">(defvar my-ticker nil)   ; <span class="r">We will use this dynamically bound</span>
                         ; <span class="r">variable to store a closure.</span>

(let ((x 0))             ; <span class="r"><code class="code">x</code> is lexically bound.</span>
  (setq my-ticker (lambda ()
                    (setq x (1+ x)))))
    &rArr; #f(lambda () [(x 0)]
          (setq x (1+ x)))

(funcall my-ticker)
    &rArr; 1

(funcall my-ticker)
    &rArr; 2

(funcall my-ticker)
    &rArr; 3

x                        ; <span class="r">Note that <code class="code">x</code> has no global value.</span>
error&rarr; Symbol's value as variable is void: x
</pre></div>

<p>Here, the <code class="code">let</code> binding defines a lexical environment in which the
variable <code class="code">x</code> is locally bound to 0.  Within this binding
construct, we define a lambda expression which increments <code class="code">x</code> by
one and returns the incremented value.  This lambda expression is
automatically turned into a closure, in which the lexical environment
lives on even after the <code class="code">let</code> binding construct has exited.  Each
time we evaluate the closure, it increments <code class="code">x</code>, using the
binding of <code class="code">x</code> in that lexical environment.
</p>
<p>Note that unlike dynamic variables which are tied to the symbol
object itself, the relationship between lexical variables and symbols
is only present in the interpreter (or compiler).  Therefore,
functions which take a symbol argument (like <code class="code">symbol-value</code>,
<code class="code">boundp</code>, and <code class="code">set</code>) can only retrieve or modify a
variable&rsquo;s dynamic binding (i.e., the contents of its symbol&rsquo;s value
cell).
</p>
<p>Note also that variables may be declared special, in which case they
will use dynamic binding, even for new bindings such as a <code class="code">let</code>
binding.  Depending on how the variable is declared, it can be
special globally, for a single file, or for a portion of a file.
See <a class="xref" href="Dynamic-Binding.html">Dynamic Binding</a>, for further details.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Dynamic-Binding.html">Dynamic Binding</a>, Up: <a href="Variable-Scoping.html">Scoping Rules for Variable Bindings</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
