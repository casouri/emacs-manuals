<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.2.

Copyright Â© 1990-1996, 1998-2024 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Timers (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Timers (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Timers (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="System-Interface.html" rel="up" title="System Interface">
<link href="Idle-Timers.html" rel="next" title="Idle Timers">
<link href="Time-Calculations.html" rel="prev" title="Time Calculations">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Timers">
<div class="nav-panel">
<p>
Next: <a href="Idle-Timers.html" accesskey="n" rel="next">Idle Timers</a>, Previous: <a href="Time-Calculations.html" accesskey="p" rel="prev">Time Calculations</a>, Up: <a href="System-Interface.html" accesskey="u" rel="up">Operating System Interface</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Timers-for-Delayed-Execution"><span>42.11 Timers for Delayed Execution<a class="copiable-link" href="#Timers-for-Delayed-Execution"> &para;</a></span></h3>
<a class="index-entry-id" id="index-timers"></a>

<p>You can set up a <em class="dfn">timer</em> to call a function at a specified
future time or after a certain length of idleness.  A timer is a
special object that stores the information about the next invocation
times and the function to invoke.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-timerp"><span class="category-def">Function: </span><span><strong class="def-name">timerp</strong> <var class="def-var-arguments">object</var><a class="copiable-link" href="#index-timerp"> &para;</a></span></dt>
<dd><p>This predicate function returns non-<code class="code">nil</code> if <code class="code">object</code> is a
timer.
</p></dd></dl>

<p>Emacs cannot run timers at any arbitrary point in a Lisp program; it
can run them only when Emacs could accept output from a subprocess:
namely, while waiting or inside certain primitive functions such as
<code class="code">sit-for</code> or <code class="code">read-event</code> which <em class="emph">can</em> wait.  Therefore, a
timer&rsquo;s execution may be delayed if Emacs is busy.  However, the time of
execution is very precise if Emacs is idle.
</p>
<p>Emacs binds <code class="code">inhibit-quit</code> to <code class="code">t</code> before calling the timer
function, because quitting out of many timer functions can leave
things in an inconsistent state.  This is normally unproblematical
because most timer functions don&rsquo;t do a lot of work.  Indeed, for a
timer to call a function that takes substantial time to run is likely
to be annoying.  If a timer function needs to allow quitting, it
should use <code class="code">with-local-quit</code> (see <a class="pxref" href="Quitting.html">Quitting</a>).  For example, if
a timer function calls <code class="code">accept-process-output</code> to receive output
from an external process, that call should be wrapped inside
<code class="code">with-local-quit</code>, to ensure that <kbd class="kbd">C-g</kbd> works if the external
process hangs.
</p>
<p>It is usually a bad idea for timer functions to alter buffer
contents.  When they do, they usually should call <code class="code">undo-boundary</code>
both before and after changing the buffer, to separate the timer&rsquo;s
changes from user commands&rsquo; changes and prevent a single undo entry
from growing to be quite large.
</p>
<p>Timer functions should also avoid calling functions that cause Emacs
to wait, such as <code class="code">sit-for</code> (see <a class="pxref" href="Waiting.html">Waiting for Elapsed Time or Input</a>).  This can lead to
unpredictable effects, since other timers (or even the same timer) can
run while waiting.  If a timer function needs to perform an action
after a certain time has elapsed, it can do this by scheduling a new
timer.
</p>
<p>If a timer function performs a remote file operation, it can be in
conflict with an already running remote file operation of the same
connection.  Such conflicts are detected, and they result in a
<code class="code">remote-file-error</code> error (see <a class="pxref" href="Standard-Errors.html">Standard Errors</a>).  This should
be protected by wrapping the timer function body with
</p>
<div class="example lisp">
<div class="group"><pre class="lisp-preformatted">(ignore-error 'remote-file-error
  ...)
</pre></div></div>

<p>If a timer function calls functions that can change the match data,
it should save and restore the match data.  See <a class="xref" href="Saving-Match-Data.html">Saving and Restoring the Match Data</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-run_002dat_002dtime"><span class="category-def">Command: </span><span><strong class="def-name">run-at-time</strong> <var class="def-var-arguments">time repeat function &amp;rest args</var><a class="copiable-link" href="#index-run_002dat_002dtime"> &para;</a></span></dt>
<dd><p>This sets up a timer that calls the function <var class="var">function</var> with
arguments <var class="var">args</var> at time <var class="var">time</var>.  If <var class="var">repeat</var> is a number
(integer or floating point), the timer is scheduled to run again every
<var class="var">repeat</var> seconds after <var class="var">time</var>.  If <var class="var">repeat</var> is <code class="code">nil</code>,
the timer runs only once.
</p>
<p><var class="var">time</var> may specify an absolute or a relative time.
</p>
<p>Absolute times may be specified using a string with a limited variety
of formats, and are taken to be times <em class="emph">today</em>, even if already in
the past.  The recognized forms are &lsquo;<samp class="samp"><var class="var">xxxx</var></samp>&rsquo;,
&lsquo;<samp class="samp"><var class="var">x</var>:<var class="var">xx</var></samp>&rsquo;, or &lsquo;<samp class="samp"><var class="var">xx</var>:<var class="var">xx</var></samp>&rsquo; (military time),
and &lsquo;<samp class="samp"><var class="var">xx</var>am</samp>&rsquo;, &lsquo;<samp class="samp"><var class="var">xx</var>AM</samp>&rsquo;, &lsquo;<samp class="samp"><var class="var">xx</var>pm</samp>&rsquo;,
&lsquo;<samp class="samp"><var class="var">xx</var>PM</samp>&rsquo;, &lsquo;<samp class="samp"><var class="var">xx</var>:<var class="var">xx</var>am</samp>&rsquo;,
&lsquo;<samp class="samp"><var class="var">xx</var>:<var class="var">xx</var>AM</samp>&rsquo;, &lsquo;<samp class="samp"><var class="var">xx</var>:<var class="var">xx</var>pm</samp>&rsquo;, or
&lsquo;<samp class="samp"><var class="var">xx</var>:<var class="var">xx</var>PM</samp>&rsquo;.  A period can be used instead of a colon
to separate the hour and minute parts.
</p>
<p>To specify a relative time as a string, use numbers followed by units.
For example:
</p>
<dl class="table">
<dt>&lsquo;<samp class="samp">1 min</samp>&rsquo;</dt>
<dd><p>denotes 1 minute from now.
</p></dd>
<dt>&lsquo;<samp class="samp">1 min 5 sec</samp>&rsquo;</dt>
<dd><p>denotes 65 seconds from now.
</p></dd>
<dt>&lsquo;<samp class="samp">1 min 2 sec 3 hour 4 day 5 week 6 fortnight 7 month 8 year</samp>&rsquo;</dt>
<dd><p>denotes exactly 103 months, 123 days, and 10862 seconds from now.
</p></dd>
</dl>

<p>For relative time values, Emacs considers a month to be exactly thirty
days, and a year to be exactly 365.25 days.
</p>
<p>Not all convenient formats are strings.  If <var class="var">time</var> is a number
(integer or floating point), that specifies a relative time measured in
seconds.  The result of <code class="code">encode-time</code> can also be used to specify
an absolute value for <var class="var">time</var>.
</p>
<p>In most cases, <var class="var">repeat</var> has no effect on when <em class="emph">first</em> call
takes place&mdash;<var class="var">time</var> alone specifies that.  There is one exception:
if <var class="var">time</var> is <code class="code">t</code>, then the timer runs whenever the time is a
multiple of <var class="var">repeat</var> seconds after the epoch.  This is useful for
functions like <code class="code">display-time</code>.  For instance, the following will
make <var class="var">function</var> run at every &ldquo;whole&rdquo; minute (e.g.,
&lsquo;<samp class="samp">11:03:00</samp>&rsquo;, &lsquo;<samp class="samp">11:04:00</samp>&rsquo;, etc):
</p>
<div class="example">
<pre class="example-preformatted">(run-at-time t 60 <var class="var">function</var>)
</pre></div>

<p>If Emacs didn&rsquo;t get any CPU time when the timer would have run (for
example if the system was busy running another process or if the
computer was sleeping or in a suspended state), the timer will run as
soon as Emacs resumes and is idle.
</p>
<p>The function <code class="code">run-at-time</code> returns a timer value that identifies
the particular scheduled future action.  You can use this value to call
<code class="code">cancel-timer</code> (see below).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-run_002dwith_002dtimer"><span class="category-def">Command: </span><span><strong class="def-name">run-with-timer</strong> <var class="def-var-arguments">secs repeat function &amp;rest args</var><a class="copiable-link" href="#index-run_002dwith_002dtimer"> &para;</a></span></dt>
<dd><p>This is exactly the same as <code class="code">run-at-time</code> (so see that definition
for an explanation of the parameters; <var class="var">secs</var> is passed as
<var class="var">time</var> to that function), but is meant to be used when the delay
is specified in seconds.
</p></dd></dl>

<p>A repeating timer nominally ought to run every <var class="var">repeat</var> seconds,
but remember that any invocation of a timer can be late.  Lateness of
one repetition has no effect on the scheduled time of the next
repetition.  For instance, if Emacs is busy computing for long enough
to cover three scheduled repetitions of the timer, and then starts to
wait, it will immediately call the timer function three times in
immediate succession (presuming no other timers trigger before or
between them).  If you want a timer to run again no less than <var class="var">n</var>
seconds after the last invocation, don&rsquo;t use the <var class="var">repeat</var> argument.
Instead, the timer function should explicitly reschedule the timer.
</p>
<dl class="first-defvr first-defopt-alias-first-defvr">
<dt class="defvr defopt-alias-defvr" id="index-timer_002dmax_002drepeats"><span class="category-def">User Option: </span><span><strong class="def-name">timer-max-repeats</strong><a class="copiable-link" href="#index-timer_002dmax_002drepeats"> &para;</a></span></dt>
<dd><p>This variable&rsquo;s value specifies the maximum number of times to repeat
calling a timer function in a row, when many previously scheduled
calls were unavoidably delayed.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-with_002dtimeout"><span class="category-def">Macro: </span><span><strong class="def-name">with-timeout</strong> <var class="def-var-arguments">(seconds timeout-forms&hellip;) body&hellip;</var><a class="copiable-link" href="#index-with_002dtimeout"> &para;</a></span></dt>
<dd><p>Execute <var class="var">body</var>, but give up after <var class="var">seconds</var> seconds.  If
<var class="var">body</var> finishes before the time is up, <code class="code">with-timeout</code> returns
the value of the last form in <var class="var">body</var>.  If, however, the execution of
<var class="var">body</var> is cut short by the timeout, then <code class="code">with-timeout</code>
executes all the <var class="var">timeout-forms</var> and returns the value of the last
of them.
</p>
<p>This macro works by setting a timer to run after <var class="var">seconds</var> seconds.  If
<var class="var">body</var> finishes before that time, it cancels the timer.  If the
timer actually runs, it terminates execution of <var class="var">body</var>, then
executes <var class="var">timeout-forms</var>.
</p>
<p>Since timers can run within a Lisp program only when the program calls a
primitive that can wait, <code class="code">with-timeout</code> cannot stop executing
<var class="var">body</var> while it is in the midst of a computation&mdash;only when it
calls one of those primitives.  So use <code class="code">with-timeout</code> only with a
<var class="var">body</var> that waits for input, not one that does a long computation.
</p></dd></dl>

<p>The function <code class="code">y-or-n-p-with-timeout</code> provides a simple way to use
a timer to avoid waiting too long for an answer.  See <a class="xref" href="Yes_002dor_002dNo-Queries.html">Yes-or-No Queries</a>.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-cancel_002dtimer"><span class="category-def">Function: </span><span><strong class="def-name">cancel-timer</strong> <var class="def-var-arguments">timer</var><a class="copiable-link" href="#index-cancel_002dtimer"> &para;</a></span></dt>
<dd><p>This cancels the requested action for <var class="var">timer</var>, which should be a
timer&mdash;usually, one previously returned by <code class="code">run-at-time</code> or
<code class="code">run-with-idle-timer</code>.  This cancels the effect of that call to
one of these functions; the arrival of the specified time will not
cause anything special to happen.
</p></dd></dl>

<a class="index-entry-id" id="index-list_002dtimers"></a>
<p>The <code class="code">list-timers</code> command lists all the currently active timers.
The command <kbd class="kbd">c</kbd> (<code class="code">timer-list-cancel</code>) will cancel the timer
on the line under point.  You can sort the list by column using the
command <kbd class="kbd">S</kbd> (<code class="code">tabulated-list-sort</code>).
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Idle-Timers.html">Idle Timers</a>, Previous: <a href="Time-Calculations.html">Time Calculations</a>, Up: <a href="System-Interface.html">Operating System Interface</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
