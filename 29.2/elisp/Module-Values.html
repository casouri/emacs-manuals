<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.2.

Copyright Â© 1990-1996, 1998-2024 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Module Values (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Module Values (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Module Values (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Writing-Dynamic-Modules.html" rel="up" title="Writing Dynamic Modules">
<link href="Module-Misc.html" rel="next" title="Module Misc">
<link href="Module-Functions.html" rel="prev" title="Module Functions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Module-Values">
<div class="nav-panel">
<p>
Next: <a href="Module-Misc.html" accesskey="n" rel="next">Miscellaneous Convenience Functions for Modules</a>, Previous: <a href="Module-Functions.html" accesskey="p" rel="prev">Writing Module Functions</a>, Up: <a href="Writing-Dynamic-Modules.html" accesskey="u" rel="up">Writing Dynamically-Loaded Modules</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Conversion-Between-Lisp-and-Module-Values"><span>E.8.3 Conversion Between Lisp and Module Values<a class="copiable-link" href="#Conversion-Between-Lisp-and-Module-Values"> &para;</a></span></h4>
<a class="index-entry-id" id="index-module-values_002c-conversion"></a>

<a class="index-entry-id" id="index-emacs_005fvalue-data-type"></a>
<p>With very few exceptions, most modules need to exchange data with
Lisp programs that call them: accept arguments to module functions and
return values from module functions.  For this purpose, the module
<abbr class="acronym">API</abbr> provides the <code class="code">emacs_value</code> type, which represents
Emacs Lisp objects communicated via the <abbr class="acronym">API</abbr>; it is the
functional equivalent of the <code class="code">Lisp_Object</code> type used in Emacs C
primitives (see <a class="pxref" href="Writing-Emacs-Primitives.html">Writing Emacs Primitives</a>).  This section describes
the parts of the module <abbr class="acronym">API</abbr> that allow to create
<code class="code">emacs_value</code> objects corresponding to basic Lisp data types, and
how to access from C data in <code class="code">emacs_value</code> objects that
correspond to Lisp objects.
</p>
<p>All of the functions described below are actually <em class="emph">function
pointers</em> provided via the pointer to the environment which every
module function accepts.  Therefore, module code should call these
functions through the environment pointer, like this:
</p>
<div class="example">
<pre class="example-preformatted">emacs_env *env;  /* the environment pointer */
env-&gt;some_function (arguments...);
</pre></div>

<p>The <code class="code">emacs_env</code> pointer will usually come from the first argument
to the module function, or from the call to <code class="code">get_environment</code> if
you need the environment in the module initialization function.
</p>
<p>Most of the functions described below became available in Emacs 25,
the first Emacs release that supported dynamic modules.  For the few
functions that became available in later Emacs releases, we mention
the first Emacs version that supported them.
</p>
<p>The following <abbr class="acronym">API</abbr> functions extract values of various C data
types from <code class="code">emacs_value</code> objects.  They all raise the
<code class="code">wrong-type-argument</code> error condition (see <a class="pxref" href="Type-Predicates.html">Type Predicates</a>)
if the argument <code class="code">emacs_value</code> object is not of the type expected
by the function.  See <a class="xref" href="Module-Nonlocal.html">Nonlocal Exits in Modules</a>, for details of how signaling
errors works in Emacs modules, and how to catch error conditions
inside the module before they are reported to Emacs.  The
<abbr class="acronym">API</abbr> function <code class="code">type_of</code> (see <a class="pxref" href="Module-Misc.html">type_of</a>)
can be used to obtain the type of a <code class="code">emacs_value</code> object.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-extract_005finteger"><span class="category-def">Function: </span><span><code class="def-type">intmax_t</code> <strong class="def-name">extract_integer</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>)</code><a class="copiable-link" href="#index-extract_005finteger"> &para;</a></span></dt>
<dd><p>This function returns the value of a Lisp integer specified by
<var class="var">arg</var>.  The C data type of the return value, <code class="code">intmax_t</code>, is
the widest integer data type supported by the C compiler, typically
<code class="code">long&nbsp;long</code><!-- /@w -->.  If the value of <var class="var">arg</var> doesn&rsquo;t fit into an
<code class="code">intmax_t</code>, the function signals an error using the error symbol
<code class="code">overflow-error</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-extract_005fbig_005finteger"><span class="category-def">Function: </span><span><code class="def-type">bool</code> <strong class="def-name">extract_big_integer</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>, int *<var class="var">sign</var>, ptrdiff_t *<var class="var">count</var>, emacs_limb_t *<var class="var">magnitude</var>)</code><a class="copiable-link" href="#index-extract_005fbig_005finteger"> &para;</a></span></dt>
<dd><p>This function, which is available since Emacs 27, extracts the
integer value of <var class="var">arg</var>.  The value of <var class="var">arg</var> must be an
integer (fixnum or bignum).  If <var class="var">sign</var> is not <code class="code">NULL</code>, it
stores the sign of <var class="var">arg</var> (-1, 0, or +1) into <code class="code">*sign</code>.  The
magnitude is stored into <var class="var">magnitude</var> as follows.  If <var class="var">count</var>
and <var class="var">magnitude</var> are both non-<code class="code">NULL</code>, then <var class="var">magnitude</var> must
point to an array of at least <code class="code">*count</code> <code class="code">unsigned long</code>
elements.  If <var class="var">magnitude</var> is large enough to hold the magnitude of
<var class="var">arg</var>, then this function writes the magnitude into the
<var class="var">magnitude</var> array in little-endian form, stores the number of
array elements written into <code class="code">*count</code>, and returns <code class="code">true</code>.
If <var class="var">magnitude</var> is not large enough, it stores the required array
size into <code class="code">*count</code>, signals an error, and returns <code class="code">false</code>.
If <var class="var">count</var> is not <code class="code">NULL</code> and <var class="var">magnitude</var> is <code class="code">NULL</code>,
then the function stores the required array size into <code class="code">*count</code>
and returns <code class="code">true</code>.
</p>
<p>Emacs guarantees that the maximum required value of <code class="code">*count</code>
never exceeds <code class="code">min (PTRDIFF_MAX, SIZE_MAX) / sizeof
(emacs_limb_t)</code>, so you can use <code class="code">malloc (*count * sizeof *magnitude)</code>
to allocate the <code class="code">magnitude</code> array without worrying about integer
overflow in the size calculation.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-emacs_005flimb_005ft"><span class="category-def">Type alias: </span><span><strong class="def-name">emacs_limb_t</strong><a class="copiable-link" href="#index-emacs_005flimb_005ft"> &para;</a></span></dt>
<dd><p>This is an unsigned integer type, used as the element type for the
magnitude arrays for the big integer conversion functions.  The type
is guaranteed to have unique object representations, i.e., no padding
bits.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-EMACS_005fLIMB_005fMAX"><span class="category-def">Macro: </span><span><strong class="def-name">EMACS_LIMB_MAX</strong><a class="copiable-link" href="#index-EMACS_005fLIMB_005fMAX"> &para;</a></span></dt>
<dd><p>This macro expands to a constant expression specifying the maximum
possible value for an <code class="code">emacs_limb_t</code> object.
The expression is suitable for use in <code class="code">#if</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-extract_005ffloat"><span class="category-def">Function: </span><span><code class="def-type">double</code> <strong class="def-name">extract_float</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>)</code><a class="copiable-link" href="#index-extract_005ffloat"> &para;</a></span></dt>
<dd><p>This function returns the value of a Lisp float specified by
<var class="var">arg</var>, as a C <code class="code">double</code> value.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-extract_005ftime"><span class="category-def">Function: </span><span><code class="def-type">struct timespec</code> <strong class="def-name">extract_time</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>)</code><a class="copiable-link" href="#index-extract_005ftime"> &para;</a></span></dt>
<dd><p>This function, which is available since Emacs 27, interprets <var class="var">arg</var>
as an Emacs Lisp time value and returns the corresponding <code class="code">struct
timespec</code>.  See <a class="xref" href="Time-of-Day.html">Time of Day</a>.  <code class="code">struct timespec</code> represents a
timestamp with nanosecond precision.  It has the following members:
</p>
<dl class="table">
<dt><code class="code">time_t tv_sec</code></dt>
<dd><p>Whole number of seconds.
</p></dd>
<dt><code class="code">long tv_nsec</code></dt>
<dd><p>Fractional seconds as a number of nanoseconds.
For timestamps returned by <code class="code">extract_time</code>,
this is always nonnegative and less than one billion.
(Although POSIX requires the type of <code class="code">tv_nsec</code> to be <code class="code">long</code>,
the type is <code class="code">long long</code> on some nonstandard platforms.)
</p></dd>
</dl>

<p>See <a data-manual="libc" href="https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html#Elapsed-Time">(libc)Elapsed Time</a>.
</p>
<p>If <var class="var">time</var> has higher precision than nanoseconds, then this
function truncates it to nanosecond precision towards negative
infinity.  This function signals an error if <var class="var">time</var> (truncated to
nanoseconds) cannot be represented by <code class="code">struct timespec</code>.  For
example, if <code class="code">time_t</code> is a 32-bit integer type, then a <var class="var">time</var>
value of ten billion seconds would signal an error, but a <var class="var">time</var>
value of 600 picoseconds would get truncated to zero.
</p>
<p>If you need to deal with time values that are not representable by
<code class="code">struct timespec</code>, or if you want higher precision, call the Lisp
function <code class="code">encode-time</code> and work with its return value.
See <a class="xref" href="Time-Conversion.html">Time Conversion</a>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-copy_005fstring_005fcontents"><span class="category-def">Function: </span><span><code class="def-type">bool</code> <strong class="def-name">copy_string_contents</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>, char *<var class="var">buf</var>, ptrdiff_t *<var class="var">len</var>)</code><a class="copiable-link" href="#index-copy_005fstring_005fcontents"> &para;</a></span></dt>
<dd><p>This function stores the UTF-8 encoded text of a Lisp string specified
by <var class="var">arg</var> in the array of <code class="code">char</code> pointed by <var class="var">buf</var>, which
should have enough space to hold at least <code class="code">*<var class="var">len</var></code> bytes,
including the terminating null byte.  The argument <var class="var">len</var> must not
be a <code class="code">NULL</code> pointer, and, when the function is called, it should
point to a value that specifies the size of <var class="var">buf</var> in bytes.
</p>
<p>If the buffer size specified by <code class="code">*<var class="var">len</var></code> is large enough to
hold the string&rsquo;s text, the function stores in <code class="code">*<var class="var">len</var></code> the
actual number of bytes copied to <var class="var">buf</var>, including the terminating
null byte, and returns <code class="code">true</code>.  If the buffer is too small, the
function raises the <code class="code">args-out-of-range</code> error condition, stores
the required number of bytes in <code class="code">*<var class="var">len</var></code>, and returns
<code class="code">false</code>.  See <a class="xref" href="Module-Nonlocal.html">Nonlocal Exits in Modules</a>, for how to handle pending error
conditions.
</p>
<p>The argument <var class="var">buf</var> can be a <code class="code">NULL</code> pointer, in which case the
function stores in <code class="code">*<var class="var">len</var></code> the number of bytes required for
storing the contents of <var class="var">arg</var>, and returns <code class="code">true</code>.  This is
how you can determine the size of <var class="var">buf</var> needed to store a
particular string: first call <code class="code">copy_string_contents</code> with
<code class="code">NULL</code> as <var class="var">buf</var>, then allocate enough memory to hold the
number of bytes stored by the function in <code class="code">*<var class="var">len</var></code>, and call
the function again with non-<code class="code">NULL</code> <var class="var">buf</var> to actually perform
the text copying.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-vec_005fget"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">vec_get</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">vector</var>, ptrdiff_t <var class="var">index</var>)</code><a class="copiable-link" href="#index-vec_005fget"> &para;</a></span></dt>
<dd><p>This function returns the element of <var class="var">vector</var> at <var class="var">index</var>.  The
<var class="var">index</var> of the first vector element is zero.  The function raises
the <code class="code">args-out-of-range</code> error condition if the value of
<var class="var">index</var> is invalid.  To extract C data from the value the function
returns, use the other extraction functions described here, as
appropriate for the Lisp data type stored in that element of the
vector.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-vec_005fsize"><span class="category-def">Function: </span><span><code class="def-type">ptrdiff_t</code> <strong class="def-name">vec_size</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">vector</var>)</code><a class="copiable-link" href="#index-vec_005fsize"> &para;</a></span></dt>
<dd><p>This function returns the number of elements in <var class="var">vector</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-vec_005fset"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">vec_set</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">vector</var>, ptrdiff_t <var class="var">index</var>, emacs_value <var class="var">value</var>)</code><a class="copiable-link" href="#index-vec_005fset"> &para;</a></span></dt>
<dd><p>This function stores <var class="var">value</var> in the element of <var class="var">vector</var> whose
index is <var class="var">index</var>.  It raises the <code class="code">args-out-of-range</code> error
condition if the value of <var class="var">index</var> is invalid.
</p></dd></dl>

<p>The following <abbr class="acronym">API</abbr> functions create <code class="code">emacs_value</code>
objects from basic C data types.  They all return the created
<code class="code">emacs_value</code> object.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005finteger"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_integer</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, intmax_t <var class="var">n</var>)</code><a class="copiable-link" href="#index-make_005finteger"> &para;</a></span></dt>
<dd><p>This function takes an integer argument <var class="var">n</var> and returns the
corresponding <code class="code">emacs_value</code> object.  It returns either a fixnum
or a bignum depending on whether the value of <var class="var">n</var> is inside the
limits set by <code class="code">most-negative-fixnum</code> and
<code class="code">most-positive-fixnum</code> (see <a class="pxref" href="Integer-Basics.html">Integer Basics</a>).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005fbig_005finteger"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_big_integer</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, int sign, ptrdiff_t count, const emacs_limb_t *magnitude)</code><a class="copiable-link" href="#index-make_005fbig_005finteger"> &para;</a></span></dt>
<dd><p>This function, which is available since Emacs 27, takes an
arbitrary-sized integer argument and returns a corresponding
<code class="code">emacs_value</code> object.  The <var class="var">sign</var> argument gives the sign of
the return value.  If <var class="var">sign</var> is nonzero, then <var class="var">magnitude</var> must
point to an array of at least <var class="var">count</var> elements specifying the
little-endian magnitude of the return value.
</p></dd></dl>

<p>The following example uses the GNU Multiprecision Library (GMP) to
calculate the next probable prime after a given integer.
See <a data-manual="gmp" href="https://www.gmplib.org/manual/index.html#Top">(gmp)Top</a>, for a general overview of GMP, and see <a data-manual="gmp" href="https://www.gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export">(gmp)Integer
Import and Export</a> for how to convert the <code class="code">magnitude</code> array
to and from GMP <code class="code">mpz_t</code> values.
</p>
<div class="example">
<pre class="example-preformatted">#include &lt;emacs-module.h&gt;
int plugin_is_GPL_compatible;

#include &lt;assert.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;gmp.h&gt;

static void
memory_full (emacs_env *env)
{
  static const char message[] = &quot;Memory exhausted&quot;;
  emacs_value data = env-&gt;make_string (env, message,
                                       strlen (message));
  env-&gt;non_local_exit_signal
    (env, env-&gt;intern (env, &quot;error&quot;),
     env-&gt;funcall (env, env-&gt;intern (env, &quot;list&quot;), 1, &amp;data));
}

enum
{
  order = -1, endian = 0, nails = 0,
  limb_size = sizeof (emacs_limb_t),
  max_nlimbs = ((SIZE_MAX &lt; PTRDIFF_MAX ? SIZE_MAX : PTRDIFF_MAX)
                / limb_size)
};

static bool
extract_big_integer (emacs_env *env, emacs_value arg, mpz_t result)
{
  ptrdiff_t nlimbs;
  bool ok = env-&gt;extract_big_integer (env, arg, NULL, &amp;nlimbs, NULL);
  if (!ok)
    return false;
  assert (0 &lt; nlimbs &amp;&amp; nlimbs &lt;= max_nlimbs);
  emacs_limb_t *magnitude = malloc (nlimbs * limb_size);
  if (magnitude == NULL)
    {
      memory_full (env);
      return false;
    }
  int sign;
  ok = env-&gt;extract_big_integer (env, arg, &amp;sign, &amp;nlimbs, magnitude);
  assert (ok);
  mpz_import (result, nlimbs, order, limb_size, endian, nails, magnitude);
  free (magnitude);
  if (sign &lt; 0)
    mpz_neg (result, result);
  return true;
}

static emacs_value
make_big_integer (emacs_env *env, const mpz_t value)
{
  size_t nbits = mpz_sizeinbase (value, 2);
  int bitsperlimb = CHAR_BIT * limb_size - nails;
  size_t nlimbs = nbits / bitsperlimb + (nbits % bitsperlimb != 0);
  emacs_limb_t *magnitude
    = nlimbs &lt;= max_nlimbs ? malloc (nlimbs * limb_size) : NULL;
  if (magnitude == NULL)
    {
      memory_full (env);
      return NULL;
    }
  size_t written;
  mpz_export (magnitude, &amp;written, order, limb_size, endian, nails, value);
  assert (written == nlimbs);
  assert (nlimbs &lt;= PTRDIFF_MAX);
  emacs_value result = env-&gt;make_big_integer (env, mpz_sgn (value),
                                              nlimbs, magnitude);
  free (magnitude);
  return result;
}

static emacs_value
next_prime (emacs_env *env, ptrdiff_t nargs, emacs_value *args,
            void *data)
{
  assert (nargs == 1);
  mpz_t p;
  mpz_init (p);
  extract_big_integer (env, args[0], p);
  mpz_nextprime (p, p);
  emacs_value result = make_big_integer (env, p);
  mpz_clear (p);
  return result;
}

int
emacs_module_init (struct emacs_runtime *runtime)
{
  emacs_env *env = runtime-&gt;get_environment (runtime);
  emacs_value symbol = env-&gt;intern (env, &quot;next-prime&quot;);
  emacs_value func
    = env-&gt;make_function (env, 1, 1, next_prime, NULL, NULL);
  emacs_value args[] = {symbol, func};
  env-&gt;funcall (env, env-&gt;intern (env, &quot;defalias&quot;), 2, args);
  return 0;
}
</pre></div>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005ffloat"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_float</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, double <var class="var">d</var>)</code><a class="copiable-link" href="#index-make_005ffloat"> &para;</a></span></dt>
<dd><p>This function takes a <code class="code">double</code> argument <var class="var">d</var> and returns the
corresponding Emacs floating-point value.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005ftime"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_time</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, struct timespec <var class="var">time</var>)</code><a class="copiable-link" href="#index-make_005ftime"> &para;</a></span></dt>
<dd><p>This function, which is available since Emacs 27, takes a <code class="code">struct
timespec</code> argument <var class="var">time</var> and returns the corresponding Emacs
timestamp as a pair <code class="code">(<var class="var">ticks</var> . <var class="var">hz</var>)</code>.  See <a class="xref" href="Time-of-Day.html">Time of Day</a>.  The return value represents exactly the same timestamp as
<var class="var">time</var>: all input values are representable, and there is never a
loss of precision.  <code class="code"><var class="var">time</var>.tv_sec</code> and
<code class="code"><var class="var">time</var>.tv_nsec</code> can be arbitrary values.  In particular,
there&rsquo;s no requirement that <var class="var">time</var> be normalized.  This means that
<code class="code"><var class="var">time</var>.tv_nsec</code> can be negative or larger than 999,999,999.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005fstring"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_string</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, const char *<var class="var">str</var>, ptrdiff_t <var class="var">len</var>)</code><a class="copiable-link" href="#index-make_005fstring"> &para;</a></span></dt>
<dd><p>This function creates an Emacs string from C text string pointed by
<var class="var">str</var> whose length in bytes, not including the terminating null
byte, is <var class="var">len</var>.  The original string in <var class="var">str</var> can be either an
<abbr class="acronym">ASCII</abbr> string or a UTF-8 encoded non-<abbr class="acronym">ASCII</abbr> string;
it can include embedded null bytes, and doesn&rsquo;t have to end in a
terminating null byte at <code class="code"><var class="var">str</var>[<var class="var">len</var>]</code>.  The function
raises the <code class="code">overflow-error</code> error condition if <var class="var">len</var> is
negative or exceeds the maximum length of an Emacs string.  If
<var class="var">len</var> is zero, then <var class="var">str</var> can be <code class="code">NULL</code>, otherwise it
must point to valid memory.  For nonzero <var class="var">len</var>, <code class="code">make_string</code>
returns unique mutable string objects.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005funibyte_005fstring"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_unibyte_string</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, const char *<var class="var">str</var>, ptrdiff_t <var class="var">len</var>)</code><a class="copiable-link" href="#index-make_005funibyte_005fstring"> &para;</a></span></dt>
<dd><p>This function is like <code class="code">make_string</code>, but has no restrictions on
the values of the bytes in the C string, and can be used to pass
binary data to Emacs in the form of a unibyte string.
</p></dd></dl>

<p>The <abbr class="acronym">API</abbr> does not provide functions to manipulate Lisp data
structures, for example, create lists with <code class="code">cons</code> and <code class="code">list</code>
(see <a class="pxref" href="Building-Lists.html">Building Cons Cells and Lists</a>), extract list members with <code class="code">car</code> and
<code class="code">cdr</code> (see <a class="pxref" href="List-Elements.html">Accessing Elements of Lists</a>), create vectors with <code class="code">vector</code>
(see <a class="pxref" href="Vector-Functions.html">Functions for Vectors</a>), etc.  For these, use <code class="code">intern</code> and
<code class="code">funcall</code>, described in the next subsection, to call the
corresponding Lisp functions.
</p>
<p>Normally, <code class="code">emacs_value</code> objects have a rather short lifetime: it
ends when the <code class="code">emacs_env</code> pointer used for their creation goes
out of scope.  Occasionally, you may need to create <em class="dfn">global
references</em>: <code class="code">emacs_value</code> objects that live as long as you
wish.  Use the following two functions to manage such objects.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005fglobal_005fref"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_global_ref</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">value</var>)</code><a class="copiable-link" href="#index-make_005fglobal_005fref"> &para;</a></span></dt>
<dd><p>This function returns a global reference for <var class="var">value</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-free_005fglobal_005fref"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">free_global_ref</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">global_value</var>)</code><a class="copiable-link" href="#index-free_005fglobal_005fref"> &para;</a></span></dt>
<dd><p>This function frees the <var class="var">global_value</var> previously created by
<code class="code">make_global_ref</code>.  The <var class="var">global_value</var> is no longer valid
after the call.  Your module code should pair each call to
<code class="code">make_global_ref</code> with the corresponding <code class="code">free_global_ref</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-user-pointer_002c-using-in-module-functions"></a>
<p>An alternative to keeping around C data structures that need to be
passed to module functions later is to create <em class="dfn">user pointer</em>
objects.  A user pointer, or <code class="code">user-ptr</code>, object is a Lisp object
that encapsulates a C pointer and can have an associated finalizer
function, which is called when the object is garbage-collected
(see <a class="pxref" href="Garbage-Collection.html">Garbage Collection</a>).  The module <abbr class="acronym">API</abbr> provides
functions to create and access <code class="code">user-ptr</code> objects.  These
functions raise the <code class="code">wrong-type-argument</code> error condition if they
are called on <code class="code">emacs_value</code> that doesn&rsquo;t represent a
<code class="code">user-ptr</code> object.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005fuser_005fptr"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_user_ptr</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_finalizer <var class="var">fin</var>, void *<var class="var">ptr</var>)</code><a class="copiable-link" href="#index-make_005fuser_005fptr"> &para;</a></span></dt>
<dd><p>This function creates and returns a <code class="code">user-ptr</code> object which wraps
the C pointer <var class="var">ptr</var>.  The finalizer function <var class="var">fin</var> can be a
<code class="code">NULL</code> pointer (meaning no finalizer), or it can be a function of
the following signature:
</p>
<div class="example">
<pre class="example-preformatted">typedef void (*emacs_finalizer) (void *<var class="var">ptr</var>);
</pre></div>

<p>If <var class="var">fin</var> is not a <code class="code">NULL</code> pointer, it will be called with the
<var class="var">ptr</var> as the argument when the <code class="code">user-ptr</code> object is
garbage-collected.  Don&rsquo;t run any expensive code in a finalizer,
because GC must finish quickly to keep Emacs responsive.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-_0028emacs_005fenv"><span class="category-def">Function: </span><span><code class="def-type">void *get_user_ptr</code> <strong class="def-name">(emacs_env</strong> <code class="def-code-arguments">*<var class="var">env</var>, emacs_value <var class="var">arg</var>)</code><a class="copiable-link" href="#index-_0028emacs_005fenv"> &para;</a></span></dt>
<dd><p>This function extracts the C pointer from the Lisp object represented
by <var class="var">arg</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-set_005fuser_005fptr"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">set_user_ptr</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>, void *<var class="var">ptr</var>)</code><a class="copiable-link" href="#index-set_005fuser_005fptr"> &para;</a></span></dt>
<dd><p>This function sets the C pointer embedded in the <code class="code">user-ptr</code>
object represented by <var class="var">arg</var> to <var class="var">ptr</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-get_005fuser_005ffinalizer"><span class="category-def">Function: </span><span><code class="def-type">emacs_finalizer</code> <strong class="def-name">get_user_finalizer</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>)</code><a class="copiable-link" href="#index-get_005fuser_005ffinalizer"> &para;</a></span></dt>
<dd><p>This function returns the finalizer of the <code class="code">user-ptr</code> object
represented by <var class="var">arg</var>, or <code class="code">NULL</code> if it doesn&rsquo;t have a
finalizer.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-set_005fuser_005ffinalizer"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">set_user_finalizer</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>, emacs_finalizer <var class="var">fin</var>)</code><a class="copiable-link" href="#index-set_005fuser_005ffinalizer"> &para;</a></span></dt>
<dd><p>This function changes the finalizer of the <code class="code">user-ptr</code> object
represented by <var class="var">arg</var> to be <var class="var">fin</var>.  If <var class="var">fin</var> is a
<code class="code">NULL</code> pointer, the <code class="code">user-ptr</code> object will have no
finalizer.
</p></dd></dl>

<p>Note that the <code class="code">emacs_finalizer</code> type works for both user pointer
an module function finalizers.  See <a class="xref" href="Module-Functions.html#Module-Function-Finalizers">Module Function Finalizers</a>.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Module-Misc.html">Miscellaneous Convenience Functions for Modules</a>, Previous: <a href="Module-Functions.html">Writing Module Functions</a>, Up: <a href="Writing-Dynamic-Modules.html">Writing Dynamically-Loaded Modules</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
