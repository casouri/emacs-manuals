<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.2.

Copyright Â© 1990-1996, 1998-2024 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Accessing Node Information (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Accessing Node Information (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Accessing Node Information (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-Program-Source.html" rel="up" title="Parsing Program Source">
<link href="Pattern-Matching.html" rel="next" title="Pattern Matching">
<link href="Retrieving-Nodes.html" rel="prev" title="Retrieving Nodes">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Accessing-Node-Information">
<div class="nav-panel">
<p>
Next: <a href="Pattern-Matching.html" accesskey="n" rel="next">Pattern Matching Tree-sitter Nodes</a>, Previous: <a href="Retrieving-Nodes.html" accesskey="p" rel="prev">Retrieving Nodes</a>, Up: <a href="Parsing-Program-Source.html" accesskey="u" rel="up">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Accessing-Node-Information-1"><span>37.4 Accessing Node Information<a class="copiable-link" href="#Accessing-Node-Information-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-information-of-node_002c-syntax-trees"></a>
<a class="index-entry-id" id="index-syntax-trees_002c-node-information"></a>

<h3 class="heading" id="Basic-information-of-Node"><span>Basic information of Node<a class="copiable-link" href="#Basic-information-of-Node"> &para;</a></span></h3>

<p>Every node is associated with a parser, and that parser is associated
with a buffer.  The following functions retrieve them.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dparser"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-parser</strong> <var class="def-var-arguments">node</var><a class="copiable-link" href="#index-treesit_002dnode_002dparser"> &para;</a></span></dt>
<dd><p>This function returns <var class="var">node</var>&rsquo;s associated parser.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dbuffer"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-buffer</strong> <var class="def-var-arguments">node</var><a class="copiable-link" href="#index-treesit_002dnode_002dbuffer"> &para;</a></span></dt>
<dd><p>This function returns <var class="var">node</var>&rsquo;s parser&rsquo;s associated buffer.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dlanguage"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-language</strong> <var class="def-var-arguments">node</var><a class="copiable-link" href="#index-treesit_002dnode_002dlanguage"> &para;</a></span></dt>
<dd><p>This function returns <var class="var">node</var>&rsquo;s parser&rsquo;s associated language.
</p></dd></dl>

<p>Each node represents a portion of text in the buffer.  Functions below
find relevant information about that text.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dstart"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-start</strong> <var class="def-var-arguments">node</var><a class="copiable-link" href="#index-treesit_002dnode_002dstart"> &para;</a></span></dt>
<dd><p>Return the start position of <var class="var">node</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dend"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-end</strong> <var class="def-var-arguments">node</var><a class="copiable-link" href="#index-treesit_002dnode_002dend"> &para;</a></span></dt>
<dd><p>Return the end position of <var class="var">node</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dtext"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-text</strong> <var class="def-var-arguments">node &amp;optional object</var><a class="copiable-link" href="#index-treesit_002dnode_002dtext"> &para;</a></span></dt>
<dd><p>Return the buffer text that <var class="var">node</var> represents, as a string.  (If
<var class="var">node</var> is retrieved from parsing a string, it will be the text
from that string.)
</p></dd></dl>

<a class="index-entry-id" id="index-predicates-for-syntax-tree-nodes"></a>
<p>Here are some predicates on tree-sitter nodes:
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dp"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-p</strong> <var class="def-var-arguments">object</var><a class="copiable-link" href="#index-treesit_002dnode_002dp"> &para;</a></span></dt>
<dd><p>Checks if <var class="var">object</var> is a tree-sitter syntax node.
</p></dd></dl>

<a class="index-entry-id" id="index-compare-tree_002dsitter-syntax-nodes"></a>
<a class="index-entry-id" id="index-tree_002dsitter-nodes_002c-comparing"></a>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002deq"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-eq</strong> <var class="def-var-arguments">node1 node2</var><a class="copiable-link" href="#index-treesit_002dnode_002deq"> &para;</a></span></dt>
<dd><p>Checks if <var class="var">node1</var> and <var class="var">node2</var> refer to the same node in a
tree-sitter syntax tree.  This function uses the same equivalence
metric as <code class="code">equal</code>.  You can also compare nodes using <code class="code">equal</code>
(see <a class="pxref" href="Equality-Predicates.html">Equality Predicates</a>).
</p></dd></dl>

<h3 class="heading" id="Property-information"><span>Property information<a class="copiable-link" href="#Property-information"> &para;</a></span></h3>

<p>In general, nodes in a concrete syntax tree fall into two categories:
<em class="dfn">named nodes</em> and <em class="dfn">anonymous nodes</em>.  Whether a node is named
or anonymous is determined by the language grammar
(see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-named-node">named node</a>).
</p>
<a class="index-entry-id" id="index-tree_002dsitter-missing-node"></a>
<a class="index-entry-id" id="index-missing-node_002c-tree_002dsitter"></a>
<p>Apart from being named or anonymous, a node can have other properties.
A node can be &ldquo;missing&rdquo;: such nodes are inserted by the parser in
order to recover from certain kinds of syntax errors, i.e., something
should probably be there according to the grammar, but is not there.
This can happen during editing of the program source, when the source
is not yet in its final form.
</p>
<a class="index-entry-id" id="index-tree_002dsitter-extra-node"></a>
<a class="index-entry-id" id="index-extra-node_002c-tree_002dsitter"></a>
<p>A node can be &ldquo;extra&rdquo;: such nodes represent things like comments,
which can appear anywhere in the text.
</p>
<a class="index-entry-id" id="index-tree_002dsitter-outdated-node"></a>
<a class="index-entry-id" id="index-outdated-node_002c-tree_002dsitter"></a>
<p>A node can be &ldquo;outdated&rdquo;, if its parser has reparsed at least once
after the node was created.
</p>
<a class="index-entry-id" id="index-tree_002dsitter-node-that-has-error"></a>
<a class="index-entry-id" id="index-has-error_002c-tree_002dsitter-node"></a>
<p>A node &ldquo;has error&rdquo; if the text it spans contains a syntax error.  It
can be that the node itself has an error, or one of its descendants
has an error.
</p>
<a class="index-entry-id" id="index-tree_002dsitter_002c-live-parsing-node"></a>
<a class="index-entry-id" id="index-live-node_002c-tree_002dsitter"></a>
<p>A node is considered <em class="dfn">live</em> if its parser is not deleted, and the
buffer to which it belongs is a live buffer (see <a class="pxref" href="Killing-Buffers.html">Killing Buffers</a>).
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dcheck"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-check</strong> <var class="def-var-arguments">node property</var><a class="copiable-link" href="#index-treesit_002dnode_002dcheck"> &para;</a></span></dt>
<dd><p>This function returns non-<code class="code">nil</code> if <var class="var">node</var> has the specified
<var class="var">property</var>.  <var class="var">property</var> can be <code class="code">named</code>, <code class="code">missing</code>,
<code class="code">extra</code>, <code class="code">outdated</code>, <code class="code">has-error</code>, or <code class="code">live</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dtype"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-type</strong> <var class="def-var-arguments">node</var><a class="copiable-link" href="#index-treesit_002dnode_002dtype"> &para;</a></span></dt>
<dd><p>Named nodes have &ldquo;types&rdquo; (see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-node-type">node type</a>).
For example, a named node can be a <code class="code">string_literal</code> node, where
<code class="code">string_literal</code> is its type.  The type of an anonymous node is
just the text that the node represents; e.g., the type of a &lsquo;<samp class="samp">,</samp>&rsquo;
node is just &lsquo;<samp class="samp">,</samp>&rsquo;.
</p>
<p>This function returns <var class="var">node</var>&rsquo;s type as a string.
</p></dd></dl>

<h3 class="heading" id="Information-as-a-child-or-parent"><span>Information as a child or parent<a class="copiable-link" href="#Information-as-a-child-or-parent"> &para;</a></span></h3>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dindex"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-index</strong> <var class="def-var-arguments">node &amp;optional named</var><a class="copiable-link" href="#index-treesit_002dnode_002dindex"> &para;</a></span></dt>
<dd><p>This function returns the index of <var class="var">node</var> as a child node of its
parent.  If <var class="var">named</var> is non-<code class="code">nil</code>, it only counts named nodes
(see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-named-node">named node</a>).
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dfield_002dname"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-field-name</strong> <var class="def-var-arguments">node</var><a class="copiable-link" href="#index-treesit_002dnode_002dfield_002dname"> &para;</a></span></dt>
<dd><p>A child of a parent node could have a field name (see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-node-field-name">field name</a>).  This function returns the field name
of <var class="var">node</var> as a child of its parent.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dfield_002dname_002dfor_002dchild"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-field-name-for-child</strong> <var class="def-var-arguments">node n</var><a class="copiable-link" href="#index-treesit_002dnode_002dfield_002dname_002dfor_002dchild"> &para;</a></span></dt>
<dd><p>This function returns the field name of the <var class="var">n</var>&rsquo;th child of
<var class="var">node</var>.  It returns <code class="code">nil</code> if there is no <var class="var">n</var>&rsquo;th child, or
the <var class="var">n</var>&rsquo;th child doesn&rsquo;t have a field name.
</p>
<p>Note that <var class="var">n</var> counts both named and anonymous children, and
<var class="var">n</var> can be negative, e.g., &minus;1 represents the last child.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dnode_002dchild_002dcount"><span class="category-def">Function: </span><span><strong class="def-name">treesit-node-child-count</strong> <var class="def-var-arguments">node &amp;optional named</var><a class="copiable-link" href="#index-treesit_002dnode_002dchild_002dcount"> &para;</a></span></dt>
<dd><p>This function returns the number of children of <var class="var">node</var>.  If
<var class="var">named</var> is non-<code class="code">nil</code>, it only counts named children
(see <a class="pxref" href="Language-Grammar.html#tree_002dsitter-named-node">named node</a>).
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Pattern-Matching.html">Pattern Matching Tree-sitter Nodes</a>, Previous: <a href="Retrieving-Nodes.html">Retrieving Nodes</a>, Up: <a href="Parsing-Program-Source.html">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
