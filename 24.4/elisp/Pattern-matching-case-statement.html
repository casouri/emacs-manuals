<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 24.4.

Copyright Â© 1990-1996, 1998-2014 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Pattern matching case statement (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Pattern matching case statement (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Pattern matching case statement (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Conditionals.html" rel="up" title="Conditionals">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Pattern-matching-case-statement">
<div class="nav-panel">
<p>
Up: <a href="Conditionals.html" accesskey="u" rel="up">Conditionals</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Pattern-matching-case-statement-1"><span>10.2.1 Pattern matching case statement<a class="copiable-link" href="#Pattern-matching-case-statement-1"> &para;</a></span></h4>
<a class="index-entry-id" id="index-pcase"></a>
<a class="index-entry-id" id="index-pattern-matching"></a>

<p>To compare a particular value against various possible cases, the macro
<code class="code">pcase</code> can come handy.  It takes the following form:
</p>
<div class="example">
<pre class="example-preformatted">(pcase <var class="var">exp</var> <var class="var">branch</var>1 <var class="var">branch</var>2 <var class="var">branch</var>3 ...)
</pre></div>

<p>where each <var class="var">branch</var> takes the form <code class="code">(<var class="var">upattern</var>
<var class="var">body-forms</var>&hellip;)</code>.
</p>
<p>It will first evaluate <var class="var">exp</var> and then compare the value against each
<var class="var">upattern</var> to see which <var class="var">branch</var> to use, after which it will run the
corresponding <var class="var">body-forms</var>.  A common use case is to distinguish
between a few different constant values:
</p>
<div class="example">
<pre class="example-preformatted">(pcase (get-return-code x)
  (`success       (message &quot;Done!&quot;))
  (`would-block   (message &quot;Sorry, can't do it now&quot;))
  (`read-only     (message &quot;The shmliblick is read-only&quot;))
  (`access-denied (message &quot;You do not have the needed rights&quot;))
  (code           (message &quot;Unknown return code %S&quot; code)))
</pre></div>

<p>In the last clause, <code class="code">code</code> is a variable that gets bound to the value that
was returned by <code class="code">(get-return-code x)</code>.
</p>
<p>To give a more complex example, a simple interpreter for a little
expression language could look like (note that this example requires
lexical binding):
</p>
<div class="example">
<pre class="example-preformatted">(defun evaluate (exp env)
  (pcase exp
    (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))
    (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))
    (`(fn ,arg ,body)   (lambda (val)
                          (evaluate body (cons (cons arg val) env))))
    ((pred numberp)     exp)
    ((pred symbolp)     (cdr (assq exp env)))
    (_                  (error &quot;Unknown expression %S&quot; exp))))
</pre></div>

<p>Where <code class="code">`(add ,x ,y)</code> is a pattern that checks that <code class="code">exp</code> is a three
element list starting with the symbol <code class="code">add</code>, then extracts the second and
third elements and binds them to the variables <code class="code">x</code> and <code class="code">y</code>.
<code class="code">(pred numberp)</code> is a pattern that simply checks that <code class="code">exp</code>
is a number, and <code class="code">_</code> is the catch-all pattern that matches anything.
</p>
<p>Here are some sample programs including their evaluation results:
</p>
<div class="example">
<pre class="example-preformatted">(evaluate '(add 1 2) nil)                 ;=&gt; 3
(evaluate '(add x y) '((x . 1) (y . 2)))  ;=&gt; 3
(evaluate '(call (fn x (add 1 x)) 2) nil) ;=&gt; 3
(evaluate '(sub 1 2) nil)                 ;=&gt; error
</pre></div>

<p>There are two kinds of patterns involved in <code class="code">pcase</code>, called
<em class="emph">U-patterns</em> and <em class="emph">Q-patterns</em>.  The <var class="var">upattern</var> mentioned above
are U-patterns and can take the following forms:
</p>
<dl class="table">
<dt><code class="code">`<var class="var">qpattern</var></code></dt>
<dd><p>This is one of the most common form of patterns.  The intention is to mimic the
backquote macro: this pattern matches those values that could have been built
by such a backquote expression.  Since we&rsquo;re pattern matching rather than
building a value, the unquote does not indicate where to plug an expression,
but instead it lets one specify a U-pattern that should match the value at
that location.
</p>
<p>More specifically, a Q-pattern can take the following forms:
</p><dl class="table">
<dt><code class="code">(<var class="var">qpattern1</var> . <var class="var">qpattern2</var>)</code></dt>
<dd><p>This pattern matches any cons cell whose <code class="code">car</code> matches <var class="var">QPATTERN1</var> and
whose <code class="code">cdr</code> matches <var class="var">PATTERN2</var>.
</p></dd>
<dt><code class="code"><var class="var">atom</var></code></dt>
<dd><p>This pattern matches any atom <code class="code">equal</code> to <var class="var">atom</var>.
</p></dd>
<dt><code class="code">,<var class="var">upattern</var></code></dt>
<dd><p>This pattern matches any object that matches the <var class="var">upattern</var>.
</p></dd>
</dl>

</dd>
<dt><code class="code"><var class="var">symbol</var></code></dt>
<dd><p>A mere symbol in a U-pattern matches anything, and additionally let-binds this
symbol to the value that it matched, so that you can later refer to it, either
in the <var class="var">body-forms</var> or also later in the pattern.
</p></dd>
<dt><code class="code">_</code></dt>
<dd><p>This so-called <em class="emph">don&rsquo;t care</em> pattern matches anything, like the previous
one, but unlike symbol patterns it does not bind any variable.
</p></dd>
<dt><code class="code">(pred <var class="var">pred</var>)</code></dt>
<dd><p>This pattern matches if the function <var class="var">pred</var> returns non-<code class="code">nil</code> when
called with the object being matched.
</p></dd>
<dt><code class="code">(or <var class="var">upattern1</var> <var class="var">upattern2</var>&hellip;)</code></dt>
<dd><p>This pattern matches as soon as one of the argument patterns succeeds.
All argument patterns should let-bind the same variables.
</p></dd>
<dt><code class="code">(and <var class="var">upattern1</var> <var class="var">upattern2</var>&hellip;)</code></dt>
<dd><p>This pattern matches only if all the argument patterns succeed.
</p></dd>
<dt><code class="code">(guard <var class="var">exp</var>)</code></dt>
<dd><p>This pattern ignores the object being examined and simply succeeds if <var class="var">exp</var>
evaluates to non-<code class="code">nil</code> and fails otherwise.  It is typically used inside
an <code class="code">and</code> pattern.  For example, <code class="code">(and x (guard (&lt; x 10)))</code>
is a pattern which matches any number smaller than 10 and let-binds it to
the variable <code class="code">x</code>.
</p></dd>
</dl>

</div>
<hr>
<div class="nav-panel">
<p>
Up: <a href="Conditionals.html">Conditionals</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
