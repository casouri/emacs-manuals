<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.1.

Copyright Â© 1990-1996, 1998-2023 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Using Parser (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Using Parser (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Using Parser (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Parsing-Program-Source.html" rel="up" title="Parsing Program Source">
<link href="Retrieving-Nodes.html" rel="next" title="Retrieving Nodes">
<link href="Language-Grammar.html" rel="prev" title="Language Grammar">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Using-Parser">
<div class="nav-panel">
<p>
Next: <a href="Retrieving-Nodes.html" accesskey="n" rel="next">Retrieving Nodes</a>, Previous: <a href="Language-Grammar.html" accesskey="p" rel="prev">Tree-sitter Language Grammar</a>, Up: <a href="Parsing-Program-Source.html" accesskey="u" rel="up">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Using-Tree_002dsitter-Parser"><span>37.2 Using Tree-sitter Parser<a class="copiable-link" href="#Using-Tree_002dsitter-Parser"> &para;</a></span></h3>
<a class="index-entry-id" id="index-tree_002dsitter-parser_002c-using"></a>

<p>This section describes how to create and configure a tree-sitter
parser.  In Emacs, each tree-sitter parser is associated with a
buffer.  As the user edits the buffer, the associated parser and
syntax tree are automatically kept up-to-date.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-treesit_002dmax_002dbuffer_002dsize"><span class="category-def">Variable: </span><span><strong class="def-name">treesit-max-buffer-size</strong><a class="copiable-link" href="#index-treesit_002dmax_002dbuffer_002dsize"> &para;</a></span></dt>
<dd><p>This variable contains the maximum size of buffers in which
tree-sitter can be activated.  Major modes should check this value
when deciding whether to enable tree-sitter features.
</p></dd></dl>

<a class="index-entry-id" id="index-creating-tree_002dsitter-parsers"></a>
<a class="index-entry-id" id="index-tree_002dsitter-parser_002c-creating"></a>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dcreate"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-create</strong> <var class="def-var-arguments">language &amp;optional buffer no-reuse</var><a class="copiable-link" href="#index-treesit_002dparser_002dcreate"> &para;</a></span></dt>
<dd><p>Create a parser for the specified <var class="var">buffer</var> and <var class="var">language</var>
(see <a class="pxref" href="Language-Grammar.html">Tree-sitter Language Grammar</a>).  If <var class="var">buffer</var> is omitted or
<code class="code">nil</code>, it stands for the current buffer.
</p>
<p>By default, this function reuses a parser if one already exists for
<var class="var">language</var> in <var class="var">buffer</var>, but if <var class="var">no-reuse</var> is
non-<code class="code">nil</code>, this function always creates a new parser.
</p>
<p>If that buffer is an indirect buffer, its base buffer is used instead.
That is, indirect buffers use their base buffer&rsquo;s parsers.  If the
base buffer is narrowed, an indirect buffer might not be able to
retrieve information of the portion of the buffer text that is
invisible in the base buffer.  Lisp programs should widen as necessary
should they want to use a parser in an indirect buffer.
</p></dd></dl>

<p>Given a parser, we can query information about it.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dbuffer"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-buffer</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002dbuffer"> &para;</a></span></dt>
<dd><p>This function returns the buffer associated with <var class="var">parser</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dlanguage"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-language</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002dlanguage"> &para;</a></span></dt>
<dd><p>This function returns the language used by <var class="var">parser</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dp"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-p</strong> <var class="def-var-arguments">object</var><a class="copiable-link" href="#index-treesit_002dparser_002dp"> &para;</a></span></dt>
<dd><p>This function checks if <var class="var">object</var> is a tree-sitter parser, and
returns non-<code class="code">nil</code> if it is, and <code class="code">nil</code> otherwise.
</p></dd></dl>

<p>There is no need to explicitly parse a buffer, because parsing is done
automatically and lazily.  A parser only parses when a Lisp program
queries for a node in its syntax tree.  Therefore, when a parser is
first created, it doesn&rsquo;t parse the buffer; it waits until the Lisp
program queries for a node for the first time.  Similarly, when some
change is made in the buffer, a parser doesn&rsquo;t re-parse immediately.
</p>
<a class="index-entry-id" id="index-treesit_002dbuffer_002dtoo_002dlarge"></a>
<p>When a parser does parse, it checks for the size of the buffer.
Tree-sitter can only handle buffers no larger than about 4GB.  If the
size exceeds that, Emacs signals the <code class="code">treesit-buffer-too-large</code>
error with signal data being the buffer size.
</p>
<p>Once a parser is created, Emacs automatically adds it to the
internal parser list.  Every time a change is made to the buffer,
Emacs updates parsers in this list so they can update their syntax
tree incrementally.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dlist"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-list</strong> <var class="def-var-arguments">&amp;optional buffer</var><a class="copiable-link" href="#index-treesit_002dparser_002dlist"> &para;</a></span></dt>
<dd><p>This function returns the parser list of <var class="var">buffer</var>.  If
<var class="var">buffer</var> is <code class="code">nil</code> or omitted, it defaults to the current
buffer.  If that buffer is an indirect buffer, its base buffer is used
instead.  That is, indirect buffers use their base buffer&rsquo;s parsers.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002ddelete"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-delete</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002ddelete"> &para;</a></span></dt>
<dd><p>This function deletes <var class="var">parser</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-tree_002dsitter-narrowing"></a>
<a class="anchor" id="tree_002dsitter-narrowing"></a><p>Normally, a parser &ldquo;sees&rdquo; the whole buffer, but when the buffer is
narrowed (see <a class="pxref" href="Narrowing.html">Narrowing</a>), the parser will only see the accessible
portion of the buffer.  As far as the parser can tell, the hidden
region was deleted.  When the buffer is later widened, the parser
thinks text is inserted at the beginning and at the end.  Although
parsers respect narrowing, modes should not use narrowing as a means
to handle a multi-language buffer; instead, set the ranges in which the
parser should operate.  See <a class="xref" href="Multiple-Languages.html">Parsing Text in Multiple Languages</a>.
</p>
<p>Because a parser parses lazily, when the user or a Lisp program
narrows the buffer, the parser is not affected immediately; as long as
the mode doesn&rsquo;t query for a node while the buffer is narrowed, the
parser is oblivious of the narrowing.
</p>
<a class="index-entry-id" id="index-tree_002dsitter-parse-string"></a>
<a class="index-entry-id" id="index-parse-string_002c-tree_002dsitter"></a>
<p>Besides creating a parser for a buffer, a Lisp program can also parse a
string.  Unlike a buffer, parsing a string is a one-off operation, and
there is no way to update the result.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparse_002dstring"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parse-string</strong> <var class="def-var-arguments">string language</var><a class="copiable-link" href="#index-treesit_002dparse_002dstring"> &para;</a></span></dt>
<dd><p>This function parses <var class="var">string</var> using <var class="var">language</var>, and returns
the root node of the generated syntax tree.
</p></dd></dl>

<h3 class="heading" id="Be-notified-by-changes-to-the-parse-tree"><span>Be notified by changes to the parse tree<a class="copiable-link" href="#Be-notified-by-changes-to-the-parse-tree"> &para;</a></span></h3>
<a class="index-entry-id" id="index-update-callback_002c-for-tree_002dsitter-parse_002dtree"></a>
<a class="index-entry-id" id="index-after_002dchange-notifier_002c-for-tree_002dsitter-parse_002dtree"></a>
<a class="index-entry-id" id="index-tree_002dsitter-parse_002dtree_002c-update-and-after_002dchange-callback"></a>
<a class="index-entry-id" id="index-notifiers_002c-tree_002dsitter"></a>

<p>A Lisp program might want to be notified of text affected by
incremental parsing.  For example, inserting a comment-closing token
converts text before that token into a comment.  Even
though the text is not directly edited, it is deemed to be &ldquo;changed&rdquo;
nevertheless.
</p>
<p>Emacs lets a Lisp program register callback functions (a.k.a.
<em class="dfn">notifiers</em>) for these kinds of changes.  A notifier function
takes two arguments: <var class="var">ranges</var> and <var class="var">parser</var>.  <var class="var">ranges</var> is a
list of cons cells of the form <code class="code">(<var class="var">start</var>&nbsp;.&nbsp;<var class="var">end</var>)</code><!-- /@w -->,
where <var class="var">start</var> and <var class="var">end</var> mark the start and the end positions
of a range.  <var class="var">parser</var> is the parser issuing the notification.
</p>
<p>Every time a parser reparses a buffer, it compares the old and new
parse-tree, computes the ranges in which nodes have changed, and
passes the ranges to notifier functions.  Note that the initial parse
is also considered a &ldquo;change&rdquo;, so notifier functions are called on
the initial parse, with range being the whole buffer.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dadd_002dnotifier"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-add-notifier</strong> <var class="def-var-arguments">parser function</var><a class="copiable-link" href="#index-treesit_002dparser_002dadd_002dnotifier"> &para;</a></span></dt>
<dd><p>This function adds <var class="var">function</var> to <var class="var">parser</var>&rsquo;s list of
after-change notifier functions.  <var class="var">function</var> must be a function
symbol, not a lambda function (see <a class="pxref" href="Anonymous-Functions.html">Anonymous Functions</a>).
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dremove_002dnotifier"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-remove-notifier</strong> <var class="def-var-arguments">parser function</var><a class="copiable-link" href="#index-treesit_002dparser_002dremove_002dnotifier"> &para;</a></span></dt>
<dd><p>This function removes <var class="var">function</var> from the list of <var class="var">parser</var>&rsquo;s
after-change notifier functions.  <var class="var">function</var> must be a function
symbol, rather than a lambda function.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-treesit_002dparser_002dnotifiers"><span class="category-def">Function: </span><span><strong class="def-name">treesit-parser-notifiers</strong> <var class="def-var-arguments">parser</var><a class="copiable-link" href="#index-treesit_002dparser_002dnotifiers"> &para;</a></span></dt>
<dd><p>This function returns the list of <var class="var">parser</var>&rsquo;s notifier functions.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Retrieving-Nodes.html">Retrieving Nodes</a>, Previous: <a href="Language-Grammar.html">Tree-sitter Language Grammar</a>, Up: <a href="Parsing-Program-Source.html">Parsing Program Source</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
