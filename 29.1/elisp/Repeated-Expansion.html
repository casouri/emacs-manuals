<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.1.

Copyright Â© 1990-1996, 1998-2023 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Repeated Expansion (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Repeated Expansion (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Repeated Expansion (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Problems-with-Macros.html" rel="up" title="Problems with Macros">
<link href="Eval-During-Expansion.html" rel="prev" title="Eval During Expansion">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Repeated-Expansion">
<div class="nav-panel">
<p>
Previous: <a href="Eval-During-Expansion.html" accesskey="p" rel="prev">Evaluating Macro Arguments in Expansion</a>, Up: <a href="Problems-with-Macros.html" accesskey="u" rel="up">Common Problems Using Macros</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="How-Many-Times-is-the-Macro-Expanded_003f"><span>14.5.5 How Many Times is the Macro Expanded?<a class="copiable-link" href="#How-Many-Times-is-the-Macro-Expanded_003f"> &para;</a></span></h4>

<p>Occasionally problems result from the fact that a macro call is
expanded each time it is evaluated in an interpreted function, but is
expanded only once (during compilation) for a compiled function.  If the
macro definition has side effects, they will work differently depending
on how many times the macro is expanded.
</p>
<p>Therefore, you should avoid side effects in computation of the
macro expansion, unless you really know what you are doing.
</p>
<p>One special kind of side effect can&rsquo;t be avoided: constructing Lisp
objects.  Almost all macro expansions include constructed lists; that is
the whole point of most macros.  This is usually safe; there is just one
case where you must be careful: when the object you construct is part of a
quoted constant in the macro expansion.
</p>
<p>If the macro is expanded just once, in compilation, then the object is
constructed just once, during compilation.  But in interpreted
execution, the macro is expanded each time the macro call runs, and this
means a new object is constructed each time.
</p>
<p>In most clean Lisp code, this difference won&rsquo;t matter.  It can matter
only if you perform side-effects on the objects constructed by the macro
definition.  Thus, to avoid trouble, <strong class="strong">avoid side effects on
objects constructed by macro definitions</strong>.  Here is an example of how
such side effects can get you into trouble:
</p>
<div class="example lisp">
<div class="group"><pre class="lisp-preformatted">(defmacro empty-object ()
  (list 'quote (cons nil nil)))
</pre></div><pre class="lisp-preformatted">

</pre><div class="group"><pre class="lisp-preformatted">(defun initialize (condition)
  (let ((object (empty-object)))
    (if condition
        (setcar object condition))
    object))
</pre></div></div>

<p>If <code class="code">initialize</code> is interpreted, a new list <code class="code">(nil)</code> is
constructed each time <code class="code">initialize</code> is called.  Thus, no side effect
survives between calls.  If <code class="code">initialize</code> is compiled, then the
macro <code class="code">empty-object</code> is expanded during compilation, producing a
single constant <code class="code">(nil)</code> that is reused and altered each time
<code class="code">initialize</code> is called.
</p>
<p>One way to avoid pathological cases like this is to think of
<code class="code">empty-object</code> as a funny kind of constant, not as a memory
allocation construct.  You wouldn&rsquo;t use <code class="code">setcar</code> on a constant such
as <code class="code">'(nil)</code>, so naturally you won&rsquo;t use it on <code class="code">(empty-object)</code>
either.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Eval-During-Expansion.html">Evaluating Macro Arguments in Expansion</a>, Up: <a href="Problems-with-Macros.html">Common Problems Using Macros</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
