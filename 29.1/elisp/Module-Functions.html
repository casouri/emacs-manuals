<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.1.

Copyright Â© 1990-1996, 1998-2023 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Module Functions (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Module Functions (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Module Functions (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Writing-Dynamic-Modules.html" rel="up" title="Writing Dynamic Modules">
<link href="Module-Values.html" rel="next" title="Module Values">
<link href="Module-Initialization.html" rel="prev" title="Module Initialization">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Module-Functions">
<div class="nav-panel">
<p>
Next: <a href="Module-Values.html" accesskey="n" rel="next">Conversion Between Lisp and Module Values</a>, Previous: <a href="Module-Initialization.html" accesskey="p" rel="prev">Module Initialization Code</a>, Up: <a href="Writing-Dynamic-Modules.html" accesskey="u" rel="up">Writing Dynamically-Loaded Modules</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Writing-Module-Functions"><span>E.8.2 Writing Module Functions<a class="copiable-link" href="#Writing-Module-Functions"> &para;</a></span></h4>
<a class="index-entry-id" id="index-writing-module-functions"></a>
<a class="index-entry-id" id="index-module-functions"></a>

<p>The main reason for writing an Emacs module is to make additional
functions available to Lisp programs that load the module.  This
subsection describes how to write such <em class="dfn">module functions</em>.
</p>
<p>A module function has the following general form and signature:
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-emacs_005ffunction"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">emacs_function</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, ptrdiff_t <var class="var">nargs</var>, emacs_value *<var class="var">args</var>, void *<var class="var">data</var>)</code><a class="copiable-link" href="#index-emacs_005ffunction"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-emacs_005ffunction-1"></a>
<p>The <var class="var">env</var> argument provides a pointer to the <abbr class="acronym">API</abbr>
environment, needed to access Emacs objects and functions.  The
<var class="var">nargs</var> argument is the required number of arguments, which can be
zero (see <code class="code">make_function</code> below for more flexible specification
of the argument number), and <var class="var">args</var> is a pointer to the array of
the function arguments.  The argument <var class="var">data</var> points to additional
data required by the function, which was arranged when
<code class="code">make_function</code> (see below) was called to create an Emacs
function from <code class="code">emacs_function</code>.
</p>
<p>Module functions use the type <code class="code">emacs_value</code> to communicate Lisp
objects between Emacs and the module (see <a class="pxref" href="Module-Values.html">Conversion Between Lisp and Module Values</a>).  The
<abbr class="acronym">API</abbr>, described below and in the following subsections,
provides facilities for conversion between basic C data types and the
corresponding <code class="code">emacs_value</code> objects.
</p>
<p>A module function always returns a value.  If the function returns
normally, the Lisp code which called it will see the Lisp object
corresponding to the <code class="code">emacs_value</code> value the function returned.
However, if the user typed <kbd class="kbd">C-g</kbd>, or if the module function or its
callees signaled an error or exited nonlocally (see <a class="pxref" href="Module-Nonlocal.html">Nonlocal Exits in Modules</a>), Emacs will ignore the returned value and quit or throw as
it does when Lisp code encounters the same situations.
</p>
<p>The header <samp class="file">emacs-module.h</samp> provides the type
<code class="code">emacs_function</code> as an alias type for a function pointer to a
module function.
</p></dd></dl>

<p>After writing your C code for a module function, you should make a
Lisp function object from it using the <code class="code">make_function</code> function,
whose pointer is provided in the environment (recall that the pointer
to the environment is returned by <code class="code">get_environment</code>).  This is
normally done in the module initialization function (see <a class="pxref" href="Module-Initialization.html#module-initialization-function">module initialization function</a>), after verifying the <abbr class="acronym">API</abbr>
compatibility.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_005ffunction"><span class="category-def">Function: </span><span><code class="def-type">emacs_value</code> <strong class="def-name">make_function</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, ptrdiff_t <var class="var">min_arity</var>, ptrdiff_t <var class="var">max_arity</var>, emacs_function <var class="var">func</var>, const char *<var class="var">docstring</var>, void *<var class="var">data</var>)</code><a class="copiable-link" href="#index-make_005ffunction"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-emacs_005fvariadic_005ffunction"></a>
<p>This returns an Emacs function created from the C function <var class="var">func</var>,
whose signature is as described for <code class="code">emacs_function</code> above.
The arguments
<var class="var">min_arity</var> and <var class="var">max_arity</var> specify the minimum and maximum
number of arguments that <var class="var">func</var> can accept.  The <var class="var">max_arity</var>
argument can have the special value <code class="code">emacs_variadic_function</code>,
which makes the function accept an unlimited number of arguments, like
the <code class="code">&amp;rest</code> keyword in Lisp (see <a class="pxref" href="Argument-List.html">Features of Argument Lists</a>).
</p>
<p>The argument <var class="var">data</var> is a way to arrange for arbitrary additional
data to be passed to <var class="var">func</var> when it is called.  Whatever pointer
is passed to <code class="code">make_function</code> will be passed unaltered to
<var class="var">func</var>.
</p>
<p>The argument <var class="var">docstring</var> specifies the documentation string for
the function.  It should be either an <abbr class="acronym">ASCII</abbr> string, or a
UTF-8 encoded non-<abbr class="acronym">ASCII</abbr> string, or a <code class="code">NULL</code> pointer; in
the latter case the function will have no documentation.  The
documentation string can end with a line that specifies the advertised
calling convention, see <a class="ref" href="Function-Documentation.html">Documentation Strings of Functions</a>.
</p>
<p>Since every module function must accept the pointer to the environment
as its first argument, the call to <code class="code">make_function</code> could be made
from any module function, but you will normally want to do that from
the module initialization function, so that all the module functions
are known to Emacs once the module is loaded.
</p></dd></dl>

<p>Finally, you should bind the Lisp function to a symbol, so that Lisp
code could call your function by name.  For that, use the module
<abbr class="acronym">API</abbr> function <code class="code">intern</code> (see <a class="pxref" href="Module-Misc.html#intern">intern</a>) whose pointer is
also provided in the environment that module functions can access.
</p>
<p>Combining the above steps, code that arranges for a C function
<code class="code">module_func</code> to be callable as <code class="code">module-func</code> from Lisp will
look like this, as part of the module initialization function:
</p>
<div class="example">
<pre class="example-preformatted"> emacs_env *env = runtime-&gt;get_environment (runtime);
 emacs_value func = env-&gt;make_function (env, min_arity, max_arity,
                                        module_func, docstring, data);
 emacs_value symbol = env-&gt;intern (env, &quot;module-func&quot;);
 emacs_value args[] = {symbol, func};
 env-&gt;funcall (env, env-&gt;intern (env, &quot;defalias&quot;), 2, args);
</pre></div>

<p>This makes the symbol <code class="code">module-func</code> known to Emacs by calling
<code class="code">env-&gt;intern</code>, then invokes <code class="code">defalias</code> from Emacs to bind
the function to that symbol.  Note that it is possible to use
<code class="code">fset</code> instead of <code class="code">defalias</code>; the differences are described
in <a class="ref" href="Defining-Functions.html">defalias</a>.
</p>
<p>Module functions including the <code class="code">emacs_module_init</code> function
(see <a class="pxref" href="Module-Initialization.html#module-initialization-function">module initialization function</a>) may only interact with Emacs
by calling environment functions from some live <code class="code">emacs_env</code>
pointer while being called directly or indirectly from Emacs.  In
other words, if a module function wants to call Lisp functions or
Emacs primitives, convert <code class="code">emacs_value</code> objects to and from C
datatypes (see <a class="pxref" href="Module-Values.html">Conversion Between Lisp and Module Values</a>), or interact with Emacs in any other
way, some call from Emacs to <code class="code">emacs_module_init</code> or to a module
function must be in the call stack.  Module functions may not interact
with Emacs while garbage collection is running; see <a class="pxref" href="Garbage-Collection.html">Garbage Collection</a>.  They may only interact with Emacs from Lisp interpreter
threads (including the main thread) created by Emacs; see <a class="pxref" href="Threads.html">Threads</a>.
The <kbd class="kbd">--module-assertions</kbd> command-line option can detect some
violations of the above requirements.  See <a data-manual="emacs" href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Initial-Options.html#Initial-Options">Initial Options</a> in <cite class="cite">The GNU Emacs Manual</cite>.
</p>
<p>Using the module <abbr class="acronym">API</abbr>, it is possible to define more complex
function and data types: inline functions, macros, etc.  However, the
resulting C code will be cumbersome and hard to read.  Therefore, we
recommend that you limit the module code which creates functions and
data structures to the absolute minimum, and leave the rest for a Lisp
package that will accompany your module, because doing these
additional tasks in Lisp is much easier, and will produce a much more
readable code.  For example, given a module function
<code class="code">module-func</code> defined as above, one way of making a macro
<code class="code">module-macro</code> based on it is with the following simple Lisp
wrapper:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(defmacro module-macro (&amp;rest args)
  &quot;Documentation string for the macro.&quot;
  (module-func args))
</pre></div>

<p>The Lisp package which goes with your module could then load the
module using the <code class="code">load</code> primitive (see <a class="pxref" href="Dynamic-Modules.html">Emacs Dynamic Modules</a>) when
the package is loaded into Emacs.
</p>
<p>By default, module functions created by <code class="code">make_function</code> are not
interactive.  To make them interactive, you can use the following
function.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-make_005finteractive"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">make_interactive</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">function</var>, emacs_value <var class="var">spec</var>)</code><a class="copiable-link" href="#index-make_005finteractive"> &para;</a></span></dt>
<dd><p>This function, which is available since Emacs 28, makes the function
<var class="var">function</var> interactive using the interactive specification
<var class="var">spec</var>.  Emacs interprets <var class="var">spec</var> like the argument to the
<code class="code">interactive</code> form.  <a class="ref" href="Using-Interactive.html">Using <code class="code">interactive</code></a>, and
see <a class="pxref" href="Interactive-Codes.html">Code Characters for <code class="code">interactive</code></a>.  <var class="var">function</var> must be an Emacs module
function returned by <code class="code">make_function</code>.
</p></dd></dl>

<p>Note that there is no native module support for retrieving the
interactive specification of a module function.  Use the function
<code class="code">interactive-form</code> for that.  <a class="ref" href="Using-Interactive.html">Using <code class="code">interactive</code></a>.  It is not
possible to make a module function non-interactive once you have made
it interactive using <code class="code">make_interactive</code>.
</p>
<a class="anchor" id="Module-Function-Finalizers"></a><p>If you want to run some code when a module function object (i.e., an
object returned by <code class="code">make_function</code>) is garbage-collected, you can
install a <em class="dfn">function finalizer</em>.  Function finalizers are available
since Emacs 28.  For example, if you have passed some heap-allocated
structure to the <var class="var">data</var> argument of <code class="code">make_function</code>, you can
use the finalizer to deallocate the structure.  See <a data-manual="libc" href="https://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html#Basic-Allocation">(libc)Basic
Allocation</a>, and see <a data-manual="libc" href="https://www.gnu.org/software/libc/manual/html_node/Freeing-after-Malloc.html#Freeing-after-Malloc">(libc)Freeing after Malloc</a>.  The
finalizer function has the following signature:
</p>
<div class="example">
<pre class="example-preformatted">void finalizer (void *<var class="var">data</var>)
</pre></div>

<p>Here, <var class="var">data</var> receives the value passed to <var class="var">data</var> when calling
<code class="code">make_function</code>.  Note that the finalizer can&rsquo;t interact with
Emacs in any way.
</p>
<p>Directly after calling <code class="code">make_function</code>, the newly-created
function doesn&rsquo;t have a finalizer.  Use <code class="code">set_function_finalizer</code>
to add one, if desired.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-emacs_005ffinalizer"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">emacs_finalizer</strong> <code class="def-code-arguments">(void *<var class="var">ptr</var>)</code><a class="copiable-link" href="#index-emacs_005ffinalizer"> &para;</a></span></dt>
<dd><p>The header <samp class="file">emacs-module.h</samp> provides the type
<code class="code">emacs_finalizer</code> as a type alias for an Emacs finalizer
function.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-get_005ffunction_005ffinalizer"><span class="category-def">Function: </span><span><code class="def-type">emacs_finalizer</code> <strong class="def-name">get_function_finalizer</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>)</code><a class="copiable-link" href="#index-get_005ffunction_005ffinalizer"> &para;</a></span></dt>
<dd><p>This function, which is available since Emacs 28, returns the function
finalizer associated with the module function represented by
<var class="var">arg</var>.  <var class="var">arg</var> must refer to a module function, that is, an
object returned by <code class="code">make_function</code>.  If no finalizer is
associated with the function, <code class="code">NULL</code> is returned.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-set_005ffunction_005ffinalizer"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">set_function_finalizer</strong> <code class="def-code-arguments">(emacs_env *<var class="var">env</var>, emacs_value <var class="var">arg</var>, emacs_finalizer <var class="var">fin</var>)</code><a class="copiable-link" href="#index-set_005ffunction_005ffinalizer"> &para;</a></span></dt>
<dd><p>This function, which is available since Emacs 28, sets the function
finalizer associated with the module function represented by <var class="var">arg</var>
to <var class="var">fin</var>.  <var class="var">arg</var> must refer to a module function, that is, an
object returned by <code class="code">make_function</code>.  <var class="var">fin</var> can either be
<code class="code">NULL</code> to clear <var class="var">arg</var>&rsquo;s function finalizer, or a pointer to a
function to be called when the object represented by <var class="var">arg</var> is
garbage-collected.  At most one function finalizer can be set per
function; if <var class="var">arg</var> already has a finalizer, it is replaced by
<var class="var">fin</var>.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Module-Values.html">Conversion Between Lisp and Module Values</a>, Previous: <a href="Module-Initialization.html">Module Initialization Code</a>, Up: <a href="Writing-Dynamic-Modules.html">Writing Dynamically-Loaded Modules</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
