<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.1.

Copyright Â© 1990-1996, 1998-2023 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Bindat Types (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Bindat Types (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Bindat Types (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Byte-Packing.html" rel="up" title="Byte Packing">
<link href="Bindat-Functions.html" rel="next" title="Bindat Functions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Bindat-Types">
<div class="nav-panel">
<p>
Next: <a href="Bindat-Functions.html" accesskey="n" rel="next">Functions to Unpack and Pack Bytes</a>, Up: <a href="Byte-Packing.html" accesskey="u" rel="up">Packing and Unpacking Byte Arrays</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Describing-Data-Layout"><span>40.20.1 Describing Data Layout<a class="copiable-link" href="#Describing-Data-Layout"> &para;</a></span></h4>
<a class="index-entry-id" id="index-bindat-types"></a>

<a class="index-entry-id" id="index-data-layout-specification"></a>
<a class="index-entry-id" id="index-bindat-type-expression"></a>
<a class="index-entry-id" id="index-base-type_002c-in-bindat-specification"></a>
<a class="index-entry-id" id="index-composite-type_002c-in-bindat-specification"></a>
<p>To control unpacking and packing, you write a <em class="dfn">data layout
specification</em>, also called a <em class="dfn">Bindat type expression</em>.  This can
be a <em class="dfn">base type</em> or a <em class="dfn">composite type</em> made of several fields,
where the specification controls the length of each field to be
processed, and how to pack or unpack it.  We normally keep bindat type
values in variables whose names end in <code class="code">-bindat-spec</code>; that kind
of name is automatically recognized as risky (see <a class="pxref" href="File-Local-Variables.html">File Local Variables</a>).
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-bindat_002dtype"><span class="category-def">Macro: </span><span><strong class="def-name">bindat-type</strong> <var class="def-var-arguments">&amp;rest type</var><a class="copiable-link" href="#index-bindat_002dtype"> &para;</a></span></dt>
<dd><p>Creates a Bindat type <em class="emph">value</em> object according to the Bindat type
<em class="emph">expression</em> <var class="var">type</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-endianness_002c-in-bindat-specification"></a>
<a class="index-entry-id" id="index-big-endian_002c-in-bindat-specification"></a>
<a class="index-entry-id" id="index-little-endian_002c-in-bindat-specification"></a>
<a class="index-entry-id" id="index-network-byte-ordering_002c-in-Bindat-specification"></a>
<p>A field&rsquo;s <em class="dfn">type</em> describes the size (in bytes) of the object
that the field represents and, in the case of multibyte fields, how
the bytes are ordered within the field.  The two possible orderings
are <em class="dfn">big endian</em> (also known as &ldquo;network byte ordering&rdquo;) and
<em class="dfn">little endian</em>.  For instance, the number <code class="code">#x23cd</code> (decimal
9165) in big endian would be the two bytes <code class="code">#x23</code> <code class="code">#xcd</code>;
and in little endian, <code class="code">#xcd</code> <code class="code">#x23</code>.  Here are the possible
type values:
</p>
<dl class="table">
<dt><code class="code">u8</code></dt>
<dt><code class="code">byte</code></dt>
<dd><p>Unsigned byte, with length 1.
</p>
</dd>
<dt><code class="code">uint <var class="var">bitlen</var> &amp;optional <var class="var">le</var></code></dt>
<dd><p>Unsigned integer in network byte order (big-endian), with <var class="var">bitlen</var> bits.
<var class="var">bitlen</var> has to be a multiple of 8.
If <var class="var">le</var> is non-<code class="code">nil</code>, then use little-endian byte order.
</p>
</dd>
<dt><code class="code">sint <var class="var">bitlen</var> <var class="var">le</var></code></dt>
<dd><p>Signed integer in network byte order (big-endian), with <var class="var">bitlen</var> bits.
<var class="var">bitlen</var> has to be a multiple of 8.
If <var class="var">le</var> is non-<code class="code">nil</code>, then use little-endian byte order.
</p>
</dd>
<dt><code class="code">str <var class="var">len</var></code></dt>
<dd><p>Unibyte string (see <a class="pxref" href="Text-Representations.html">Text Representations</a>) of length <var class="var">len</var> bytes.
When packing, the first <var class="var">len</var> bytes of the input string are copied
to the packed output.  If the input string is shorter than <var class="var">len</var>,
the remaining bytes will be null (zero) unless a pre-allocated string
was provided to <code class="code">bindat-pack</code>, in which case the remaining bytes
are left unmodified.  If the input string is multibyte with only ASCII
and <code class="code">eight-bit</code> characters, it is converted to unibyte before it
is packed; other multibyte strings signal an error.  When unpacking,
any null bytes in the packed input string will appear in the unpacked
output.
</p>
</dd>
<dt><code class="code">strz &amp;optional <var class="var">len</var></code></dt>
<dd><p>If <var class="var">len</var> is not provided, this is a variable-length
null-terminated unibyte string (see <a class="pxref" href="Text-Representations.html">Text Representations</a>).  When
packing into <code class="code">strz</code>, the entire input string is copied to the
packed output followed by a null (zero) byte.  (If pre-allocated
string is provided for packing into <code class="code">strz</code>, that pre-allocated
string should have enough space for the additional null byte appended
to the output string contents, see <a class="pxref" href="Bindat-Functions.html">Functions to Unpack and Pack Bytes</a>).  The length
of the packed output is the length of the input string plus one (for
the null terminator).  The input string must not contain any null
bytes.  If the input string is multibyte with only ASCII and
<code class="code">eight-bit</code> characters, it is converted to unibyte before it is
packed; other multibyte strings signal an error.  When unpacking a
<code class="code">strz</code>, the resulting output string will contain all bytes up to
(but excluding) the null byte that terminated the input string.
</p>
<p>If <var class="var">len</var> is provided, <code class="code">strz</code> behaves the same as <code class="code">str</code>,
but with a couple of differences:
</p>
<ul class="itemize mark-bullet">
<li>When packing, a null terminator is written after the packed input
string if the number of characters in the input string is less than
<var class="var">len</var>.

</li><li>When unpacking, the first null byte encountered in the packed string
is interpreted as the terminating byte, and it and all subsequent
bytes are excluded from the result of the unpacking.
</li></ul>

<blockquote class="quotation">
<p><b class="b">Caution:</b> The packed output will not be null-terminated unless the input string
is shorter than <var class="var">len</var> bytes or it contains a null byte within the
first <var class="var">len</var> bytes.
</p></blockquote>

</dd>
<dt><code class="code">vec <var class="var">len</var> [<var class="var">type</var>]</code></dt>
<dd><p>Vector of <var class="var">len</var> elements.  The type of the elements is given by
<var class="var">type</var>, defaulting to bytes.  The <var class="var">type</var> can be any Bindat
type expression.
</p>
</dd>
<dt><code class="code">repeat <var class="var">len</var> [<var class="var">type</var>]</code></dt>
<dd><p>Like <code class="code">vec</code>, but it unpacks to and packs from lists, whereas
<code class="code">vec</code> unpacks to vectors.
</p>
</dd>
<dt><code class="code">bits <var class="var">len</var></code></dt>
<dd><p>List of bits that are set to 1 in <var class="var">len</var> bytes.  The bytes are
taken in big-endian order, and the bits are numbered starting with
<code class="code">8 * <var class="var">len</var> &minus; 1</code> and ending with zero.  For example:
<code class="code">bits 2</code> unpacks <code class="code">#x28</code> <code class="code">#x1c</code> to <code class="code">(2&nbsp;3&nbsp;4&nbsp;11&nbsp;13)</code><!-- /@w -->
and <code class="code">#x1c</code> <code class="code">#x28</code> to <code class="code">(3&nbsp;5&nbsp;10&nbsp;11&nbsp;12)</code><!-- /@w -->.
</p>
</dd>
<dt><code class="code">fill <var class="var">len</var></code></dt>
<dd><p><var class="var">len</var> bytes used as a mere filler.  In packing, these bytes are
left unchanged, which normally means they remain zero.
When unpacking, this just returns <code class="code">nil</code>.
</p>
</dd>
<dt><code class="code">align <var class="var">len</var></code></dt>
<dd><p>Same as <code class="code">fill</code> except the number of bytes is that needed to skip
to the next multiple of <var class="var">len</var> bytes.
</p>
</dd>
<dt><code class="code">type <var class="var">exp</var></code></dt>
<dd><p>This lets you refer to a type indirectly: <var class="var">exp</var> is a Lisp
expression which should return a Bindat type <em class="emph">value</em>.
</p>
</dd>
<dt><code class="code">unit <var class="var">exp</var></code></dt>
<dd><p>This is a trivial type which uses up 0 bits of space.  <var class="var">exp</var>
describes the value returned when we try to &ldquo;unpack&rdquo; such a field.
</p>
</dd>
<dt><code class="code">struct <var class="var">fields</var>...</code></dt>
<dd><p>Composite type made of several fields.  Every field is of the form
<code class="code">(<var class="var">name</var> <var class="var">type</var>)</code> where <var class="var">type</var> can be any Bindat
type expression.  <var class="var">name</var> can be <code class="code">_</code> when the field&rsquo;s value
does not deserve to be named, as is often the case for <code class="code">align</code>
and <code class="code">fill</code> fields.
When the context makes it clear that this is a Bindat type expression,
the symbol <code class="code">struct</code> can be omitted.
</p></dd>
</dl>

<p>In the types above, <var class="var">len</var> and <var class="var">bitlen</var> are given as an integer
specifying the number of bytes (or bits) in the field.  When the
length of a field is not fixed, it typically depends on the value of
preceding fields.  For this reason, the length <var class="var">len</var> does not have
to be a constant but can be any Lisp expression and it can refer to
the value of previous fields via their name.
</p>
<p>For example, the specification of a data layout where a leading byte gives
the size of a subsequent vector of 16 bit integers could be:
</p><div class="example">
<pre class="example-preformatted">(bindat-type
  (len      u8)
  (payload  vec (1+ len) uint 16))
</pre></div>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Bindat-Functions.html">Functions to Unpack and Pack Bytes</a>, Up: <a href="Byte-Packing.html">Packing and Unpacking Byte Arrays</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
