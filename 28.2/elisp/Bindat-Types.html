<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 28.2.

Copyright Â© 1990-1996, 1998-2022 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Bindat Types (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Bindat Types (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Bindat Types (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Byte-Packing.html" rel="up" title="Byte Packing">
<link href="Bindat-Functions.html" rel="next" title="Bindat Functions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Bindat-Types">
<div class="nav-panel">
<p>
Next: <a href="Bindat-Functions.html" accesskey="n" rel="next">Functions to Unpack and Pack Bytes</a>, Up: <a href="Byte-Packing.html" accesskey="u" rel="up">Packing and Unpacking Byte Arrays</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Describing-Data-Layout"><span>39.20.1 Describing Data Layout<a class="copiable-link" href="#Describing-Data-Layout"> &para;</a></span></h4>
<a class="index-entry-id" id="index-bindat-types"></a>

<a class="index-entry-id" id="index-data-layout-specification"></a>
<a class="index-entry-id" id="index-bindat-type-expression"></a>
<a class="index-entry-id" id="index-base-type_002c-in-bindat-specification"></a>
<a class="index-entry-id" id="index-composite-type_002c-in-bindat-specification"></a>
<p>To control unpacking and packing, you write a <em class="dfn">data layout
specification</em>, also called a <em class="dfn">Bindat type expression</em>.  This can
be a <em class="dfn">base type</em> or a <em class="dfn">composite type</em> made of several fields,
where the specification controls the length of each field to be
processed, and how to pack or unpack it.  We normally keep bindat type
values in variables whose names end in <code class="code">-bindat-spec</code>; that kind
of name is automatically recognized as risky (see <a class="pxref" href="File-Local-Variables.html">File Local Variables</a>).
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-bindat_002dtype"><span class="category-def">Macro: </span><span><strong class="def-name">bindat-type</strong> <var class="def-var-arguments">&amp;rest type</var><a class="copiable-link" href="#index-bindat_002dtype"> &para;</a></span></dt>
<dd><p>Creates a Bindat type <em class="emph">value</em> object according to the Bindat type
<em class="emph">expression</em> <var class="var">type</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-endianness_002c-in-bindat-specification"></a>
<a class="index-entry-id" id="index-big-endian_002c-in-bindat-specification"></a>
<a class="index-entry-id" id="index-little-endian_002c-in-bindat-specification"></a>
<a class="index-entry-id" id="index-network-byte-ordering_002c-in-Bindat-specification"></a>
<p>A field&rsquo;s <em class="dfn">type</em> describes the size (in bytes) of the object
that the field represents and, in the case of multibyte fields, how
the bytes are ordered within the field.  The two possible orderings
are <em class="dfn">big endian</em> (also known as &ldquo;network byte ordering&rdquo;) and
<em class="dfn">little endian</em>.  For instance, the number <code class="code">#x23cd</code> (decimal
9165) in big endian would be the two bytes <code class="code">#x23</code> <code class="code">#xcd</code>;
and in little endian, <code class="code">#xcd</code> <code class="code">#x23</code>.  Here are the possible
type values:
</p>
<dl class="table">
<dt><code class="code">u8</code></dt>
<dt><code class="code">byte</code></dt>
<dd><p>Unsigned byte, with length 1.
</p>
</dd>
<dt><code class="code">uint <var class="var">bitlen</var></code></dt>
<dd><p>Unsigned integer in network byte order, with <var class="var">bitlen</var> bits.
<var class="var">bitlen</var> has to be a multiple of 8.
</p>
</dd>
<dt><code class="code">uintr <var class="var">bitlen</var></code></dt>
<dd><p>Unsigned integer in little endian order, with <var class="var">bitlen</var> bits.
<var class="var">bitlen</var> has to be a multiple of 8.
</p>
</dd>
<dt><code class="code">str <var class="var">len</var></code></dt>
<dd><p>String of bytes of length <var class="var">len</var>.
</p>
</dd>
<dt><code class="code">strz &amp;optional <var class="var">len</var></code></dt>
<dd><p>Zero-terminated string of bytes, can be of arbitrary length or in a fixed-size
field with length <var class="var">len</var>.
</p>
</dd>
<dt><code class="code">vec <var class="var">len</var> [<var class="var">type</var>]</code></dt>
<dd><p>Vector of <var class="var">len</var> elements.  The type of the elements is given by
<var class="var">type</var>, defaulting to bytes.  The <var class="var">type</var> can be any Bindat
type expression.
</p>
</dd>
<dt><code class="code">repeat <var class="var">len</var> [<var class="var">type</var>]</code></dt>
<dd><p>Like <code class="code">vec</code>, but it unpacks to and packs from lists, whereas
<code class="code">vec</code> unpacks to vectors.
</p>
</dd>
<dt><code class="code">bits <var class="var">len</var></code></dt>
<dd><p>List of bits that are set to 1 in <var class="var">len</var> bytes.  The bytes are
taken in big-endian order, and the bits are numbered starting with
<code class="code">8 * <var class="var">len</var> &minus; 1</code> and ending with zero.  For example:
<code class="code">bits 2</code> unpacks <code class="code">#x28</code> <code class="code">#x1c</code> to <code class="code">(2&nbsp;3&nbsp;4&nbsp;11&nbsp;13)</code><!-- /@w -->
and <code class="code">#x1c</code> <code class="code">#x28</code> to <code class="code">(3&nbsp;5&nbsp;10&nbsp;11&nbsp;12)</code><!-- /@w -->.
</p>
</dd>
<dt><code class="code">fill <var class="var">len</var></code></dt>
<dd><p><var class="var">len</var> bytes used as a mere filler.  In packing, these bytes are
are left unchanged, which normally means they remain zero.
When unpacking, this just returns nil.
</p>
</dd>
<dt><code class="code">align <var class="var">len</var></code></dt>
<dd><p>Same as <code class="code">fill</code> except the number of bytes is that needed to skip
to the next multiple of <var class="var">len</var> bytes.
</p>
</dd>
<dt><code class="code">type <var class="var">exp</var></code></dt>
<dd><p>This lets you refer to a type indirectly: <var class="var">exp</var> is a Lisp
expression which should return a Bindat type <em class="emph">value</em>.
</p>
</dd>
<dt><code class="code">unit <var class="var">exp</var></code></dt>
<dd><p>This is a trivial type which uses up 0 bits of space.  <var class="var">exp</var>
describes the value returned when we try to &ldquo;unpack&rdquo; such a field.
</p>
</dd>
<dt><code class="code">struct <var class="var">fields</var>...</code></dt>
<dd><p>Composite type made of several fields.  Every field is of the form
<code class="code">(<var class="var">name</var> <var class="var">type</var>)</code> where <var class="var">type</var> can be any Bindat
type expression.  <var class="var">name</var> can be <code class="code">_</code> when the field&rsquo;s value
does not deserve to be named, as is often the case for <code class="code">align</code>
and <code class="code">fill</code> fields.
When the context makes it clear that this is a Bindat type expression,
the symbol <code class="code">struct</code> can be omitted.
</p></dd>
</dl>

<p>In the types above, <var class="var">len</var> and <var class="var">bitlen</var> are given as an integer
specifying the number of bytes (or bits) in the field.  When the
length of a field is not fixed, it typically depends on the value of
preceding fields.  For this reason, the length <var class="var">len</var> does not have
to be a constant but can be any Lisp expression and it can refer to
the value of previous fields via their name.
</p>
<p>For example, the specification of a data layout where a leading byte gives
the size of a subsequent vector of 16 bit integers could be:
</p><div class="example">
<pre class="example-preformatted">(bindat-type
  (len      u8)
  (payload  vec (1+ len) uint 16))
</pre></div>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Bindat-Functions.html">Functions to Unpack and Pack Bytes</a>, Up: <a href="Byte-Packing.html">Packing and Unpacking Byte Arrays</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
