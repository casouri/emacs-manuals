<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.4.

Copyright Â© 1990-1996, 1998-2024 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Property Search (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Property Search (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Property Search (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Text-Properties.html" rel="up" title="Text Properties">
<link href="Special-Properties.html" rel="next" title="Special Properties">
<link href="Changing-Properties.html" rel="prev" title="Changing Properties">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
pre.display-preformatted {font-family: inherit}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Property-Search">
<div class="nav-panel">
<p>
Next: <a href="Special-Properties.html" accesskey="n" rel="next">Properties with Special Meanings</a>, Previous: <a href="Changing-Properties.html" accesskey="p" rel="prev">Changing Text Properties</a>, Up: <a href="Text-Properties.html" accesskey="u" rel="up">Text Properties</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Text-Property-Search-Functions"><span>33.19.3 Text Property Search Functions<a class="copiable-link" href="#Text-Property-Search-Functions"> &para;</a></span></h4>
<a class="index-entry-id" id="index-searching-text-properties"></a>
<a class="index-entry-id" id="index-text-properties_002c-searching"></a>

<p>In typical use of text properties, most of the time several or many
consecutive characters have the same value for a property.  Rather than
writing your programs to examine characters one by one, it is much
faster to process chunks of text that have the same property value.
</p>
<p>Here are functions you can use to do this.  They use <code class="code">eq</code> for
comparing property values.  In all cases, <var class="var">object</var> defaults to the
current buffer.
</p>
<p>For good performance, it&rsquo;s very important to use the <var class="var">limit</var>
argument to these functions, especially the ones that search for a
single property&mdash;otherwise, they may spend a long time scanning to the
end of the buffer, if the property you are interested in does not change.
</p>
<p>These functions do not move point; instead, they return a position (or
<code class="code">nil</code>).  Remember that a position is always between two characters;
the position returned by these functions is between two characters with
different properties.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-next_002dproperty_002dchange"><span class="category-def">Function: </span><span><strong class="def-name">next-property-change</strong> <var class="def-var-arguments">pos &amp;optional object limit</var><a class="copiable-link" href="#index-next_002dproperty_002dchange"> &para;</a></span></dt>
<dd><p>The function scans the text forward from position <var class="var">pos</var> in the
string or buffer <var class="var">object</var> until it finds a change in some text
property, then returns the position of the change.  In other words, it
returns the position of the first character beyond <var class="var">pos</var> whose
properties are not identical to those of the character just after
<var class="var">pos</var>.
</p>
<p>If <var class="var">limit</var> is non-<code class="code">nil</code>, then the scan ends at position
<var class="var">limit</var>.  If there is no property change before that point, this
function returns <var class="var">limit</var>.
</p>
<p>The value is <code class="code">nil</code> if the properties remain unchanged all the way
to the end of <var class="var">object</var> and <var class="var">limit</var> is <code class="code">nil</code>.  If the value
is non-<code class="code">nil</code>, it is a position greater than or equal to <var class="var">pos</var>.
The value equals <var class="var">pos</var> only when <var class="var">limit</var> equals <var class="var">pos</var>.
</p>
<p>Here is an example of how to scan the buffer by chunks of text within
which all properties are constant:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(while (not (eobp))
  (let ((plist (text-properties-at (point)))
        (next-change
         (or (next-property-change (point) (current-buffer))
             (point-max))))
    <span class="r">Process text from point to <var class="var">next-change</var>...</span>
    (goto-char next-change)))
</pre></div>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-previous_002dproperty_002dchange"><span class="category-def">Function: </span><span><strong class="def-name">previous-property-change</strong> <var class="def-var-arguments">pos &amp;optional object limit</var><a class="copiable-link" href="#index-previous_002dproperty_002dchange"> &para;</a></span></dt>
<dd><p>This is like <code class="code">next-property-change</code>, but scans back from <var class="var">pos</var>
instead of forward.  If the value is non-<code class="code">nil</code>, it is a position
less than or equal to <var class="var">pos</var>; it equals <var class="var">pos</var> only if <var class="var">limit</var>
equals <var class="var">pos</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-next_002dsingle_002dproperty_002dchange"><span class="category-def">Function: </span><span><strong class="def-name">next-single-property-change</strong> <var class="def-var-arguments">pos prop &amp;optional object limit</var><a class="copiable-link" href="#index-next_002dsingle_002dproperty_002dchange"> &para;</a></span></dt>
<dd><p>The function scans text for a change in the <var class="var">prop</var> property, then
returns the position of the change.  The scan goes forward from
position <var class="var">pos</var> in the string or buffer <var class="var">object</var>.  In other
words, this function returns the position of the first character
beyond <var class="var">pos</var> whose <var class="var">prop</var> property differs from that of the
character just after <var class="var">pos</var>.
</p>
<p>If <var class="var">limit</var> is non-<code class="code">nil</code>, then the scan ends at position
<var class="var">limit</var>.  If there is no property change before that point,
<code class="code">next-single-property-change</code> returns <var class="var">limit</var>.
</p>
<p>The value is <code class="code">nil</code> if the property remains unchanged all the way to
the end of <var class="var">object</var> and <var class="var">limit</var> is <code class="code">nil</code>.  If the value is
non-<code class="code">nil</code>, it is a position greater than or equal to <var class="var">pos</var>; it
equals <var class="var">pos</var> only if <var class="var">limit</var> equals <var class="var">pos</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-previous_002dsingle_002dproperty_002dchange"><span class="category-def">Function: </span><span><strong class="def-name">previous-single-property-change</strong> <var class="def-var-arguments">pos prop &amp;optional object limit</var><a class="copiable-link" href="#index-previous_002dsingle_002dproperty_002dchange"> &para;</a></span></dt>
<dd><p>This is like <code class="code">next-single-property-change</code>, but scans back from
<var class="var">pos</var> instead of forward.  If the value is non-<code class="code">nil</code>, it is a
position less than or equal to <var class="var">pos</var>; it equals <var class="var">pos</var> only if
<var class="var">limit</var> equals <var class="var">pos</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-next_002dchar_002dproperty_002dchange"><span class="category-def">Function: </span><span><strong class="def-name">next-char-property-change</strong> <var class="def-var-arguments">pos &amp;optional limit</var><a class="copiable-link" href="#index-next_002dchar_002dproperty_002dchange"> &para;</a></span></dt>
<dd><p>This is like <code class="code">next-property-change</code> except that it considers
overlay properties as well as text properties, and if no change is
found before the end of the buffer, it returns the maximum buffer
position rather than <code class="code">nil</code> (in this sense, it resembles the
corresponding overlay function <code class="code">next-overlay-change</code>, rather than
<code class="code">next-property-change</code>).  There is no <var class="var">object</var> operand
because this function operates only on the current buffer.  It returns
the next address at which either kind of property changes.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-previous_002dchar_002dproperty_002dchange"><span class="category-def">Function: </span><span><strong class="def-name">previous-char-property-change</strong> <var class="def-var-arguments">pos &amp;optional limit</var><a class="copiable-link" href="#index-previous_002dchar_002dproperty_002dchange"> &para;</a></span></dt>
<dd><p>This is like <code class="code">next-char-property-change</code>, but scans back from
<var class="var">pos</var> instead of forward, and returns the minimum buffer
position if no change is found.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-next_002dsingle_002dchar_002dproperty_002dchange"><span class="category-def">Function: </span><span><strong class="def-name">next-single-char-property-change</strong> <var class="def-var-arguments">pos prop &amp;optional object limit</var><a class="copiable-link" href="#index-next_002dsingle_002dchar_002dproperty_002dchange"> &para;</a></span></dt>
<dd><p>This is like <code class="code">next-single-property-change</code> except that it
considers overlay properties as well as text properties, and if no
change is found before the end of the <var class="var">object</var>, it returns the
maximum valid position in <var class="var">object</var> rather than <code class="code">nil</code>.  Unlike
<code class="code">next-char-property-change</code>, this function <em class="emph">does</em> have an
<var class="var">object</var> operand; if <var class="var">object</var> is not a buffer, only
text-properties are considered.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-previous_002dsingle_002dchar_002dproperty_002dchange"><span class="category-def">Function: </span><span><strong class="def-name">previous-single-char-property-change</strong> <var class="def-var-arguments">pos prop &amp;optional object limit</var><a class="copiable-link" href="#index-previous_002dsingle_002dchar_002dproperty_002dchange"> &para;</a></span></dt>
<dd><p>This is like <code class="code">next-single-char-property-change</code>, but scans back
from <var class="var">pos</var> instead of forward, and returns the minimum valid
position in <var class="var">object</var> if no change is found.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-text_002dproperty_002dany"><span class="category-def">Function: </span><span><strong class="def-name">text-property-any</strong> <var class="def-var-arguments">start end prop value &amp;optional object</var><a class="copiable-link" href="#index-text_002dproperty_002dany"> &para;</a></span></dt>
<dd><p>This function returns non-<code class="code">nil</code> if at least one character between
<var class="var">start</var> and <var class="var">end</var> has a property <var class="var">prop</var> whose value is
<var class="var">value</var>.  More precisely, it returns the position of the first such
character.  Otherwise, it returns <code class="code">nil</code>.
</p>
<p>The optional fifth argument, <var class="var">object</var>, specifies the string or
buffer to scan.  Positions are relative to <var class="var">object</var>.  The default
for <var class="var">object</var> is the current buffer.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-text_002dproperty_002dnot_002dall"><span class="category-def">Function: </span><span><strong class="def-name">text-property-not-all</strong> <var class="def-var-arguments">start end prop value &amp;optional object</var><a class="copiable-link" href="#index-text_002dproperty_002dnot_002dall"> &para;</a></span></dt>
<dd><p>This function returns non-<code class="code">nil</code> if at least one character between
<var class="var">start</var> and <var class="var">end</var> does not have a property <var class="var">prop</var> with value
<var class="var">value</var>.  More precisely, it returns the position of the first such
character.  Otherwise, it returns <code class="code">nil</code>.
</p>
<p>The optional fifth argument, <var class="var">object</var>, specifies the string or
buffer to scan.  Positions are relative to <var class="var">object</var>.  The default
for <var class="var">object</var> is the current buffer.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-text_002dproperty_002dsearch_002dforward"><span class="category-def">Function: </span><span><strong class="def-name">text-property-search-forward</strong> <var class="def-var-arguments">prop &amp;optional value predicate not-current</var><a class="copiable-link" href="#index-text_002dproperty_002dsearch_002dforward"> &para;</a></span></dt>
<dd><p>Search for the next region of text whose property <var class="var">prop</var> is a
match for <var class="var">value</var> (which defaults to <code class="code">nil</code>), according to
<var class="var">predicate</var>.
</p>
<p>This function is modeled after <code class="code">search-forward</code> (see <a class="pxref" href="String-Search.html">Searching for Strings</a>) and friends, in that it moves point, but it also returns a
structure that describes the match instead of returning it in
<code class="code">match-beginning</code> and friends.
</p>
<p>If the text property whose value is a match can&rsquo;t be found, the
function returns <code class="code">nil</code>.  If it&rsquo;s found, point is placed at the
end of the region that has this matching text property, and the
function returns a <code class="code">prop-match</code> structure with information about
the match.
</p>
<p><var class="var">predicate</var> can either be <code class="code">t</code> (which is a synonym for
<code class="code">equal</code>), <code class="code">nil</code> (which means &ldquo;not equal&rdquo;), or a predicate
that will be called with two arguments: <var class="var">value</var> and the value of
the text property <var class="var">prop</var> at the buffer position that is a
candidate for a match.  The function should return non-<code class="code">nil</code> if
there&rsquo;s a match, <code class="code">nil</code> otherwise.
</p>
<p>If <var class="var">not-current</var> is non-<code class="code">nil</code>, then if point is already in a
region where we have a property match, skip past that region and find
the next region instead.
</p>
<p>The <code class="code">prop-match</code> structure has the following accessor functions:
<code class="code">prop-match-beginning</code> (the start of the match),
<code class="code">prop-match-end</code> (the end of the match), and
<code class="code">prop-match-value</code> (the value of <var class="var">property</var> at the start of
the match).
</p>
<p>In the examples below, we use a buffer whose contents is:
</p>
<div class="display">
<pre class="display-preformatted">This is a <b class="b">bold</b> and here&rsquo;s <b class="b"><i class="i">bolditalic</i></b> and this is the end.
</pre></div>

<p>That is, the &ldquo;bold&rdquo; words are the <code class="code">bold</code> face, and the
&ldquo;italic&rdquo; word is in the <code class="code">italic</code> face.
</p>
<p>With point at the start:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(while (setq match (text-property-search-forward 'face 'bold t))
  (push (buffer-substring (prop-match-beginning match)
                          (prop-match-end match))
        words))
</pre></div>

<p>This will pick out all the words that use the <code class="code">bold</code> face.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(while (setq match (text-property-search-forward 'face nil t))
  (push (buffer-substring (prop-match-beginning match)
                          (prop-match-end match))
        words))
</pre></div>

<p>This will pick out all the bits that have no face properties, which
will result in the list &lsquo;<samp class="samp">(&quot;This&nbsp;is&nbsp;a&nbsp;&quot;<!-- /@w --> &quot;and&nbsp;here's&nbsp;&quot;<!-- /@w -->
&quot;and&nbsp;this&nbsp;is&nbsp;the&nbsp;end&quot;<!-- /@w -->)</samp>&rsquo; (only in reverse order, since we used
<code class="code">push</code>, see <a class="pxref" href="List-Variables.html">Modifying List Variables</a>).
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(while (setq match (text-property-search-forward 'face nil nil))
  (push (buffer-substring (prop-match-beginning match)
                          (prop-match-end match))
        words))
</pre></div>

<p>This will pick out all the regions where <code class="code">face</code> is set to
something, but this is split up into where the properties change, so
the result here will be &lsquo;<samp class="samp">(&quot;bold&quot; &quot;bold&quot; &quot;italic&quot;)</samp>&rsquo;.
</p>
<p>For a more realistic example where you might use this, consider that
you have a buffer where certain sections represent URLs, and these are
tagged with <code class="code">shr-url</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(while (setq match (text-property-search-forward 'shr-url nil nil))
  (push (prop-match-value match) urls))
</pre></div>

<p>This will give you a list of all those URLs.
</p>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-text_002dproperty_002dsearch_002dbackward"><span class="category-def">Function: </span><span><strong class="def-name">text-property-search-backward</strong> <var class="def-var-arguments">prop &amp;optional value predicate not-current</var><a class="copiable-link" href="#index-text_002dproperty_002dsearch_002dbackward"> &para;</a></span></dt>
<dd><p>This is just like <code class="code">text-property-search-forward</code>, but searches
backward instead, and if a match is found, point is placed at the
beginning of the matched region instead of the end.
</p></dd></dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Special-Properties.html">Properties with Special Meanings</a>, Previous: <a href="Changing-Properties.html">Changing Text Properties</a>, Up: <a href="Text-Properties.html">Text Properties</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
