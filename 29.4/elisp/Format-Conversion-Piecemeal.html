<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 29.4.

Copyright Â© 1990-1996, 1998-2024 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Format Conversion Piecemeal (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Format Conversion Piecemeal (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Format Conversion Piecemeal (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Format-Conversion.html" rel="up" title="Format Conversion">
<link href="Format-Conversion-Round_002dTrip.html" rel="prev" title="Format Conversion Round-Trip">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Format-Conversion-Piecemeal">
<div class="nav-panel">
<p>
Previous: <a href="Format-Conversion-Round_002dTrip.html" accesskey="p" rel="prev">Round-Trip Specification</a>, Up: <a href="Format-Conversion.html" accesskey="u" rel="up">File Format Conversion</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Piecemeal-Specification"><span>26.13.3 Piecemeal Specification<a class="copiable-link" href="#Piecemeal-Specification"> &para;</a></span></h4>

<p>In contrast to the round-trip specification described in the previous
subsection (see <a class="pxref" href="Format-Conversion-Round_002dTrip.html">Round-Trip Specification</a>), you can use the variables
<code class="code">after-insert-file-functions</code> and <code class="code">write-region-annotate-functions</code>
to separately control the respective reading and writing conversions.
</p>
<p>Conversion starts with one representation and produces another
representation.  When there is only one conversion to do, there is no
conflict about what to start with.  However, when there are multiple
conversions involved, conflict may arise when two conversions need to
start with the same data.
</p>
<p>This situation is best understood in the context of converting text
properties during <code class="code">write-region</code>.  For example, the character at
position 42 in a buffer is &lsquo;<samp class="samp">X</samp>&rsquo; with a text property <code class="code">foo</code>.  If
the conversion for <code class="code">foo</code> is done by inserting into the buffer, say,
&lsquo;<samp class="samp">FOO:</samp>&rsquo;, then that changes the character at position 42 from
&lsquo;<samp class="samp">X</samp>&rsquo; to &lsquo;<samp class="samp">F</samp>&rsquo;.  The next conversion will start with the wrong
data straight away.
</p>
<p>To avoid conflict, cooperative conversions do not modify the buffer,
but instead specify <em class="dfn">annotations</em>, a list of elements of the form
<code class="code">(<var class="var">position</var> . <var class="var">string</var>)</code>, sorted in order of increasing
<var class="var">position</var>.
</p>
<p>If there is more than one conversion, <code class="code">write-region</code> merges their
annotations destructively into one sorted list.  Later, when the text
from the buffer is actually written to the file, it intermixes the
specified annotations at the corresponding positions.  All this takes
place without modifying the buffer.
</p>

<p>In contrast, when reading, the annotations intermixed with the text
are handled immediately.  <code class="code">insert-file-contents</code> sets point to
the beginning of some text to be converted, then calls the conversion
functions with the length of that text.  These functions should always
return with point at the beginning of the inserted text.  This
approach makes sense for reading because annotations removed by the
first converter can&rsquo;t be mistakenly processed by a later converter.
Each conversion function should scan for the annotations it
recognizes, remove the annotation, modify the buffer text (to set a
text property, for example), and return the updated length of the
text, as it stands after those changes.  The value returned by one
function becomes the argument to the next function.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-write_002dregion_002dannotate_002dfunctions"><span class="category-def">Variable: </span><span><strong class="def-name">write-region-annotate-functions</strong><a class="copiable-link" href="#index-write_002dregion_002dannotate_002dfunctions"> &para;</a></span></dt>
<dd><p>A list of functions for <code class="code">write-region</code> to call.  Each function in
the list is called with two arguments: the start and end of the region
to be written.  These functions should not alter the contents of the
buffer.  Instead, they should return annotations.
</p>
<p>As a special case, a function may return with a different buffer
current.  Emacs takes this to mean that the current buffer contains
altered text to be output.  It therefore changes the <var class="var">start</var> and
<var class="var">end</var> arguments of the <code class="code">write-region</code> call, giving them the
values of <code class="code">point-min</code> and <code class="code">point-max</code> in the new buffer,
respectively.  It also discards all previous annotations, because they
should have been dealt with by this function.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-write_002dregion_002dpost_002dannotation_002dfunction"><span class="category-def">Variable: </span><span><strong class="def-name">write-region-post-annotation-function</strong><a class="copiable-link" href="#index-write_002dregion_002dpost_002dannotation_002dfunction"> &para;</a></span></dt>
<dd><p>The value of this variable, if non-<code class="code">nil</code>, should be a function.
This function is called, with no arguments, after <code class="code">write-region</code>
has completed.
</p>
<p>If any function in <code class="code">write-region-annotate-functions</code> returns with
a different buffer current, Emacs calls
<code class="code">write-region-post-annotation-function</code> more than once.  Emacs
calls it with the last buffer that was current, and again with the
buffer before that, and so on back to the original buffer.
</p>
<p>Thus, a function in <code class="code">write-region-annotate-functions</code> can create
a buffer, give this variable the local value of <code class="code">kill-buffer</code> in
that buffer, set up the buffer with altered text, and make the buffer
current.  The buffer will be killed after <code class="code">write-region</code> is done.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-after_002dinsert_002dfile_002dfunctions"><span class="category-def">Variable: </span><span><strong class="def-name">after-insert-file-functions</strong><a class="copiable-link" href="#index-after_002dinsert_002dfile_002dfunctions"> &para;</a></span></dt>
<dd><p>Each function in this list is called by <code class="code">insert-file-contents</code>
with one argument, the number of characters inserted, and with point
at the beginning of the inserted text.  Each function should leave
point unchanged, and return the new character count describing the
inserted text as modified by the function.
</p></dd></dl>

<p>We invite users to write Lisp programs to store and retrieve text
properties in files, using these hooks, and thus to experiment with
various data formats and find good ones.  Eventually we hope users
will produce good, general extensions we can install in Emacs.
</p>
<p>We suggest not trying to handle arbitrary Lisp objects as text property
names or values&mdash;because a program that general is probably difficult
to write, and slow.  Instead, choose a set of possible data types that
are reasonably flexible, and not too hard to encode.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Format-Conversion-Round_002dTrip.html">Round-Trip Specification</a>, Up: <a href="Format-Conversion.html">File Format Conversion</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
