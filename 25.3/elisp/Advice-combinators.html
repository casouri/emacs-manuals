<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 25.3.

Copyright Â© 1990-1996, 1998-2017 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<title>Advice combinators (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Advice combinators (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Advice combinators (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Advising-Functions.html" rel="up" title="Advising Functions">
<link href="Porting-old-advice.html" rel="next" title="Porting old advice">
<link href="Advising-Named-Functions.html" rel="prev" title="Advising Named Functions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Advice-combinators">
<div class="nav-panel">
<p>
Next: <a href="Porting-old-advice.html" accesskey="n" rel="next">Adapting code using the old defadvice</a>, Previous: <a href="Advising-Named-Functions.html" accesskey="p" rel="prev">Advising Named Functions</a>, Up: <a href="Advising-Functions.html" accesskey="u" rel="up">Advising Emacs Lisp Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Ways-to-compose-advice"><span>12.11.3 Ways to compose advice<a class="copiable-link" href="#Ways-to-compose-advice"> &para;</a></span></h4>

<p>Here are the different possible values for the <var class="var">where</var> argument of
<code class="code">add-function</code> and <code class="code">advice-add</code>, specifying how the advice
<var class="var">function</var> and the original function should be composed.
</p>
<dl class="table">
<dt><code class="code">:before</code></dt>
<dd><p>Call <var class="var">function</var> before the old function.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
</p><div class="example">
<pre class="example-preformatted">(lambda (&amp;rest r) (apply <var class="var">function</var> r) (apply <var class="var">oldfun</var> r))
</pre></div>
<p><code class="code">(add-function :before <var class="var">funvar</var> <var class="var">function</var>)</code> is comparable for
single-function hooks to <code class="code">(add-hook '<var class="var">hookvar</var> <var class="var">function</var>)</code> for
normal hooks.
</p>
</dd>
<dt><code class="code">:after</code></dt>
<dd><p>Call <var class="var">function</var> after the old function.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
</p><div class="example">
<pre class="example-preformatted">(lambda (&amp;rest r) (prog1 (apply <var class="var">oldfun</var> r) (apply <var class="var">function</var> r)))
</pre></div>
<p><code class="code">(add-function :after <var class="var">funvar</var> <var class="var">function</var>)</code> is comparable for
single-function hooks to <code class="code">(add-hook '<var class="var">hookvar</var> <var class="var">function</var>
'append)</code> for normal hooks.
</p>
</dd>
<dt><code class="code">:override</code></dt>
<dd><p>This completely replaces the old function with the new one.  The old function
can of course be recovered if you later call <code class="code">remove-function</code>.
</p>
</dd>
<dt><code class="code">:around</code></dt>
<dd><p>Call <var class="var">function</var> instead of the old function, but provide the old function
as an extra argument to <var class="var">function</var>.  This is the most flexible composition.
For example, it lets you call the old function with different arguments, or
many times, or within a let-binding, or you can sometimes delegate the work to
the old function and sometimes override it completely.  More specifically, the
composition of the two functions behaves like:
</p><div class="example">
<pre class="example-preformatted">(lambda (&amp;rest r) (apply <var class="var">function</var> <var class="var">oldfun</var> r))
</pre></div>

</dd>
<dt><code class="code">:before-while</code></dt>
<dd><p>Call <var class="var">function</var> before the old function and don&rsquo;t call the old
function if <var class="var">function</var> returns <code class="code">nil</code>.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
</p><div class="example">
<pre class="example-preformatted">(lambda (&amp;rest r) (and (apply <var class="var">function</var> r) (apply <var class="var">oldfun</var> r)))
</pre></div>
<p><code class="code">(add-function :before-while <var class="var">funvar</var> <var class="var">function</var>)</code> is comparable
for single-function hooks to <code class="code">(add-hook '<var class="var">hookvar</var> <var class="var">function</var>)</code>
when <var class="var">hookvar</var> is run via <code class="code">run-hook-with-args-until-failure</code>.
</p>
</dd>
<dt><code class="code">:before-until</code></dt>
<dd><p>Call <var class="var">function</var> before the old function and only call the old function if
<var class="var">function</var> returns <code class="code">nil</code>.  More specifically, the composition of the
two functions behaves like:
</p><div class="example">
<pre class="example-preformatted">(lambda (&amp;rest r) (or (apply <var class="var">function</var> r) (apply <var class="var">oldfun</var> r)))
</pre></div>
<p><code class="code">(add-function :before-until <var class="var">funvar</var> <var class="var">function</var>)</code> is comparable
for single-function hooks to <code class="code">(add-hook '<var class="var">hookvar</var> <var class="var">function</var>)</code>
when <var class="var">hookvar</var> is run via <code class="code">run-hook-with-args-until-success</code>.
</p>
</dd>
<dt><code class="code">:after-while</code></dt>
<dd><p>Call <var class="var">function</var> after the old function and only if the old function
returned non-<code class="code">nil</code>.  Both functions receive the same arguments, and the
return value of the composition is the return value of <var class="var">function</var>.
More specifically, the composition of the two functions behaves like:
</p><div class="example">
<pre class="example-preformatted">(lambda (&amp;rest r) (and (apply <var class="var">oldfun</var> r) (apply <var class="var">function</var> r)))
</pre></div>
<p><code class="code">(add-function :after-while <var class="var">funvar</var> <var class="var">function</var>)</code> is comparable
for single-function hooks to <code class="code">(add-hook '<var class="var">hookvar</var> <var class="var">function</var>
'append)</code> when <var class="var">hookvar</var> is run via
<code class="code">run-hook-with-args-until-failure</code>.
</p>
</dd>
<dt><code class="code">:after-until</code></dt>
<dd><p>Call <var class="var">function</var> after the old function and only if the old function
returned <code class="code">nil</code>.  More specifically, the composition of the two functions
behaves like:
</p><div class="example">
<pre class="example-preformatted">(lambda (&amp;rest r) (or  (apply <var class="var">oldfun</var> r) (apply <var class="var">function</var> r)))
</pre></div>
<p><code class="code">(add-function :after-until <var class="var">funvar</var> <var class="var">function</var>)</code> is comparable
for single-function hooks to <code class="code">(add-hook '<var class="var">hookvar</var> <var class="var">function</var>
'append)</code> when <var class="var">hookvar</var> is run via
<code class="code">run-hook-with-args-until-success</code>.
</p>
</dd>
<dt><code class="code">:filter-args</code></dt>
<dd><p>Call <var class="var">function</var> first and use the result (which should be a list) as the
new arguments to pass to the old function.  More specifically, the composition
of the two functions behaves like:
</p><div class="example">
<pre class="example-preformatted">(lambda (&amp;rest r) (apply <var class="var">oldfun</var> (funcall <var class="var">function</var> r)))
</pre></div>

</dd>
<dt><code class="code">:filter-return</code></dt>
<dd><p>Call the old function first and pass the result to <var class="var">function</var>.
More specifically, the composition of the two functions behaves like:
</p><div class="example">
<pre class="example-preformatted">(lambda (&amp;rest r) (funcall <var class="var">function</var> (apply <var class="var">oldfun</var> r)))
</pre></div>
</dd>
</dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Porting-old-advice.html">Adapting code using the old defadvice</a>, Previous: <a href="Advising-Named-Functions.html">Advising Named Functions</a>, Up: <a href="Advising-Functions.html">Advising Emacs Lisp Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
